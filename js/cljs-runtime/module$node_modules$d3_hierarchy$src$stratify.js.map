{
"version":3,
"file":"module$node_modules$d3_hierarchy$src$stratify.js",
"lineCount":6,
"mappings":"AAAAA,cAAA,CAAA,6CAAA,CAAkE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAkB1GC,QAASA,UAAS,CAACC,CAAD,CAAI,CACpB,MAAOA,EAAEC,CAAAA,EADW,CAItBC,QAASA,gBAAe,CAACF,CAAD,CAAI,CAC1B,MAAOA,EAAEG,CAAAA,QADiB,CA2H5BC,QAASA,SAAQ,CAACC,IAAD,CAAO,CACtB,IAAIC,EAAID,IAAKE,CAAAA,MACb,IAAQ,CAAR,CAAID,CAAJ,CAAW,MAAO,EAElB,KAAA,CAAa,CAAb,CAAO,EAAEA,CAAT,EAAoB,CAAAE,KAAA,CAAMH,IAAN,CAAYC,CAAZ,CAApB,CAAA,EAEA,MAAOD,KAAKI,CAAAA,KAAL,CAAW,CAAX,CAAcH,CAAd,CANe,CAYxBE,QAASA,MAAK,CAACH,IAAD,CAAOC,CAAP,CAAU,CACtB,GAAgB,GAAhB,GAAID,IAAA,CAAKC,CAAL,CAAJ,CAAqB,CACnB,IAAII,EAAI,CAER,KAAA,CAAW,CAAX,CAAOJ,CAAP,EAA8B,IAA9B,GAAgBD,IAAA,CAAK,EAAEC,CAAP,CAAhB,CAAA,CAAoC,EAAEI,CAEtC,IAAgB,CAAhB,IAAKA,CAAL,CAAS,CAAT,EAAmB,MAAO,CAAA,CALP,CAQrB,MAAO,CAAA,CATe,CA1JxBC,MAAOC,CAAAA,cAAP,CAAsBd,OAAtB,CAA+B,YAA/B,CAA6C,CAC3Ce,MAAO,CAAA,CADoC,CAA7C,CAGAf,QAAQgB,CAAAA,OAAR,CAoBAC,QAAiB,EAAG,CAKlBC,QAASA,SAAQ,CAACC,IAAD,CAAO,CAAA,IAClBC;AAAQC,KAAMC,CAAAA,IAAN,CAAWH,IAAX,CADU,CAElBI,UAAYpB,EAFM,CAGlBqB,gBAAkBnB,QAHA,CAIlBoB,CAJkB,CAUlBC,MAVkB,CAYlBC,UAAY,IAAIC,GAEpB,IAAY,IAAZ,EAAIrB,IAAJ,CAAkB,CAChB,MAAMsB,EAAIT,KAAMU,CAAAA,GAAN,CAAU,CAAC5B,CAAD,CAAIM,CAAJ,CAAA,EAAU,CAAU,CAAA,CAAAD,IAAA,CAAKL,CAAL,CAAQM,CAAR,CAAWW,IAAX,CA0F5CZ,EAAA,CAAQ,GAAEA,CAAF,EACJC,EAAAA,CAAID,CAAKE,CAAAA,MACTC,MAAA,CAAMH,CAAN,CAAYC,CAAZ,CAAgB,CAAhB,CAAJ,EAA0B,CAACE,KAAA,CAAMH,CAAN,CAAYC,CAAZ,CAAgB,CAAhB,CAA3B,GAA+CD,CAA/C,CAAsDA,CAAKI,CAAAA,KAAL,CAAW,CAAX,CAAc,CAAC,CAAf,CAAtD,CA5FkC,OA6Ff,GAAZ,GAAAJ,CAAA,CAAK,CAAL,CAAA,CAAkBA,CAAlB,CAA0B,IAAGA,CAAH,EA7FC,CAApB,CAAV,CACMwB,EAAIF,CAAEC,CAAAA,GAAF,CAAMxB,QAAN,CACJ0B,UAAAA,CAAeC,CAAX,IAAIC,GAAJ,CAAQL,CAAR,CAAWI,EAAAA,GAAX,CAAe,EAAf,CAEV,KAAWzB,aAAX,GAAgBuB,EAAhB,CACOC,SAAEG,CAAAA,GAAF,CAAM3B,aAAN,CAAL,GACEwB,SAAEC,CAAAA,GAAF,CAAMzB,aAAN,CAGA,CAFAqB,CAAEO,CAAAA,IAAF,CAAO5B,aAAP,CAEA,CADAuB,CAAEK,CAAAA,IAAF,CAAO9B,QAAA,CAASE,aAAT,CAAP,CACA,CAAAY,KAAMgB,CAAAA,IAAN,CAAWC,OAAX,CAJF,CAQFd,UAAA,CAAY,CAACe,CAAD,CAAI9B,CAAJ,CAAAe,EAAUM,CAAA,CAAErB,CAAF,CAEtBgB,gBAAA,CAAkB,CAACc,CAAD,CAAI9B,CAAJ,CAAAgB,EAAUO,CAAA,CAAEvB,CAAF,CAhBZ,CAmBb,IAAAA;AAAI,CAAT,KAAYiB,CAAZ,CAAgBL,KAAMX,CAAAA,MAAtB,CAA8BD,UAA9B,CAAkCiB,CAAlC,CAAqC,EAAEjB,UAAvC,CAA0C,CACxC,IAAAN,WAAIkB,KAAA,CAAMZ,UAAN,CAAU,KAAA+B,cAAOnB,KAAA,CAAMZ,UAAN,CAAP+B,CAAkB,IAAIC,MAAOC,CAAAA,IAAX,CAAgBvC,UAAhB,CAEhC,IAAwC,IAAxC,GAAKwB,MAAL,CAAcH,SAAA,CAAUrB,UAAV,CAAaM,UAAb,CAAgBW,IAAhB,CAAd,IAAiDO,MAAjD,EAA2D,EAA3D,EAAgE,CAC9D,IAAAgB,QAAUH,aAAKpC,CAAAA,EAAfuC,CAAoBhB,MACpBC,UAAUgB,CAAAA,GAAV,CAAcD,OAAd,CAAuBf,SAAUQ,CAAAA,GAAV,CAAcO,OAAd,CAAA,CAAyBE,SAAzB,CAAqCL,aAA5D,CAF8D,CAKlB,IAA9C,GAAKb,MAAL,CAAcF,eAAA,CAAgBtB,UAAhB,CAAmBM,UAAnB,CAAsBW,IAAtB,CAAd,IAAuDO,MAAvD,EAAiE,EAAjE,IACEa,aAAKM,CAAAA,MADP,CACgBnB,MADhB,CARwC,CAa1C,IAAKlB,UAAL,CAAS,CAAT,CAAYA,UAAZ,CAAgBiB,CAAhB,CAAmB,EAAEjB,UAArB,CAGE,GAFA+B,aAEI,CAFGnB,KAAA,CAAMZ,UAAN,CAEH;AAAAkB,MAAA,CAASa,aAAKM,CAAAA,MAAlB,CAA0B,CACxBA,SAAA,CAASlB,SAAUmB,CAAAA,GAAV,CAAcpB,MAAd,CACT,IAAI,CAACmB,SAAL,CAAa,KAAUE,MAAJ,CAAU,WAAV,CAAwBrB,MAAxB,CAAN,CACb,GAAImB,SAAJ,GAAeD,SAAf,CAA0B,KAAUG,MAAJ,CAAU,aAAV,CAA0BrB,MAA1B,CAAN,CACtBmB,SAAOG,CAAAA,QAAX,CAAqBH,SAAOG,CAAAA,QAASZ,CAAAA,IAAhB,CAAqBG,aAArB,CAArB,CAAqDM,SAAOG,CAAAA,QAA5D,CAAuE,CAACT,aAAD,CACvEA,cAAKM,CAAAA,MAAL,CAAcA,SALU,CAA1B,IAMO,CACL,GAAII,IAAJ,CAAU,KAAUF,MAAJ,CAAU,gBAAV,CAAN,CACV,IAAAE,KAAOV,aAFF,CAMT,GAAI,CAACU,IAAL,CAAW,KAAUF,MAAJ,CAAU,SAAV,CAAN,CAGX,GAAY,IAAZ,EAAIxC,IAAJ,CAAkB,CAChB,IAAA,CAAO0C,IAAK9B,CAAAA,IAAZ,GAAqBkB,OAArB,EAAyD,CAAzD,GAAgCY,IAAKD,CAAAA,QAASvC,CAAAA,MAA9C,CAAA,CACEwC,IAAyB,CAAlBA,IAAKD,CAAAA,QAAL,CAAc,CAAd,CAAkB,CAAA,EAAEvB,CAG7B,KAASjB,MAAT,CAAaY,KAAMX,CAAAA,MAAnB;AAA4B,CAA5B,CAAoC,CAApC,EAA+BD,MAA/B,CAAuC,EAAEA,MAAzC,CAA4C,CAC1C+B,aAAA,CAAOnB,KAAA,CAAMZ,MAAN,CACP,IAAI+B,aAAKpB,CAAAA,IAAT,GAAkBkB,OAAlB,CAA2B,KAC3BE,cAAKpB,CAAAA,IAAL,CAAY,IAH8B,CAL5B,CAYlB8B,IAAKJ,CAAAA,MAAL,CAAcK,OACdD,KAAKE,CAAAA,UAAL,CAAgB,QAAS,CAACZ,IAAD,CAAO,CAC9BA,IAAKa,CAAAA,KAAL,CAAab,IAAKM,CAAAA,MAAOO,CAAAA,KAAzB,CAAiC,CACjC,GAAE3B,CAF4B,CAAhC,CAGG0B,CAAAA,UAHH,CAGcX,MAAOa,CAAAA,aAHrB,CAIAJ,KAAKJ,CAAAA,MAAL,CAAc,IACd,IAAQ,CAAR,CAAIpB,CAAJ,CAAW,KAAUsB,MAAJ,CAAU,OAAV,CAAN,CACX,MAAOE,KAnFe,CALN,IACd9C,GAAKF,SADS,CAEdI,SAAWD,eAFG,CAGdG,IAwFJW,SAASf,CAAAA,EAAT,CAAcmD,QAAS,CAACC,CAAD,CAAI,CACzB,MAAOC,UAAU/C,CAAAA,MAAV,EAAoBN,EAAA,CAAK,GAAIsD,UAAWC,CAAAA,QAAf,EAAyBH,CAAzB,CAAL,CAAkCrC,QAAtD,EAAkEf,EADhD,CAI3Be,SAASb,CAAAA,QAAT,CAAoBsD,QAAS,CAACJ,CAAD,CAAI,CAC/B,MAAOC,UAAU/C,CAAAA,MAAV,EAAoBJ,QAAA,CAAW,GAAIoD,UAAWC,CAAAA,QAAf,EAAyBH,CAAzB,CAAX;AAAwCrC,QAA5D,EAAwEb,QADhD,CAIjCa,SAASX,CAAAA,IAAT,CAAgBqD,QAAS,CAACL,CAAD,CAAI,CAC3B,MAAOC,UAAU/C,CAAAA,MAAV,EAAoBF,IAAA,CAAO,GAAIkD,UAAWC,CAAAA,QAAf,EAAyBH,CAAzB,CAAP,CAAoCrC,QAAxD,EAAoEX,IADhD,CAI7B,OAAOW,SAvGW,CAlBpB,KAAIuC,WAAa3D,OAAA,CAAQ,gDAAR,CAAjB,CAEI0C,OAAS1C,OAAA,CAAQ,sDAAR,CAFb,CAIIoD,QAAU,CACZE,MAAO,CAAC,CADI,CAJd,CAOIR,UAAY,EAPhB,CAQIP,QAAU,EAhB4F;",
"sources":["node_modules/d3-hierarchy/src/stratify.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$d3_hierarchy$src$stratify\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _accessors = require(\"./accessors.js\");\n\nvar _index = require(\"./hierarchy/index.js\");\n\nvar preroot = {\n  depth: -1\n},\n    ambiguous = {},\n    imputed = {};\n\nfunction defaultId(d) {\n  return d.id;\n}\n\nfunction defaultParentId(d) {\n  return d.parentId;\n}\n\nfunction _default() {\n  var id = defaultId,\n      parentId = defaultParentId,\n      path;\n\n  function stratify(data) {\n    var nodes = Array.from(data),\n        currentId = id,\n        currentParentId = parentId,\n        n,\n        d,\n        i,\n        root,\n        parent,\n        node,\n        nodeId,\n        nodeKey,\n        nodeByKey = new Map();\n\n    if (path != null) {\n      const I = nodes.map((d, i) => normalize(path(d, i, data)));\n      const P = I.map(parentof);\n      const S = new Set(I).add(\"\");\n\n      for (const i of P) {\n        if (!S.has(i)) {\n          S.add(i);\n          I.push(i);\n          P.push(parentof(i));\n          nodes.push(imputed);\n        }\n      }\n\n      currentId = (_, i) => I[i];\n\n      currentParentId = (_, i) => P[i];\n    }\n\n    for (i = 0, n = nodes.length; i < n; ++i) {\n      d = nodes[i], node = nodes[i] = new _index.Node(d);\n\n      if ((nodeId = currentId(d, i, data)) != null && (nodeId += \"\")) {\n        nodeKey = node.id = nodeId;\n        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);\n      }\n\n      if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += \"\")) {\n        node.parent = nodeId;\n      }\n    }\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i];\n\n      if (nodeId = node.parent) {\n        parent = nodeByKey.get(nodeId);\n        if (!parent) throw new Error(\"missing: \" + nodeId);\n        if (parent === ambiguous) throw new Error(\"ambiguous: \" + nodeId);\n        if (parent.children) parent.children.push(node);else parent.children = [node];\n        node.parent = parent;\n      } else {\n        if (root) throw new Error(\"multiple roots\");\n        root = node;\n      }\n    }\n\n    if (!root) throw new Error(\"no root\"); // When imputing internal nodes, only introduce roots if needed.\n    // Then replace the imputed marker data with null.\n\n    if (path != null) {\n      while (root.data === imputed && root.children.length === 1) {\n        root = root.children[0], --n;\n      }\n\n      for (let i = nodes.length - 1; i >= 0; --i) {\n        node = nodes[i];\n        if (node.data !== imputed) break;\n        node.data = null;\n      }\n    }\n\n    root.parent = preroot;\n    root.eachBefore(function (node) {\n      node.depth = node.parent.depth + 1;\n      --n;\n    }).eachBefore(_index.computeHeight);\n    root.parent = null;\n    if (n > 0) throw new Error(\"cycle\");\n    return root;\n  }\n\n  stratify.id = function (x) {\n    return arguments.length ? (id = (0, _accessors.optional)(x), stratify) : id;\n  };\n\n  stratify.parentId = function (x) {\n    return arguments.length ? (parentId = (0, _accessors.optional)(x), stratify) : parentId;\n  };\n\n  stratify.path = function (x) {\n    return arguments.length ? (path = (0, _accessors.optional)(x), stratify) : path;\n  };\n\n  return stratify;\n} // To normalize a path, we coerce to a string, strip the trailing slash if any\n// (as long as the trailing slash is not immediately preceded by another slash),\n// and add leading slash if missing.\n\n\nfunction normalize(path) {\n  path = `${path}`;\n  let i = path.length;\n  if (slash(path, i - 1) && !slash(path, i - 2)) path = path.slice(0, -1);\n  return path[0] === \"/\" ? path : `/${path}`;\n} // Walk backwards to find the first slash that is not the leading slash, e.g.:\n// \"/foo/bar\" \u21e5 \"/foo\", \"/foo\" \u21e5 \"/\", \"/\" \u21a6 \"\". (The root is special-cased\n// because the id of the root must be a truthy value.)\n\n\nfunction parentof(path) {\n  let i = path.length;\n  if (i < 2) return \"\";\n\n  while (--i > 1) if (slash(path, i)) break;\n\n  return path.slice(0, i);\n} // Slashes can be escaped; to determine whether a slash is a path delimiter, we\n// count the number of preceding backslashes escaping the forward slash: an odd\n// number indicates an escaped forward slash.\n\n\nfunction slash(path, i) {\n  if (path[i] === \"/\") {\n    let k = 0;\n\n    while (i > 0 && path[--i] === \"\\\\\") ++k;\n\n    if ((k & 1) === 0) return true;\n  }\n\n  return false;\n}\n};"],
"names":["shadow$provide","global","require","module","exports","defaultId","d","id","defaultParentId","parentId","parentof","path","i","length","slash","slice","k","Object","defineProperty","value","default","_default","stratify","data","nodes","Array","from","currentId","currentParentId","n","nodeId","nodeByKey","Map","I","map","P","S","add","Set","has","push","imputed","_","node","_index","Node","nodeKey","set","ambiguous","parent","get","Error","children","root","preroot","eachBefore","depth","computeHeight","stratify.id","x","arguments","_accessors","optional","stratify.parentId","stratify.path"]
}
