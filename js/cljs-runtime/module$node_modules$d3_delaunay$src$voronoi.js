shadow$provide.module$node_modules$d3_delaunay$src$voronoi=function(global,require,module,exports){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;var _path=_interopRequireDefault(require("module$node_modules$d3_delaunay$src$path")),_polygon=_interopRequireDefault(require("module$node_modules$d3_delaunay$src$polygon"));class Voronoi{constructor(delaunay,[xmin,ymin,xmax,ymax]=[0,0,960,500]){if(!((xmax=
+xmax)>=(xmin=+xmin)&&(ymax=+ymax)>=(ymin=+ymin)))throw Error("invalid bounds");this.delaunay=delaunay;this._circumcenters=new Float64Array(2*delaunay.points.length);this.vectors=new Float64Array(2*delaunay.points.length);this.xmax=xmax;this.xmin=xmin;this.ymax=ymax;this.ymin=ymin;this._init()}update(){this.delaunay.update();this._init();return this}_init(){const {delaunay:{points,hull,triangles},vectors}=this;var circumcenters=this.circumcenters=this._circumcenters.subarray(0,triangles.length/3*
2);for(let i=0,j=0,n=triangles.length,x,y;i<n;i+=3,j+=2){var t1=2*triangles[i],t2=2*triangles[i+1],t3=2*triangles[i+2],x1=points[t1];t1=points[t1+1];var x3=points[t3],y3=points[t3+1],dx=points[t2]-x1,dy=points[t2+1]-t1;t2=x3-x1;t3=y3-t1;var ab=2*(dx*t3-dy*t2);1E-9>Math.abs(ab)?(dx=1E9,dy=2*triangles[0],dx*=Math.sign((points[dy]-x1)*t3-(points[dy+1]-t1)*t2),x=(x1+x3)/2-dx*t3,y=(t1+y3)/2+dx*t2):(x3=1/ab,y3=dx*dx+dy*dy,ab=t2*t2+t3*t3,x=x1+(t3*y3-dy*ab)*x3,y=t1+(dx*ab-t2*y3)*x3);circumcenters[j]=x;circumcenters[j+
1]=y}circumcenters=hull[hull.length-1];t1=4*circumcenters;t3=points[2*circumcenters];dx=points[2*circumcenters+1];vectors.fill(0);for(y3=0;y3<hull.length;++y3)circumcenters=hull[y3],x1=t1,t2=t3,x3=dx,t1=4*circumcenters,t3=points[2*circumcenters],dx=points[2*circumcenters+1],vectors[x1+2]=vectors[t1]=x3-dx,vectors[x1+3]=vectors[t1+1]=t3-t2}render(context){const buffer=null==context?context=new _path.default:void 0,{delaunay:{halfedges,inedges,hull},circumcenters,vectors}=this;if(1>=hull.length)return null;
for(let i=0,n=halfedges.length;i<n;++i){var j=halfedges[i];if(!(j<i)){var ti=2*Math.floor(i/3);j=2*Math.floor(j/3);this._renderSegment(circumcenters[ti],circumcenters[ti+1],circumcenters[j],circumcenters[j+1],context)}}ti=hull[hull.length-1];for(j=0;j<hull.length;++j){var h0=ti;ti=hull[j];var t=2*Math.floor(inedges[ti]/3);const x=circumcenters[t];t=circumcenters[t+1];h0*=4;(h0=this._project(x,t,vectors[h0+2],vectors[h0+3]))&&this._renderSegment(x,t,h0[0],h0[1],context)}return buffer&&buffer.value()}renderBounds(context){const buffer=
null==context?context=new _path.default:void 0;context.rect(this.xmin,this.ymin,this.xmax-this.xmin,this.ymax-this.ymin);return buffer&&buffer.value()}renderCell(i$jscomp$0,context){const buffer=null==context?context=new _path.default:void 0;i$jscomp$0=this._clip(i$jscomp$0);if(null!==i$jscomp$0&&i$jscomp$0.length){context.moveTo(i$jscomp$0[0],i$jscomp$0[1]);for(var n=i$jscomp$0.length;i$jscomp$0[0]===i$jscomp$0[n-2]&&i$jscomp$0[1]===i$jscomp$0[n-1]&&1<n;)n-=2;for(let i=2;i<n;i+=2)i$jscomp$0[i]===
i$jscomp$0[i-2]&&i$jscomp$0[i+1]===i$jscomp$0[i-1]||context.lineTo(i$jscomp$0[i],i$jscomp$0[i+1]);context.closePath();return buffer&&buffer.value()}}*cellPolygons(){var {delaunay:{points}}=this;for(let i=0,n=points.length/2;i<n;++i)if(points=this.cellPolygon(i))points.index=i,yield points}cellPolygon(i){const polygon=new _polygon.default;this.renderCell(i,polygon);return polygon.value()}_renderSegment(x0,y0,x1,y1,context){const c0=this._regioncode(x0,y0),c1=this._regioncode(x1,y1);if(0===c0&&0===
c1)context.moveTo(x0,y0),context.lineTo(x1,y1);else if(x0=this._clipSegment(x0,y0,x1,y1,c0,c1))context.moveTo(x0[0],x0[1]),context.lineTo(x0[2],x0[3])}contains(i,x,y){return(x=+x,x!==x)||(y=+y,y!==y)?!1:this.delaunay._step(i,x,y)===i}*neighbors(i){const ci=this._clip(i);if(ci)for(const j of this.delaunay.neighbors(i))if(i=this._clip(j))a:for(let ai=0,li=ci.length;ai<li;ai+=2)for(let aj=0,lj=i.length;aj<lj;aj+=2)if(ci[ai]==i[aj]&&ci[ai+1]==i[aj+1]&&ci[(ai+2)%li]==i[(aj+lj-2)%lj]&&ci[(ai+3)%li]==i[(aj+
lj-1)%lj]){yield j;break a}}_cell(i){const {circumcenters,delaunay:{inedges,halfedges,triangles}}=this,e0=inedges[i];if(-1===e0)return null;const points=[];let e=e0;do{const t=Math.floor(e/3);points.push(circumcenters[2*t],circumcenters[2*t+1]);e=2===e%3?e-2:e+1;if(triangles[e]!==i)break;e=halfedges[e]}while(e!==e0&&-1!==e);return points}_clip(i){if(0===i&&1===this.delaunay.hull.length)return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];const points=this._cell(i);
if(null===points)return null;const {vectors:V}=this,v=4*i;return V[v]||V[v+1]?this._clipInfinite(i,points,V[v],V[v+1],V[v+2],V[v+3]):this._clipFinite(i,points)}_clipFinite(i,points){const n=points.length;let P=null;let x1=points[n-2],y1=points[n-1];let c1=this._regioncode(x1,y1),e1=0;for(let j=0;j<n;j+=2){var x0=x1;var y0=y1;x1=points[j];y1=points[j+1];var c0=c1;c1=this._regioncode(x1,y1);if(0===c0&&0===c1)e1=0,P?P.push(x1,y1):P=[x1,y1];else{let sx1,sy1;if(0===c0){if(null===(x0=this._clipSegment(x0,
y0,x1,y1,c0,c1)))continue;[y0,c0,sx1,sy1]=x0}else{if(null===(x0=this._clipSegment(x1,y1,x0,y0,c1,c0)))continue;[sx1,sy1,y0,c0]=x0;x0=e1;e1=this._edgecode(y0,c0);x0&&e1&&this._edge(i,x0,e1,P,P.length);P?P.push(y0,c0):P=[y0,c0]}x0=e1;e1=this._edgecode(sx1,sy1);x0&&e1&&this._edge(i,x0,e1,P,P.length);P?P.push(sx1,sy1):P=[sx1,sy1]}}if(P)x0=e1,e1=this._edgecode(P[0],P[1]),x0&&e1&&this._edge(i,x0,e1,P,P.length);else if(this.contains(i,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2))return[this.xmax,this.ymin,
this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];return P}_clipSegment(x0,y0,x1,y1,c0,c1){for(;;){if(0===c0&&0===c1)return[x0,y0,x1,y1];if(c0&c1)return null;var x=void 0;let y;x=c0||c1;x&8?(x=x0+(x1-x0)*(this.ymax-y0)/(y1-y0),y=this.ymax):x&4?(x=x0+(x1-x0)*(this.ymin-y0)/(y1-y0),y=this.ymin):x&2?(y=y0+(y1-y0)*(this.xmax-x0)/(x1-x0),x=this.xmax):(y=y0+(y1-y0)*(this.xmin-x0)/(x1-x0),x=this.xmin);c0?(x0=x,y0=y,c0=this._regioncode(x0,y0)):(x1=x,y1=y,c1=this._regioncode(x1,y1))}}_clipInfinite(i,
points,vx0,vy0,vxn,vyn){points=Array.from(points);let p;(p=this._project(points[0],points[1],vx0,vy0))&&points.unshift(p[0],p[1]);(p=this._project(points[points.length-2],points[points.length-1],vxn,vyn))&&points.push(p[0],p[1]);if(points=this._clipFinite(i,points))for(let j=0,n=points.length,c0,c1=this._edgecode(points[n-2],points[n-1]);j<n;j+=2)c0=c1,c1=this._edgecode(points[j],points[j+1]),c0&&c1&&(j=this._edge(i,c0,c1,points,j),n=points.length);else this.contains(i,(this.xmin+this.xmax)/2,(this.ymin+
this.ymax)/2)&&(points=[this.xmin,this.ymin,this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax]);return points}_edge(i,e0,e1,P,j){for(;e0!==e1;){let x,y;switch(e0){case 5:e0=4;continue;case 4:e0=6;x=this.xmax;y=this.ymin;break;case 6:e0=2;continue;case 2:e0=10;x=this.xmax;y=this.ymax;break;case 10:e0=8;continue;case 8:e0=9;x=this.xmin;y=this.ymax;break;case 9:e0=1;continue;case 1:e0=5,x=this.xmin,y=this.ymin}P[j]===x&&P[j+1]===y||!this.contains(i,x,y)||(P.splice(j,0,x,y),j+=2)}if(4<P.length)for(i=
0;i<P.length;i+=2)if(e0=(i+2)%P.length,e1=(i+4)%P.length,P[i]===P[e0]&&P[e0]===P[e1]||P[i+1]===P[e0+1]&&P[e0+1]===P[e1+1])P.splice(e0,2),i-=2;return j}_project(x0,y0,vx,vy){let t=Infinity,c,x,y;if(0>vy){if(y0<=this.ymin)return null;(c=(this.ymin-y0)/vy)<t&&(y=this.ymin,x=x0+(t=c)*vx)}else if(0<vy){if(y0>=this.ymax)return null;(c=(this.ymax-y0)/vy)<t&&(y=this.ymax,x=x0+(t=c)*vx)}if(0<vx){if(x0>=this.xmax)return null;(c=(this.xmax-x0)/vx)<t&&(x=this.xmax,y=y0+c*vy)}else if(0>vx){if(x0<=this.xmin)return null;
(c=(this.xmin-x0)/vx)<t&&(x=this.xmin,y=y0+c*vy)}return[x,y]}_edgecode(x,y){return(x===this.xmin?1:x===this.xmax?2:0)|(y===this.ymin?4:y===this.ymax?8:0)}_regioncode(x,y){return(x<this.xmin?1:x>this.xmax?2:0)|(y<this.ymin?4:y>this.ymax?8:0)}}exports.default=Voronoi}
//# sourceMappingURL=module$node_modules$d3_delaunay$src$voronoi.js.map
