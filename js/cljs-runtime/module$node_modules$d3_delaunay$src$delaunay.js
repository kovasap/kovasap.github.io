shadow$provide.module$node_modules$d3_delaunay$src$delaunay=function(global,require,module,exports){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function pointX(p){return p[0]}function pointY(p){return p[1]}function collinear$jscomp$0(d){const {triangles,coords}=d;for(d=0;d<triangles.length;d+=3){const a=2*triangles[d],b=2*triangles[d+1],c=2*triangles[d+2];if(1E-10<(coords[c]-coords[a])*(coords[b+1]-coords[a+1])-(coords[b]-coords[a])*(coords[c+1]-coords[a+1]))return!1}return!0}
function jitter(x,y,r){return[x+Math.sin(x+y)*r,y+Math.cos(x-y)*r]}function*flatIterable(points,fx,fy,that){let i=0;for(const p of points)yield fx.call(that,p,i,points),yield fy.call(that,p,i,points),++i}Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;var _delaunator=_interopRequireDefault(require("module$node_modules$delaunator$index")),_path=_interopRequireDefault(require("module$node_modules$d3_delaunay$src$path")),_polygon=_interopRequireDefault(require("module$node_modules$d3_delaunay$src$polygon")),
_voronoi=_interopRequireDefault(require("module$node_modules$d3_delaunay$src$voronoi"));const tau=2*Math.PI,pow=Math.pow;class Delaunay{static from(points,fx=pointX,fy=pointY,that){if("length"in points){const n=points.length,array=new Float64Array(2*n);for(let i=0;i<n;++i){const p=points[i];array[2*i]=fx.call(that,p,i,points);array[2*i+1]=fy.call(that,p,i,points)}points=array}else points=Float64Array.from(flatIterable(points,fx,fy,that));return new Delaunay(points)}constructor(points){this._delaunator=
new _delaunator.default(points);this.inedges=new Int32Array(points.length/2);this._hullIndex=new Int32Array(points.length/2);this.points=this._delaunator.coords;this._init()}update(){this._delaunator.update();this._init();return this}_init(){var d=this._delaunator;const points=this.points;if(d.hull&&2<d.hull.length&&collinear$jscomp$0(d)){this.collinear=Int32Array.from({length:points.length/2},(_,i)=>i).sort((i,j)=>points[2*i]-points[2*j]||points[2*i+1]-points[2*j+1]);d=this.collinear[0];var f=this.collinear[this.collinear.length-
1];d=[points[2*d],points[2*d+1],points[2*f],points[2*f+1]];d=1E-8*Math.hypot(d[3]-d[1],d[2]-d[0]);for(let i=0,n=points.length/2;i<n;++i)f=jitter(points[2*i],points[2*i+1],d),points[2*i]=f[0],points[2*i+1]=f[1];this._delaunator=new _delaunator.default(points)}else delete this.collinear;d=this.halfedges=this._delaunator.halfedges;f=this.hull=this._delaunator.hull;const triangles=this.triangles=this._delaunator.triangles,inedges=this.inedges.fill(-1),hullIndex=this._hullIndex.fill(-1);for(let e=0,n=
d.length;e<n;++e){const p=triangles[2===e%3?e-2:e+1];if(-1===d[e]||-1===inedges[p])inedges[p]=e}for(let i=0,n=f.length;i<n;++i)hullIndex[f[i]]=i;2>=f.length&&0<f.length&&(this.triangles=(new Int32Array(3)).fill(-1),this.halfedges=(new Int32Array(3)).fill(-1),this.triangles[0]=f[0],inedges[f[0]]=1,2===f.length&&(inedges[f[1]]=0,this.triangles[1]=f[1],this.triangles[2]=f[1]))}voronoi(bounds){return new _voronoi.default(this,bounds)}*neighbors(i){const {inedges,hull,_hullIndex,halfedges,triangles,collinear}=
this;if(collinear){var l=collinear.indexOf(i);0<l&&(yield collinear[l-1]);l<collinear.length-1&&(yield collinear[l+1])}else{var e0=inedges[i];if(-1!==e0){var e=e0;do{yield(l=triangles[e]);e=2===e%3?e-2:e+1;if(triangles[e]!==i)break;e=halfedges[e];if(-1===e){i=hull[(_hullIndex[i]+1)%hull.length];i!==l&&(yield i);break}}while(e!==e0)}}}find(x,y,i=0){if((x=+x,x!==x)||(y=+y,y!==y))return-1;const i0=i;let c;for(;0<=(c=this._step(i,x,y))&&c!==i&&c!==i0;)i=c;return c}_step(i,x,y){const {inedges,hull,_hullIndex,
halfedges,triangles,points}=this;if(-1===inedges[i]||!points.length)return(i+1)%(points.length>>1);let c=i,dc=pow(x-points[2*i],2)+pow(y-points[2*i+1],2);const e0=inedges[i];let e=e0;do{let t=triangles[e];const dt=pow(x-points[2*t],2)+pow(y-points[2*t+1],2);dt<dc&&(dc=dt,c=t);e=2===e%3?e-2:e+1;if(triangles[e]!==i)break;e=halfedges[e];if(-1===e){e=hull[(_hullIndex[i]+1)%hull.length];if(e!==t&&pow(x-points[2*e],2)+pow(y-points[2*e+1],2)<dc)return e;break}}while(e!==e0);return c}render(context){const buffer=
null==context?context=new _path.default:void 0,{points,halfedges,triangles}=this;for(let i=0,n=halfedges.length;i<n;++i){var j=halfedges[i];if(j<i)continue;const ti=2*triangles[i];j=2*triangles[j];context.moveTo(points[ti],points[ti+1]);context.lineTo(points[j],points[j+1])}this.renderHull(context);return buffer&&buffer.value()}renderPoints(context,r){void 0!==r||context&&"function"===typeof context.moveTo||(r=context,context=null);r=void 0==r?2:+r;const buffer=null==context?context=new _path.default:
void 0,{points}=this;for(let i=0,n=points.length;i<n;i+=2){const x=points[i],y=points[i+1];context.moveTo(x+r,y);context.arc(x,y,r,0,tau)}return buffer&&buffer.value()}renderHull(context){const buffer=null==context?context=new _path.default:void 0,{hull,points}=this;var h$jscomp$0=2*hull[0];const n=hull.length;context.moveTo(points[h$jscomp$0],points[h$jscomp$0+1]);for(h$jscomp$0=1;h$jscomp$0<n;++h$jscomp$0){const h=2*hull[h$jscomp$0];context.lineTo(points[h],points[h+1])}context.closePath();return buffer&&
buffer.value()}hullPolygon(){const polygon=new _polygon.default;this.renderHull(polygon);return polygon.value()}renderTriangle(i,context){const buffer=null==context?context=new _path.default:void 0,{points,triangles}=this,t0=2*triangles[i*=3],t1=2*triangles[i+1];i=2*triangles[i+2];context.moveTo(points[t0],points[t0+1]);context.lineTo(points[t1],points[t1+1]);context.lineTo(points[i],points[i+1]);context.closePath();return buffer&&buffer.value()}*trianglePolygons(){const {triangles}=this;for(let i=
0,n=triangles.length/3;i<n;++i)yield this.trianglePolygon(i)}trianglePolygon(i){const polygon=new _polygon.default;this.renderTriangle(i,polygon);return polygon.value()}}exports.default=Delaunay}
//# sourceMappingURL=module$node_modules$d3_delaunay$src$delaunay.js.map
