{
"version":3,
"file":"module$node_modules$d3_geo$src$polygonContains.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/d3-geo/src/polygonContains.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$d3_geo$src$polygonContains\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _d3Array = require(\"d3-array\");\n\nvar _cartesian = require(\"./cartesian.js\");\n\nvar _math = require(\"./math.js\");\n\nfunction longitude(point) {\n  return (0, _math.abs)(point[0]) <= _math.pi ? point[0] : (0, _math.sign)(point[0]) * (((0, _math.abs)(point[0]) + _math.pi) % _math.tau - _math.pi);\n}\n\nfunction _default(polygon, point) {\n  var lambda = longitude(point),\n      phi = point[1],\n      sinPhi = (0, _math.sin)(phi),\n      normal = [(0, _math.sin)(lambda), -(0, _math.cos)(lambda), 0],\n      angle = 0,\n      winding = 0;\n  var sum = new _d3Array.Adder();\n  if (sinPhi === 1) phi = _math.halfPi + _math.epsilon;else if (sinPhi === -1) phi = -_math.halfPi - _math.epsilon;\n\n  for (var i = 0, n = polygon.length; i < n; ++i) {\n    if (!(m = (ring = polygon[i]).length)) continue;\n    var ring,\n        m,\n        point0 = ring[m - 1],\n        lambda0 = longitude(point0),\n        phi0 = point0[1] / 2 + _math.quarterPi,\n        sinPhi0 = (0, _math.sin)(phi0),\n        cosPhi0 = (0, _math.cos)(phi0);\n\n    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n      var point1 = ring[j],\n          lambda1 = longitude(point1),\n          phi1 = point1[1] / 2 + _math.quarterPi,\n          sinPhi1 = (0, _math.sin)(phi1),\n          cosPhi1 = (0, _math.cos)(phi1),\n          delta = lambda1 - lambda0,\n          sign = delta >= 0 ? 1 : -1,\n          absDelta = sign * delta,\n          antimeridian = absDelta > _math.pi,\n          k = sinPhi0 * sinPhi1;\n      sum.add((0, _math.atan2)(k * sign * (0, _math.sin)(absDelta), cosPhi0 * cosPhi1 + k * (0, _math.cos)(absDelta)));\n      angle += antimeridian ? delta + sign * _math.tau : delta; // Are the longitudes either side of the point\u2019s meridian (lambda),\n      // and are the latitudes smaller than the parallel (phi)?\n\n      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n        var arc = (0, _cartesian.cartesianCross)((0, _cartesian.cartesian)(point0), (0, _cartesian.cartesian)(point1));\n        (0, _cartesian.cartesianNormalizeInPlace)(arc);\n        var intersection = (0, _cartesian.cartesianCross)(normal, arc);\n        (0, _cartesian.cartesianNormalizeInPlace)(intersection);\n        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * (0, _math.asin)(intersection[2]);\n\n        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n          winding += antimeridian ^ delta >= 0 ? 1 : -1;\n        }\n      }\n    }\n  } // First, determine whether the South pole is inside or outside:\n  //\n  // It is inside if:\n  // * the polygon winds around it in a clockwise direction.\n  // * the polygon does not (cumulatively) wind around it, but has a negative\n  //   (counter-clockwise) area.\n  //\n  // Second, count the (signed) number of times a segment crosses a lambda\n  // from the point to the South pole.  If it is zero, then the point is the\n  // same side as the South pole.\n\n\n  return (angle < -_math.epsilon || angle < _math.epsilon && sum < -_math.epsilon2) ^ winding & 1;\n}\n};"],
"names":["shadow$provide","global","require","module","exports","longitude","point","_math","abs","pi","sign","tau","Object","defineProperty","value","default","_default","polygon","lambda","phi","sinPhi","sin","normal","cos","angle","winding","sum","_d3Array","Adder","halfPi","epsilon","i","n","length","m","ring","point0","lambda0","phi0","quarterPi","sinPhi0","cosPhi0","j","lambda1","sinPhi1","cosPhi1","point1","phi1","delta","absDelta","antimeridian","k","add","atan2","arc","_cartesian","cartesianCross","cartesian","cartesianNormalizeInPlace","intersection","phiArc","asin","epsilon2"]
}
