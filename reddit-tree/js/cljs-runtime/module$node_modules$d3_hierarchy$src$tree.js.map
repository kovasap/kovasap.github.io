{
"version":3,
"file":"module$node_modules$d3_hierarchy$src$tree.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/d3-hierarchy/src/tree.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$d3_hierarchy$src$tree\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _index = require(\"./hierarchy/index.js\");\n\nfunction defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n} // function radialSeparation(a, b) {\n//   return (a.parent === b.parent ? 1 : 2) / a.depth;\n// }\n// This function is used to traverse the left contour of a subtree (or\n// subforest). It returns the successor of v on this contour. This successor is\n// either given by the leftmost child of v or by the thread of v. The function\n// returns null if and only if v is on the highest level of its subtree.\n\n\nfunction nextLeft(v) {\n  var children = v.children;\n  return children ? children[0] : v.t;\n} // This function works analogously to nextLeft.\n\n\nfunction nextRight(v) {\n  var children = v.children;\n  return children ? children[children.length - 1] : v.t;\n} // Shifts the current subtree rooted at w+. This is done by increasing\n// prelim(w+) and mod(w+) by shift.\n\n\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n} // All other shifts, applied to the smaller subtrees between w- and w+, are\n// performed by this function. To prepare the shifts, we have to adjust\n// change(w+), shift(w+), and change(w-).\n\n\nfunction executeShifts(v) {\n  var shift = 0,\n      change = 0,\n      children = v.children,\n      i = children.length,\n      w;\n\n  while (--i >= 0) {\n    w = children[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n} // If vi-\u2019s ancestor is a sibling of v, returns vi-\u2019s ancestor. Otherwise,\n// returns the specified (default) ancestor.\n\n\nfunction nextAncestor(vim, v, ancestor) {\n  return vim.a.parent === v.parent ? vim.a : ancestor;\n}\n\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null; // default ancestor\n\n  this.a = this; // ancestor\n\n  this.z = 0; // prelim\n\n  this.m = 0; // mod\n\n  this.c = 0; // change\n\n  this.s = 0; // shift\n\n  this.t = null; // thread\n\n  this.i = i; // number\n}\n\nTreeNode.prototype = Object.create(_index.Node.prototype);\n\nfunction treeRoot(root) {\n  var tree = new TreeNode(root, 0),\n      node,\n      nodes = [tree],\n      child,\n      children,\n      i,\n      n;\n\n  while (node = nodes.pop()) {\n    if (children = node._.children) {\n      node.children = new Array(n = children.length);\n\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n        child.parent = node;\n      }\n    }\n  }\n\n  (tree.parent = new TreeNode(null, 0)).children = [tree];\n  return tree;\n} // Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\n\n\nfunction _default() {\n  var separation = defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = null;\n\n  function tree(root) {\n    var t = treeRoot(root); // Compute the layout using Buchheim et al.\u2019s algorithm.\n\n    t.eachAfter(firstWalk), t.parent.m = -t.z;\n    t.eachBefore(secondWalk); // If a fixed node size is specified, scale x and y.\n\n    if (nodeSize) root.eachBefore(sizeNode); // If a fixed tree size is specified, scale x and y based on the extent.\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    else {\n      var left = root,\n          right = root,\n          bottom = root;\n      root.eachBefore(function (node) {\n        if (node.x < left.x) left = node;\n        if (node.x > right.x) right = node;\n        if (node.depth > bottom.depth) bottom = node;\n      });\n      var s = left === right ? 1 : separation(left, right) / 2,\n          tx = s - left.x,\n          kx = dx / (right.x + s + tx),\n          ky = dy / (bottom.depth || 1);\n      root.eachBefore(function (node) {\n        node.x = (node.x + tx) * kx;\n        node.y = node.depth * ky;\n      });\n    }\n    return root;\n  } // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n  // applied recursively to the children of v, as well as the function\n  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n  // node v is placed to the midpoint of its outermost children.\n\n\n  function firstWalk(v) {\n    var children = v.children,\n        siblings = v.parent.children,\n        w = v.i ? siblings[v.i - 1] : null;\n\n    if (children) {\n      executeShifts(v);\n      var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n\n      if (w) {\n        v.z = w.z + separation(v._, w._);\n        v.m = v.z - midpoint;\n      } else {\n        v.z = midpoint;\n      }\n    } else if (w) {\n      v.z = w.z + separation(v._, w._);\n    }\n\n    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n  } // Computes all real x-coordinates by summing up the modifiers recursively.\n\n\n  function secondWalk(v) {\n    v._.x = v.z + v.parent.m;\n    v.m += v.parent.m;\n  } // The core of the algorithm. Here, a new subtree is combined with the\n  // previous subtrees. Threads are used to traverse the inside and outside\n  // contours of the left and right subtree up to the highest common level. The\n  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n  // superscript o means outside and i means inside, the subscript - means left\n  // subtree and + means right subtree. For summing up the modifiers along the\n  // contour, we use respective variables si+, si-, so-, and so+. Whenever two\n  // nodes of the inside contours conflict, we compute the left one of the\n  // greatest uncommon ancestors using the function ANCESTOR and call MOVE\n  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n  // Finally, we add a new thread (if necessary).\n\n\n  function apportion(v, w, ancestor) {\n    if (w) {\n      var vip = v,\n          vop = v,\n          vim = w,\n          vom = vip.parent.children[0],\n          sip = vip.m,\n          sop = vop.m,\n          sim = vim.m,\n          som = vom.m,\n          shift;\n\n      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n          sip += shift;\n          sop += shift;\n        }\n\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v;\n      }\n    }\n\n    return ancestor;\n  }\n\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n\n  tree.separation = function (x) {\n    return arguments.length ? (separation = x, tree) : separation;\n  };\n\n  tree.size = function (x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : nodeSize ? null : [dx, dy];\n  };\n\n  tree.nodeSize = function (x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : nodeSize ? [dx, dy] : null;\n  };\n\n  return tree;\n}\n};"],
"names":["shadow$provide","global","require","module","exports","defaultSeparation","a","b","parent","nextLeft","v","children","t","nextRight","length","TreeNode","node","i","_","A","s","c","m","z","treeRoot","root","tree","nodes","child","pop","Array","n","push","Object","defineProperty","value","default","_default","eachAfter","firstWalk","eachBefore","secondWalk","nodeSize","sizeNode","left","right","bottom","x","depth","separation","tx","kx","dx","ky","dy","y","siblings","w","shift","change","midpoint","vop","vip","vom","sip","sop","sim","vim","som","ancestor","wp","wm","tree.separation","arguments","size","tree.size","tree.nodeSize","_index","prototype","create","Node"]
}
