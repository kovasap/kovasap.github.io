shadow$provide.module$node_modules$vega_hierarchy$build$vega_hierarchy=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){"object"===typeof exports$jscomp$0&&"undefined"!==typeof module?factory(exports$jscomp$0,require("module$node_modules$vega_dataflow$build$vega_dataflow"),require("module$node_modules$vega_util$build$vega_util"),require("module$node_modules$d3_hierarchy$dist$d3_hierarchy")):"function"===typeof define&&define.amd?define(["exports","vega-dataflow",
"vega-util","d3-hierarchy"],factory):(global="undefined"!==typeof globalThis?globalThis:global||self,factory(global.vega={},global.vega,global.vega,global.d3))})(this,function(exports,vegaDataflow,vegaUtil,d3Hierarchy){function lookup(tree,key,filter){const map={};tree.each(node=>{const t=node.data;filter(t)&&(map[key(t)]=node)});tree.lookup=map;return tree}function Nest(params){vegaDataflow.Transform.call(this,null,params)}function nest$jscomp$0(){function apply(array,depth){if(depth>=keys.length)return array;
const n=array.length,key=keys[depth++],valuesByKey={},result={};let i=-1,keyValue,value,values;for(;++i<n;)keyValue=key(value=array[i])+"",(values=valuesByKey[keyValue])?values.push(value):valuesByKey[keyValue]=[value];for(keyValue in valuesByKey)result[keyValue]=apply(valuesByKey[keyValue],depth);return result}function entries(map,depth){if(++depth>keys.length)return map;const array=[];for(const key in map)array.push({key,values:entries(map[key],depth)});return array}const keys=[],nest={entries:array=>
entries(apply(array,0),0),key:d=>(keys.push(d),nest)};return nest}function HierarchyLayout(params){vegaDataflow.Transform.call(this,null,params)}function setParams(layout,params,_){for(let p,i=0,n=params.length;i<n;++i)if(p=params[i],p in _)layout[p](_[p])}function Pack(params){HierarchyLayout.call(this,params)}function Partition(params){HierarchyLayout.call(this,params)}function Stratify(params){vegaDataflow.Transform.call(this,null,params)}function Tree(params){HierarchyLayout.call(this,params)}
function TreeLinks(params){vegaDataflow.Transform.call(this,[],params)}function Treemap(params){HierarchyLayout.call(this,params)}Nest.Definition={type:"Nest",metadata:{treesource:!0,changes:!0},params:[{name:"keys",type:"field",array:!0},{name:"generate",type:"boolean"}]};const children=n=>n.values;vegaUtil.inherits(Nest,vegaDataflow.Transform,{transform(_,pulse){pulse.source||vegaUtil.error("Nest transform requires an upstream data source.");var gen=_.generate,mod=_.modified(),out=pulse.clone(),
tree=this.value;if(!tree||mod||pulse.changed())tree&&tree.each(node=>{node.children&&vegaDataflow.isTuple(node.data)&&out.rem.push(node.data)}),this.value=tree=d3Hierarchy.hierarchy({values:vegaUtil.array(_.keys).reduce((n,k)=>{n.key(k);return n},nest$jscomp$0()).entries(out.source)},children),gen&&tree.each(node=>{node.children&&(node=vegaDataflow.ingest(node.data),out.add.push(node),out.source.push(node))}),lookup(tree,vegaDataflow.tupleid,vegaDataflow.tupleid);out.source.root=tree;return out}});
const defaultSeparation=(a,b)=>a.parent===b.parent?1:2;vegaUtil.inherits(HierarchyLayout,vegaDataflow.Transform,{transform(_,pulse){pulse.source&&pulse.source.root||vegaUtil.error(this.constructor.name+" transform requires a backing tree data source.");const layout=this.layout(_.method),fields=this.fields,root=pulse.source.root,as=_.as||fields;_.field?root.sum(_.field):root.count();_.sort&&root.sort(vegaDataflow.stableCompare(_.sort,d=>d.data));setParams(layout,this.params,_);layout.separation&&layout.separation(!1!==
_.separation?defaultSeparation:vegaUtil.one);try{this.value=layout(root)}catch(err){vegaUtil.error(err)}root.each(node=>{const t=node.data,n=fields.length-1;for(let i=0;i<n;++i)t[as[i]]=node[fields[i]];t[as[n]]=node.children?node.children.length:0});return pulse.reflow(_.modified()).modifies(as).modifies("leaf")}});var Output=["x","y","r","depth","children"];Pack.Definition={type:"Pack",metadata:{tree:!0,modifies:!0},params:[{name:"field",type:"field"},{name:"sort",type:"compare"},{name:"padding",
type:"number","default":0},{name:"radius",type:"field","default":null},{name:"size",type:"number",array:!0,length:2},{name:"as",type:"string",array:!0,length:Output.length,"default":Output}]};vegaUtil.inherits(Pack,HierarchyLayout,{layout:d3Hierarchy.pack,params:["radius","size","padding"],fields:Output});Output="x0 y0 x1 y1 depth children".split(" ");Partition.Definition={type:"Partition",metadata:{tree:!0,modifies:!0},params:[{name:"field",type:"field"},{name:"sort",type:"compare"},{name:"padding",
type:"number","default":0},{name:"round",type:"boolean","default":!1},{name:"size",type:"number",array:!0,length:2},{name:"as",type:"string",array:!0,length:Output.length,"default":Output}]};vegaUtil.inherits(Partition,HierarchyLayout,{layout:d3Hierarchy.partition,params:["size","round","padding"],fields:Output});Stratify.Definition={type:"Stratify",metadata:{treesource:!0},params:[{name:"key",type:"field",required:!0},{name:"parentKey",type:"field",required:!0}]};vegaUtil.inherits(Stratify,vegaDataflow.Transform,
{transform(_,pulse){pulse.source||vegaUtil.error("Stratify transform requires an upstream data source.");let tree=this.value;const mod=_.modified(),out=pulse.fork(pulse.ALL).materialize(pulse.SOURCE);pulse=!tree||mod||pulse.changed(pulse.ADD_REM)||pulse.modified(_.key.fields)||pulse.modified(_.parentKey.fields);out.source=out.source.slice();pulse&&(tree=out.source.length?lookup(d3Hierarchy.stratify().id(_.key).parentId(_.parentKey)(out.source),_.key,vegaUtil.truthy):lookup(d3Hierarchy.stratify()([{}]),
_.key,_.key));out.source.root=this.value=tree;return out}});const Layouts={tidy:d3Hierarchy.tree,cluster:d3Hierarchy.cluster};Output=["x","y","depth","children"];Tree.Definition={type:"Tree",metadata:{tree:!0,modifies:!0},params:[{name:"field",type:"field"},{name:"sort",type:"compare"},{name:"method",type:"enum","default":"tidy",values:["tidy","cluster"]},{name:"size",type:"number",array:!0,length:2},{name:"nodeSize",type:"number",array:!0,length:2},{name:"separation",type:"boolean","default":!0},
{name:"as",type:"string",array:!0,length:Output.length,"default":Output}]};vegaUtil.inherits(Tree,HierarchyLayout,{layout(method){method=method||"tidy";if(vegaUtil.hasOwnProperty(Layouts,method))return Layouts[method]();vegaUtil.error("Unrecognized Tree layout method: "+method)},params:["size","nodeSize"],fields:Output});TreeLinks.Definition={type:"TreeLinks",metadata:{tree:!0,generates:!0,changes:!0},params:[]};vegaUtil.inherits(TreeLinks,vegaDataflow.Transform,{transform(_,pulse){_=this.value;const tree=
pulse.source&&pulse.source.root,out=pulse.fork(pulse.NO_SOURCE),lut={};tree||vegaUtil.error("TreeLinks transform requires a tree data source.");pulse.changed(pulse.ADD_REM)?(out.rem=_,pulse.visit(pulse.SOURCE,t=>lut[vegaDataflow.tupleid(t)]=1),tree.each(node=>{const t=node.data;(node=node.parent&&node.parent.data)&&lut[vegaDataflow.tupleid(t)]&&lut[vegaDataflow.tupleid(node)]&&out.add.push(vegaDataflow.ingest({source:node,target:t}))}),this.value=out.add):pulse.changed(pulse.MOD)&&(pulse.visit(pulse.MOD,
t=>lut[vegaDataflow.tupleid(t)]=1),_.forEach(link=>{(lut[vegaDataflow.tupleid(link.source)]||lut[vegaDataflow.tupleid(link.target)])&&out.mod.push(link)}));return out}});const Tiles={binary:d3Hierarchy.treemapBinary,dice:d3Hierarchy.treemapDice,slice:d3Hierarchy.treemapSlice,slicedice:d3Hierarchy.treemapSliceDice,squarify:d3Hierarchy.treemapSquarify,resquarify:d3Hierarchy.treemapResquarify};Output="x0 y0 x1 y1 depth children".split(" ");Treemap.Definition={type:"Treemap",metadata:{tree:!0,modifies:!0},
params:[{name:"field",type:"field"},{name:"sort",type:"compare"},{name:"method",type:"enum","default":"squarify",values:"squarify resquarify binary dice slice slicedice".split(" ")},{name:"padding",type:"number","default":0},{name:"paddingInner",type:"number","default":0},{name:"paddingOuter",type:"number","default":0},{name:"paddingTop",type:"number","default":0},{name:"paddingRight",type:"number","default":0},{name:"paddingBottom",type:"number","default":0},{name:"paddingLeft",type:"number","default":0},
{name:"ratio",type:"number","default":1.618033988749895},{name:"round",type:"boolean","default":!1},{name:"size",type:"number",array:!0,length:2},{name:"as",type:"string",array:!0,length:Output.length,"default":Output}]};vegaUtil.inherits(Treemap,HierarchyLayout,{layout(){const x=d3Hierarchy.treemap();x.ratio=_=>{const t=x.tile();t.ratio&&x.tile(t.ratio(_))};x.method=_=>{vegaUtil.hasOwnProperty(Tiles,_)?x.tile(Tiles[_]):vegaUtil.error("Unrecognized Treemap layout method: "+_)};return x},params:"method ratio size round padding paddingInner paddingOuter paddingTop paddingRight paddingBottom paddingLeft".split(" "),
fields:Output});exports.nest=Nest;exports.pack=Pack;exports.partition=Partition;exports.stratify=Stratify;exports.tree=Tree;exports.treelinks=TreeLinks;exports.treemap=Treemap;Object.defineProperty(exports,"__esModule",{value:!0})})}
//# sourceMappingURL=module$node_modules$vega_hierarchy$build$vega_hierarchy.js.map
