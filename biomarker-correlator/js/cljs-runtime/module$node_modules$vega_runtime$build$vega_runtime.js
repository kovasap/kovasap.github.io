shadow$provide.module$node_modules$vega_runtime$build$vega_runtime=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){"object"===typeof exports$jscomp$0&&"undefined"!==typeof module?factory(exports$jscomp$0,require("module$node_modules$vega_util$build$vega_util"),require("module$node_modules$vega_dataflow$build$vega_dataflow")):"function"===typeof define&&define.amd?define(["exports","vega-util","vega-dataflow"],factory):(global="undefined"!==typeof globalThis?globalThis:
global||self,factory(global.vega={},global.vega,global.vega))})(this,function(exports,vegaUtil,vegaDataflow){function expression(ctx,args,code){";"!==code[code.length-1]&&(code="return("+code+");");args=Function(...args.concat(code));return ctx&&ctx.functions?args.bind(ctx.functions):args}function parseParameter(spec,ctx,params){if(!spec||!vegaUtil.isObject(spec))return spec;for(let i=0,n=PARSERS.length,p;i<n;++i)if(p=PARSERS[i],vegaUtil.hasOwnProperty(spec,p.key))return p.parse(spec,ctx,params);
return spec}function Context(df,transforms,functions,expr){this.dataflow=df;this.transforms=transforms;this.events=df.events.bind(df);this.expr=expr||expressionCodegen;this.signals={};this.scales={};this.nodes={};this.data={};this.fn={};functions&&(this.functions=Object.create(functions),this.functions.context=this)}function Subcontext(ctx){this.dataflow=ctx.dataflow;this.transforms=ctx.transforms;this.events=ctx.events;this.expr=ctx.expr;this.signals=Object.create(ctx.signals);this.scales=Object.create(ctx.scales);
this.nodes=Object.create(ctx.nodes);this.data=Object.create(ctx.data);this.fn=Object.create(ctx.fn);ctx.functions&&(this.functions=Object.create(ctx.functions),this.functions.context=this)}const Skip=vegaUtil.toSet(["rule"]),Swap=vegaUtil.toSet(["group","image","rect"]);var expressionCodegen={operator:(ctx,expr)=>expression(ctx,["_"],expr.code),parameter:(ctx,expr)=>expression(ctx,["datum","_"],expr.code),event:(ctx,expr)=>expression(ctx,["event"],expr.code),handler:(ctx,expr)=>expression(ctx,["_",
"event"],`var datum=event.item&&event.item.datum;return ${expr.code};`),encode:(ctx,encode)=>{const {marktype,channels}=encode;encode="var o\x3ditem,datum\x3do.datum,m\x3d0,$;";for(var name in channels){const o="o["+vegaUtil.stringValue(name)+"]";encode+=`$=${channels[name].code};if(${o}!==$)${o}=$,m=1;`}name="";Skip[marktype]||(channels.x2&&(channels.x?(Swap[marktype]&&(name+="if(o.x\x3eo.x2)$\x3do.x,o.x\x3do.x2,o.x2\x3d$;"),name+="o.width\x3do.x2-o.x;"):name+="o.x\x3do.x2-(o.width||0);"),channels.xc&&
(name+="o.x\x3do.xc-(o.width||0)/2;"),channels.y2&&(channels.y?(Swap[marktype]&&(name+="if(o.y\x3eo.y2)$\x3do.y,o.y\x3do.y2,o.y2\x3d$;"),name+="o.height\x3do.y2-o.y;"):name+="o.y\x3do.y2-(o.height||0);"),channels.yc&&(name+="o.y\x3do.yc-(o.height||0)/2;"));encode+=name;return expression(ctx,["item","_"],encode+"return m;")},codegen:{get(path){path=`[${path.map(vegaUtil.stringValue).join("][")}]`;const get=Function("_",`return _${path};`);get.path=path;return get},comparator(fields,orders){let t;fields=
Function("a","b","var u, v; return "+fields.map((f,i)=>{const o=orders[i];let u;f.path?(u=`a${f.path}`,f=`b${f.path}`):((t=t||{})["f"+i]=f,u=`this.f${i}(a)`,f=`this.f${i}(b)`);i=-o;return`((u = ${u}) < (v = ${f}) || u == null) && v != null ? ${i}
  : (u > v || v == null) && u != null ? ${o}
  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${i}
  : v !== v && u === u ? ${o} : `}).join("")+"0;");return t?fields.bind(t):fields}}},PARSERS=[{key:"$ref",parse:function(_,ctx){return ctx.get(_.$ref)||vegaUtil.error("Operator not defined: "+_.$ref)}},{key:"$key",parse:function(_,ctx){const k="k:"+_.$key+"_"+!!_.$flat;return ctx.fn[k]||(ctx.fn[k]=vegaUtil.key(_.$key,_.$flat,ctx.expr.codegen))}},{key:"$expr",parse:function(_,ctx,params){_.$params&&ctx.parseParameters(_.$params,params);params="e:"+_.$expr.code+"_"+_.$name;return ctx.fn[params]||(ctx.fn[params]=
vegaUtil.accessor(ctx.parameterExpression(_.$expr),_.$fields,_.$name))}},{key:"$field",parse:function(_,ctx){if(!_.$field)return null;const k="f:"+_.$field+"_"+_.$name;return ctx.fn[k]||(ctx.fn[k]=vegaUtil.field(_.$field,_.$name,ctx.expr.codegen))}},{key:"$encode",parse:function(_,ctx){_=_.$encode;const encode={};for(const name in _){const enc=_[name];encode[name]=vegaUtil.accessor(ctx.encodeExpression(enc.$expr),enc.$fields);encode[name].output=enc.$output}return encode}},{key:"$compare",parse:function(_$jscomp$0,
ctx){const k="c:"+_$jscomp$0.$compare+"_"+_$jscomp$0.$order,c=vegaUtil.array(_$jscomp$0.$compare).map(_=>_&&_.$tupleid?vegaDataflow.tupleid:_);return ctx.fn[k]||(ctx.fn[k]=vegaUtil.compare(c,_$jscomp$0.$order,ctx.expr.codegen))}},{key:"$context",parse:function(_,ctx){return ctx}},{key:"$subflow",parse:function(_,ctx){const spec=_.$subflow;return function(dataflow,key,parent){const subctx=ctx.fork().parse(spec);dataflow=subctx.get(spec.operators[0].id);(key=subctx.signals.parent)&&key.set(parent);
dataflow.detachSubflow=()=>ctx.detach(subctx);return dataflow}}},{key:"$tupleid",parse:function(){return vegaDataflow.tupleid}}];const SKIP={skip:!0};Context.prototype=Subcontext.prototype={fork(){const ctx=new Subcontext(this);(this.subcontext||(this.subcontext=[])).push(ctx);return ctx},detach(ctx){this.subcontext=this.subcontext.filter(c=>c!==ctx);const keys=Object.keys(ctx.nodes);for(const key of keys)ctx.nodes[key]._targets=null;for(const key of keys)ctx.nodes[key].detach();ctx.nodes=null},get(id){return this.nodes[id]},
set(id,node){return this.nodes[id]=node},add(spec,op){const ctx=this,df=ctx.dataflow,data$jscomp$0=spec.value;ctx.set(spec.id,op);"collect"===(spec.type+"").toLowerCase()&&data$jscomp$0&&(data$jscomp$0.$ingest?df.ingest(op,data$jscomp$0.$ingest,data$jscomp$0.$format):data$jscomp$0.$request?df.preload(op,data$jscomp$0.$request,data$jscomp$0.$format):df.pulse(op,df.changeset().insert(data$jscomp$0)));spec.root&&(ctx.root=op);if(spec.parent){let p=ctx.get(spec.parent.$ref);p?(df.connect(p,[op]),op.targets().add(p)):
(ctx.unresolved=ctx.unresolved||[]).push(()=>{p=ctx.get(spec.parent.$ref);df.connect(p,[op]);op.targets().add(p)})}spec.signal&&(ctx.signals[spec.signal]=op);spec.scale&&(ctx.scales[spec.scale]=op);if(spec.data)for(const name in spec.data){const data=ctx.data[name]||(ctx.data[name]={});spec.data[name].forEach(role=>data[role]=op)}},resolve(){(this.unresolved||[]).forEach(fn=>fn());delete this.unresolved;return this},operator(spec,update){this.add(spec,this.dataflow.add(spec.value,update))},transform(spec,
type){this.add(spec,this.dataflow.add(this.transforms[(type+"").toLowerCase()]))},stream(spec,stream){this.set(spec.id,stream)},update(spec,stream,target,update,params){this.dataflow.on(stream,target,update,params,spec.options)},operatorExpression(expr){return this.expr.operator(this,expr)},parameterExpression(expr){return this.expr.parameter(this,expr)},eventExpression(expr){return this.expr.event(this,expr)},handlerExpression(expr){return this.expr.handler(this,expr)},encodeExpression(encode){return this.expr.encode(this,
encode)},parse:function(spec){const ctx=this,operators=spec.operators||[];spec.background&&(ctx.background=spec.background);spec.eventConfig&&(ctx.eventConfig=spec.eventConfig);spec.locale&&(ctx.locale=spec.locale);operators.forEach(entry=>ctx.parseOperator(entry));operators.forEach(entry=>ctx.parseOperatorParameters(entry));(spec.streams||[]).forEach(entry=>ctx.parseStream(entry));(spec.updates||[]).forEach(entry=>ctx.parseUpdate(entry));return ctx.resolve()},parseOperator:function(spec){"operator"!==
(spec.type+"").toLowerCase()&&spec.type?this.transform(spec,spec.type):this.operator(spec,spec.update?this.operatorExpression(spec.update):null)},parseOperatorParameters:function(spec){if(spec.params){const op=this.get(spec.id);op||vegaUtil.error("Invalid operator id: "+spec.id);this.dataflow.connect(op,op.parameters(this.parseParameters(spec.params),spec.react,spec.initonly))}},parseParameters:function(spec,params){params=params||{};const ctx=this;for(const key in spec){const value=spec[key];params[key]=
vegaUtil.isArray(value)?value.map(v=>parseParameter(v,ctx,params)):parseParameter(value,ctx,params)}return params},parseStream:function(spec){var ctx=this,filter=null!=spec.filter?ctx.eventExpression(spec.filter):void 0,stream=null!=spec.stream?ctx.get(spec.stream):void 0;if(spec.source)stream=ctx.events(spec.source,spec.type,filter);else if(spec.merge){var args=spec.merge.map(_=>ctx.get(_));stream=args[0].merge.apply(args[0],args.slice(1))}spec.between&&(args=spec.between.map(_=>ctx.get(_)),stream=
stream.between(args[0],args[1]));spec.filter&&(stream=stream.filter(filter));null!=spec.throttle&&(stream=stream.throttle(+spec.throttle));null!=spec.debounce&&(stream=stream.debounce(+spec.debounce));null==stream&&vegaUtil.error("Invalid stream definition: "+JSON.stringify(spec));spec.consume&&stream.consume(!0);ctx.stream(spec,stream)},parseUpdate:function(spec){var srcid=vegaUtil.isObject(srcid=spec.source)?srcid.$ref:srcid;srcid=this.get(srcid);var update=spec.update,params=void 0;srcid||vegaUtil.error("Source not defined: "+
spec.source);var target=spec.target&&spec.target.$expr?this.eventExpression(spec.target.$expr):this.get(spec.target);update&&update.$expr&&(update.$params&&(params=this.parseParameters(update.$params)),update=this.handlerExpression(update.$expr));this.update(spec,srcid,target,update,params)},getState:function(options){var ctx$jscomp$0=this,state={};if(options.signals){var signals=state.signals={};Object.keys(ctx$jscomp$0.signals).forEach(key=>{const op=ctx$jscomp$0.signals[key];options.signals(key,
op)&&(signals[key]=op.value)})}if(options.data){var data=state.data={};Object.keys(ctx$jscomp$0.data).forEach(key=>{const dataset=ctx$jscomp$0.data[key];options.data(key,dataset)&&(data[key]=dataset.input.value)})}ctx$jscomp$0.subcontext&&!1!==options.recurse&&(state.subcontext=ctx$jscomp$0.subcontext.map(ctx=>ctx.getState(options)));return state},setState:function(state){var ctx=this,df=ctx.dataflow,data=state.data,signals=state.signals;Object.keys(signals||{}).forEach(key=>{df.update(ctx.signals[key],
signals[key],SKIP)});Object.keys(data||{}).forEach(key=>{df.pulse(ctx.data[key].input,df.changeset().remove(vegaUtil.truthy).insert(data[key]))});(state.subcontext||[]).forEach((substate,i)=>{(i=ctx.subcontext[i])&&i.setState(substate)})}};exports.context=function(df,transforms,functions,expr){return new Context(df,transforms,functions,expr)};Object.defineProperty(exports,"__esModule",{value:!0})})}
//# sourceMappingURL=module$node_modules$vega_runtime$build$vega_runtime.js.map
