shadow$provide.module$node_modules$vega_dataflow$build$vega_dataflow=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){"object"===typeof exports$jscomp$0&&"undefined"!==typeof module?factory(exports$jscomp$0,require("module$node_modules$vega_util$build$vega_util"),require("module$node_modules$vega_loader$build$vega_loader_browser"),require("module$node_modules$vega_format$build$vega_format")):"function"===typeof define&&define.amd?define(["exports","vega-util","vega-loader",
"vega-format"],factory):(global="undefined"!==typeof globalThis?globalThis:global||self,factory(global.vega={},global.vega,global.vega,global.vega))})(this,function(exports,vegaUtil,vegaLoader,vegaFormat){function UniqueList(idFunc){const $=idFunc||vegaUtil.identity,list=[],ids={};list.add=_=>{const id=$(_);ids[id]||(ids[id]=1,list.push(_));return list};list.remove=_=>{const id=$(_);ids[id]&&(ids[id]=0,_=list.indexOf(_),0<=_&&list.splice(_,1));return list};return list}function asyncCallback(df,callback){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){try{yield callback(df)}catch(err){df.error(err)}})}
function ingest$1(datum){datum=datum===Object(datum)?datum:{data:datum};if(!datum[TUPLE_ID_KEY]){var id=TUPLE_ID++;datum[TUPLE_ID_KEY]=id}return datum}function rederive(t,d){for(const k in t)d[k]=t[k];return d}function isChangeSet(v){return v&&v.constructor===changeset}function changeset(){const add=[],rem=[],mod=[],remp=[],modp=[];let clean=null,reflow=!1;return{constructor:changeset,insert(t){t=vegaUtil.array(t);const n=t.length;for(let i=0;i<n;++i)add.push(t[i]);return this},remove(t){const a=
vegaUtil.isFunction(t)?remp:rem;t=vegaUtil.array(t);const n=t.length;for(let i=0;i<n;++i)a.push(t[i]);return this},modify(t,field,value){field={field,value:vegaUtil.constant(value)};vegaUtil.isFunction(t)?(field.filter=t,modp.push(field)):(field.tuple=t,mod.push(field));return this},encode(t,set){vegaUtil.isFunction(t)?modp.push({filter:t,field:set}):mod.push({tuple:t,field:set});return this},clean(value){clean=value;return this},reflow(){reflow=!0;return this},pulse(pulse,tuples){function modify(t,
f,v){v?t[f]=v(t):pulse.encode=f;reflow||(out[t[TUPLE_ID_KEY]]=t)}const cur={},out={};let i,n,m,f$jscomp$0,t$jscomp$0,id;i=0;for(n=tuples.length;i<n;++i)cur[tuples[i][TUPLE_ID_KEY]]=1;i=0;for(n=rem.length;i<n;++i)t$jscomp$0=rem[i],cur[t$jscomp$0[TUPLE_ID_KEY]]=-1;i=0;for(n=remp.length;i<n;++i)f$jscomp$0=remp[i],tuples.forEach(t=>{f$jscomp$0(t)&&(cur[t[TUPLE_ID_KEY]]=-1)});i=0;for(n=add.length;i<n;++i)t$jscomp$0=add[i],id=t$jscomp$0[TUPLE_ID_KEY],cur[id]?cur[id]=1:pulse.add.push(ingest$1(add[i]));i=
0;for(n=tuples.length;i<n;++i)t$jscomp$0=tuples[i],0>cur[t$jscomp$0[TUPLE_ID_KEY]]&&pulse.rem.push(t$jscomp$0);i=0;for(n=mod.length;i<n;++i)m=mod[i],t$jscomp$0=m.tuple,f$jscomp$0=m.field,id=cur[t$jscomp$0[TUPLE_ID_KEY]],0<id&&(modify(t$jscomp$0,f$jscomp$0,m.value),pulse.modifies(f$jscomp$0));i=0;for(n=modp.length;i<n;++i)m=modp[i],f$jscomp$0=m.filter,tuples.forEach(t=>{f$jscomp$0(t)&&0<cur[t[TUPLE_ID_KEY]]&&modify(t,m.field,m.value)}),pulse.modifies(m.field);if(reflow)pulse.mod=rem.length||remp.length?
tuples.filter(t=>0<cur[t[TUPLE_ID_KEY]]):tuples.slice();else for(id in out)pulse.mod.push(out[id]);(clean||null==clean&&(rem.length||remp.length))&&pulse.clean(!0);return pulse}}}function Parameters(){Object.defineProperty(this,"_:mod:_",{writable:!0,value:{}})}function Operator(init,update,params,react){this.id=++OP_ID;this.value=init;this.qrank=this.rank=this.stamp=-1;this.flags=0;update&&(this._update=update);params&&this.parameters(params,react)}function flag(bit){return function(state){const f=
this.flags;if(0===arguments.length)return!!(f&bit);this.flags=state?f|bit:f&~bit;return this}}function EventStream(filter,apply,receive){this.id=++STREAM_ID;this.value=null;receive&&(this.receive=receive);filter&&(this._filter=filter);apply&&(this._apply=apply)}function stream$jscomp$0(filter,apply,receive){return new EventStream(filter,apply,receive)}function loadPending(df){let accept;const pending=new Promise(a=>accept=a);pending.requests=0;pending.done=()=>{0===--pending.requests&&(df._pending=
null,accept(df))};return df._pending=pending}function onStream(df,stream,target,update,params,options){const opt=vegaUtil.extend({},options,SKIP);let op;vegaUtil.isFunction(target)||(target=vegaUtil.constant(target));void 0===update?params=e=>df.touch(target(e)):vegaUtil.isFunction(update)?(op=new Operator(null,update,params,!1),params=e=>{op.evaluate(e);e=target(e);const v=op.value;isChangeSet(v)?df.pulse(e,v,options):df.update(e,v,opt)}):params=e=>df.update(target(e),update,opt);stream.apply(params)}
function onOperator(df,source,target,update,params,options){void 0===update?source.targets().add(target):(options=options||{},update=new Operator(null,updater(target,update),params,!1),update.modified(options.force),update.rank=source.rank,source.targets().add(update),target&&(update.skip(!0),update.value=target.value,update.targets().add(target),df.connect(target,[update])))}function updater(target,update){update=vegaUtil.isFunction(update)?update:vegaUtil.constant(update);return target?function(_,
pulse){_=update(_,pulse);target.skip()||(target.skip(_!==this.value).value=_);return _}:update}function Pulse(dataflow,stamp,encode){this.dataflow=dataflow;this.stamp=null==stamp?-1:stamp;this.add=[];this.rem=[];this.mod=[];this.fields=null;this.encode=encode||null}function materialize(data,filter){const out=[];vegaUtil.visitArray(data,filter,_=>out.push(_));return out}function filter$jscomp$0(pulse,flags){const map={};pulse.visit(flags,t=>{map[t[TUPLE_ID_KEY]]=1});return t=>map[t[TUPLE_ID_KEY]]?
null:t}function addFilter(a,b){return a?(t,i)=>a(t,i)&&b(t,i):b}function MultiPulse(dataflow,stamp,pulses,encode){const n=pulses.length;let c=0;this.dataflow=dataflow;this.stamp=stamp;this.fields=null;this.encode=encode||null;this.pulses=pulses;for(dataflow=0;dataflow<n;++dataflow)if(encode=pulses[dataflow],encode.stamp===stamp){if(encode.fields){const hash=this.fields||(this.fields={});for(const f in encode.fields)hash[f]=1}encode.changed(this.ADD)&&(c|=this.ADD);encode.changed(this.REM)&&(c|=this.REM);
encode.changed(this.MOD)&&(c|=this.MOD)}this.changes=c}function reentrant(df){df.error("Dataflow already running. Use runAsync() to chain invocations.");return df}function singlePulse(p,s){if(s&&s.stamp===p.stamp)return s;p=p.fork();s&&s!==StopPropagation&&(p.source=s.source);return p}function Heap(cmp){let nodes=[];return{clear:()=>nodes=[],size:()=>nodes.length,peek:()=>nodes[0],push:x=>{nodes.push(x);return siftdown(nodes,0,nodes.length-1,cmp)},pop:()=>{var last=nodes.pop();let item$jscomp$0;if(nodes.length){item$jscomp$0=
nodes[0];nodes[0]=last;last=nodes;var idx=0;const start=idx,end=last.length,item=last[idx];let cidx=(idx<<1)+1,ridx;for(;cidx<end;)ridx=cidx+1,ridx<end&&0<=cmp(last[cidx],last[ridx])&&(cidx=ridx),last[idx]=last[cidx],idx=cidx,cidx=(idx<<1)+1;last[idx]=item;siftdown(last,start,idx,cmp)}else item$jscomp$0=last;return item$jscomp$0}}}function siftdown(array,start,idx,cmp){let parent,pidx;const item=array[idx];for(;idx>start;)if(pidx=idx-1>>1,parent=array[pidx],0>cmp(item,parent))array[idx]=parent,idx=
pidx;else break;return array[idx]=item}function Dataflow(){this.logger(vegaUtil.logger());this.logLevel(vegaUtil.Error);this._rank=this._clock=0;this._locale=vegaFormat.defaultLocale();try{this._loader=vegaLoader.loader()}catch(e){}this._touched=UniqueList(vegaUtil.id);this._input={};this._pulse=null;this._heap=Heap((a,b)=>a.qrank-b.qrank);this._postrun=[]}function logMethod(method){return function(){return this._log[method].apply(this,arguments)}}function Transform(init,params){Operator.call(this,
init,null,params)}function transform(type){type=type&&type.toLowerCase();return vegaUtil.hasOwnProperty(transforms,type)?transforms[type]:null}const TUPLE_ID_KEY=Symbol("vega_id");let TUPLE_ID=1;Parameters.prototype={set(name,index,value,force){const v=this[name],mod=this["_:mod:_"];if(null!=index&&0<=index){if(v[index]!==value||force)v[index]=value,mod[index+":"+name]=-1,mod[name]=-1}else if(v!==value||force)this[name]=value,mod[name]=vegaUtil.isArray(value)?1+value.length:-1;return this},modified(name,
index){const mod=this["_:mod:_"];if(!arguments.length){for(var k in mod)if(mod[k])return!0;return!1}if(vegaUtil.isArray(name)){for(k=0;k<name.length;++k)if(mod[name[k]])return!0;return!1}return null!=index&&0<=index?index+1<mod[name]||!!mod[index+":"+name]:!!mod[name]},clear(){this["_:mod:_"]={};return this}};let OP_ID=0;const NO_PARAMS=new Parameters;Operator.prototype={targets(){return this._targets||(this._targets=UniqueList(vegaUtil.id))},set(value){return this.value!==value?(this.value=value,
1):0},skip:flag(1),modified:flag(2),parameters(params,react,initonly){react=!1!==react;const argval=this._argval=this._argval||new Parameters,argops=this._argops=this._argops||[],deps=[];let name$jscomp$0,value$jscomp$0,n,i;const add=(name,index,value)=>{value instanceof Operator?(value!==this&&(react&&value.targets().add(this),deps.push(value)),argops.push({op:value,name,index})):argval.set(name,index,value)};for(name$jscomp$0 in params)if(value$jscomp$0=params[name$jscomp$0],"pulse"===name$jscomp$0)vegaUtil.array(value$jscomp$0).forEach(op=>
{op instanceof Operator?op!==this&&(op.targets().add(this),deps.push(op)):vegaUtil.error("Pulse parameters must be operator instances.")}),this.source=value$jscomp$0;else if(vegaUtil.isArray(value$jscomp$0))for(argval.set(name$jscomp$0,-1,Array(n=value$jscomp$0.length)),i=0;i<n;++i)add(name$jscomp$0,i,value$jscomp$0[i]);else add(name$jscomp$0,-1,value$jscomp$0);this.marshall().clear();initonly&&(argops.initonly=!0);return deps},marshall(stamp){const argval=this._argval||NO_PARAMS,argops=this._argops;
let item,i,op,mod;if(argops){const n=argops.length;for(i=0;i<n;++i)item=argops[i],op=item.op,mod=op.modified()&&op.stamp===stamp,argval.set(item.name,item.index,op.value,mod);if(argops.initonly){for(i=0;i<n;++i)item=argops[i],item.op.targets().remove(this);this._update=this._argops=null}}return argval},detach(){const argops=this._argops;let i,n;if(argops)for(i=0,n=argops.length;i<n;++i){var item=argops[i];item=item.op;item._targets&&item._targets.remove(this)}this.source=this.pulse=null},evaluate(pulse){var update=
this._update;if(update){const params=this.marshall(pulse.stamp);update=update.call(this,params,pulse);params.clear();if(update!==this.value)this.value=update;else if(!this.modified())return pulse.StopPropagation}},run(pulse){if(pulse.stamp<this.stamp)return pulse.StopPropagation;let rv;this.skip()?(this.skip(!1),rv=0):rv=this.evaluate(pulse);return this.pulse=rv||pulse}};let STREAM_ID=0;EventStream.prototype={_filter:vegaUtil.truthy,_apply:vegaUtil.identity,targets(){return this._targets||(this._targets=
UniqueList(vegaUtil.id))},consume(_){if(!arguments.length)return!!this._consume;this._consume=!!_;return this},receive(evt){if(this._filter(evt)){const val=this.value=this._apply(evt),trg=this._targets,n=trg?trg.length:0;for(let i=0;i<n;++i)trg[i].receive(val);this._consume&&(evt.preventDefault(),evt.stopPropagation())}},filter(filter){filter=stream$jscomp$0(filter);this.targets().add(filter);return filter},apply(apply){apply=stream$jscomp$0(null,apply);this.targets().add(apply);return apply},merge(){const s=
stream$jscomp$0();this.targets().add(s);for(let i=0,n=arguments.length;i<n;++i)arguments[i].targets().add(s);return s},throttle(pause){let t=-1;return this.filter(()=>{const now=Date.now();return now-t>pause?(t=now,1):0})},debounce(delay){const s=stream$jscomp$0();this.targets().add(stream$jscomp$0(null,null,vegaUtil.debounce(delay,e=>{const df=e.dataflow;s.receive(e);df&&df.run&&df.run()})));return s},between(a,b){let active=!1;a.targets().add(stream$jscomp$0(null,null,()=>active=!0));b.targets().add(stream$jscomp$0(null,
null,()=>active=!1));return this.filter(()=>active)},detach(){this._filter=vegaUtil.truthy;this._targets=null}};const SKIP={skip:!0},StopPropagation={};Pulse.prototype={StopPropagation,ADD:1,REM:2,MOD:4,ADD_REM:3,ADD_MOD:5,ALL:7,REFLOW:8,SOURCE:16,NO_SOURCE:32,NO_FIELDS:64,fork(flags){return(new Pulse(this.dataflow)).init(this,flags)},clone(){const p=this.fork(7);p.add=p.add.slice();p.rem=p.rem.slice();p.mod=p.mod.slice();p.source&&(p.source=p.source.slice());return p.materialize(23)},addAll(){let p=
this;p.source&&p.add!==p.rem&&(p.rem.length||p.source.length!==p.add.length)&&(p=(new Pulse(this.dataflow)).init(this),p.add=p.source,p.rem=[]);return p},init(src,flags){this.stamp=src.stamp;this.encode=src.encode;!src.fields||flags&64||(this.fields=src.fields);flags&1?(this.addF=src.addF,this.add=src.add):(this.addF=null,this.add=[]);flags&2?(this.remF=src.remF,this.rem=src.rem):(this.remF=null,this.rem=[]);flags&4?(this.modF=src.modF,this.mod=src.mod):(this.modF=null,this.mod=[]);flags&32?this.source=
this.srcF=null:(this.srcF=src.srcF,this.source=src.source,src.cleans&&(this.cleans=src.cleans));return this},runAfter(func){this.dataflow.runAfter(func)},changed(flags){flags=flags||7;return flags&1&&this.add.length||flags&2&&this.rem.length||flags&4&&this.mod.length},reflow(fork){if(fork)return this.fork(7).reflow();fork=this.add.length;const src=this.source&&this.source.length;src&&src!==fork&&(this.mod=this.source,fork&&this.filter(4,filter$jscomp$0(this,1)));return this},clean(value){return arguments.length?
(this.cleans=!!value,this):this.cleans},modifies(_){const hash=this.fields||(this.fields={});vegaUtil.isArray(_)?_.forEach(f=>hash[f]=!0):hash[_]=!0;return this},modified(_,nomod){const fields=this.fields;return(nomod||this.mod.length)&&fields?arguments.length?vegaUtil.isArray(_)?_.some(f=>fields[f]):fields[_]:!!fields:!1},filter(flags,filter){flags&1&&(this.addF=addFilter(this.addF,filter));flags&2&&(this.remF=addFilter(this.remF,filter));flags&4&&(this.modF=addFilter(this.modF,filter));flags&16&&
(this.srcF=addFilter(this.srcF,filter));return this},materialize(flags){flags=flags||7;flags&1&&this.addF&&(this.add=materialize(this.add,this.addF),this.addF=null);flags&2&&this.remF&&(this.rem=materialize(this.rem,this.remF),this.remF=null);flags&4&&this.modF&&(this.mod=materialize(this.mod,this.modF),this.modF=null);flags&16&&this.srcF&&(this.source=this.source.filter(this.srcF),this.srcF=null);return this},visit(flags,visitor){if(flags&16)return vegaUtil.visitArray(this.source,this.srcF,visitor),
this;flags&1&&vegaUtil.visitArray(this.add,this.addF,visitor);flags&2&&vegaUtil.visitArray(this.rem,this.remF,visitor);flags&4&&vegaUtil.visitArray(this.mod,this.modF,visitor);const src=this.source;flags&8&&src&&(flags=this.add.length+this.mod.length,flags!==src.length&&(flags?vegaUtil.visitArray(src,filter$jscomp$0(this,5),visitor):vegaUtil.visitArray(src,this.srcF,visitor)));return this}};vegaUtil.inherits(MultiPulse,Pulse,{fork(flags){const p=(new Pulse(this.dataflow)).init(this,flags&this.NO_FIELDS);
void 0!==flags&&(flags&p.ADD&&this.visit(p.ADD,t=>p.add.push(t)),flags&p.REM&&this.visit(p.REM,t=>p.rem.push(t)),flags&p.MOD&&this.visit(p.MOD,t=>p.mod.push(t)));return p},changed(flags){return this.changes&flags},modified(_){const fields=this.fields;return fields&&this.changes&this.MOD?vegaUtil.isArray(_)?_.some(f=>fields[f]):fields[_]:0},filter(){vegaUtil.error("MultiPulse does not support filtering.")},materialize(){vegaUtil.error("MultiPulse does not support materialization.")},visit(flags,visitor){const pulses=
this.pulses,n=pulses.length;let i=0;if(flags&this.SOURCE)for(;i<n;++i)pulses[i].visit(flags,visitor);else for(;i<n;++i)pulses[i].stamp===this.stamp&&pulses[i].visit(flags,visitor);return this}});const NO_OPT={skip:!1,force:!1};Dataflow.prototype={stamp(){return this._clock},loader(_){return arguments.length?(this._loader=_,this):this._loader},locale(_){return arguments.length?(this._locale=_,this):this._locale},logger(logger){return arguments.length?(this._log=logger,this):this._log},error:logMethod("error"),
warn:logMethod("warn"),info:logMethod("info"),debug:logMethod("debug"),logLevel:logMethod("level"),cleanThreshold:1E4,add:function(init,update,params,react){let shift=1;init instanceof Operator||(init&&init.prototype instanceof Operator?init=new init:vegaUtil.isFunction(init)?init=new Operator(null,init):(shift=0,init=new Operator(init,update)));this.rank(init);shift&&(react=params,params=update);params&&this.connect(init,init.parameters(params,react));this.touch(init);return init},connect:function(target,
sources){const targetRank=target.rank,n=sources.length;for(let i=0;i<n;++i)if(targetRank<sources[i].rank){this.rerank(target);break}},rank:function(op){op.rank=++this._rank},rerank:function(op){const queue=[op];let cur,list,i;for(;queue.length;)if(this.rank(cur=queue.pop()),list=cur._targets)for(i=list.length;0<=--i;)queue.push(cur=list[i]),cur===op&&vegaUtil.error("Cycle detected in dataflow graph.")},pulse:function(op,changeset,options){this.touch(op,options||NO_OPT);options=new Pulse(this,this._clock+
(this._pulse?0:1));const t=op.pulse&&op.pulse.source||[];options.target=op;this._input[op.id]=changeset.pulse(options,t);return this},touch:function(op,options){options=options||NO_OPT;this._pulse?this._enqueue(op):this._touched.add(op);options.skip&&op.skip(!0);return this},update:function(op,value,options){options=options||NO_OPT;(op.set(value)||options.force)&&this.touch(op,options);return this},changeset,ingest:function(target,data,format){data=this.parse(data,format);return this.pulse(target,
this.changeset().insert(data))},parse:function(data,format){const locale=this.locale();return vegaLoader.read(data,format,locale.timeParse,locale.utcParse)},preload:function(target,url,format){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const pending=$jscomp$async$this._pending||loadPending($jscomp$async$this);pending.requests+=1;const res=yield $jscomp$async$this.request(url,format);$jscomp$async$this.pulse(target,$jscomp$async$this.changeset().remove(vegaUtil.truthy).insert(res.data||
[]));pending.done();return res})},request:function(url,format){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){let status=0,data;try{data=yield $jscomp$async$this.loader().load(url,{context:"dataflow",response:vegaLoader.responseType(format&&format.type)});try{data=$jscomp$async$this.parse(data,format)}catch(err){status=-2,$jscomp$async$this.warn("Data ingestion failed",url,err)}}catch(err){status=-1,$jscomp$async$this.warn("Loading failed",url,err)}return{data,
status}})},events:function(source,type,filter,apply){const df=this,s=stream$jscomp$0(filter,apply);filter=function(e){e.dataflow=df;try{s.receive(e)}catch(error){df.error(error)}finally{df.run()}};source="string"===typeof source&&"undefined"!==typeof document?document.querySelectorAll(source):vegaUtil.array(source);apply=source.length;for(let i=0;i<apply;++i)source[i].addEventListener(type,filter);return s},on:function(source,target,update,params,options){(source instanceof Operator?onOperator:onStream)(this,
source,target,update,params,options);return this},evaluate:function(encode,prerun,postrun){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const async=[];if($jscomp$async$this._pulse)return reentrant($jscomp$async$this);$jscomp$async$this._pending&&(yield $jscomp$async$this._pending);prerun&&(yield asyncCallback($jscomp$async$this,prerun));if(!$jscomp$async$this._touched.length)return $jscomp$async$this.debug("Dataflow invoked, but nothing to do."),$jscomp$async$this;
var stamp=++$jscomp$async$this._clock;$jscomp$async$this._pulse=new Pulse($jscomp$async$this,stamp,encode);$jscomp$async$this._touched.forEach(op=>$jscomp$async$this._enqueue(op,!0));$jscomp$async$this._touched=UniqueList(vegaUtil.id);var count=0;let op$jscomp$0,next,error;try{for(;0<$jscomp$async$this._heap.size();)op$jscomp$0=$jscomp$async$this._heap.pop(),op$jscomp$0.rank!==op$jscomp$0.qrank?$jscomp$async$this._enqueue(op$jscomp$0,!0):(next=op$jscomp$0.run($jscomp$async$this._getPulse(op$jscomp$0,
encode)),next.then?next=yield next:next.async&&(async.push(next.async),next=StopPropagation),next!==StopPropagation&&op$jscomp$0._targets&&op$jscomp$0._targets.forEach(op=>$jscomp$async$this._enqueue(op)),++count)}catch(err){$jscomp$async$this._heap.clear(),error=err}$jscomp$async$this._input={};$jscomp$async$this._pulse=null;$jscomp$async$this.debug(`Pulse ${stamp}: ${count} operators`);error&&($jscomp$async$this._postrun=[],$jscomp$async$this.error(error));if($jscomp$async$this._postrun.length)for(stamp=
$jscomp$async$this._postrun.sort((a,b)=>b.priority-a.priority),$jscomp$async$this._postrun=[],count=0;count<stamp.length;++count)yield asyncCallback($jscomp$async$this,stamp[count].callback);postrun&&(yield asyncCallback($jscomp$async$this,postrun));async.length&&Promise.all(async).then(cb=>$jscomp$async$this.runAsync(null,()=>{cb.forEach(f=>{try{f($jscomp$async$this)}catch(err){$jscomp$async$this.error(err)}})}));return $jscomp$async$this})},run:function(encode,prerun,postrun){return this._pulse?
reentrant(this):(this.evaluate(encode,prerun,postrun),this)},runAsync:function(encode,prerun,postrun){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){for(;$jscomp$async$this._running;)yield $jscomp$async$this._running;const clear=()=>$jscomp$async$this._running=null;($jscomp$async$this._running=$jscomp$async$this.evaluate(encode,prerun,postrun)).then(clear,clear);return $jscomp$async$this._running})},runAfter:function(callback,enqueue,priority){if(this._pulse||
enqueue)this._postrun.push({priority:priority||0,callback});else try{callback(this)}catch(err){this.error(err)}},_enqueue:function(op,force){const q=op.stamp<this._clock;q&&(op.stamp=this._clock);if(q||force)op.qrank=op.rank,this._heap.push(op)},_getPulse:function(op,encode){const s=op.source,stamp=this._clock;return s&&vegaUtil.isArray(s)?new MultiPulse(this,stamp,s.map(_=>_.pulse),encode):this._input[op.id]||singlePulse(this._pulse,s&&s.pulse)}};vegaUtil.inherits(Transform,Operator,{run(pulse){if(pulse.stamp<
this.stamp)return pulse.StopPropagation;let rv;this.skip()?this.skip(!1):rv=this.evaluate(pulse);rv=rv||pulse;rv.then?rv=rv.then(_=>this.pulse=_):rv!==pulse.StopPropagation&&(this.pulse=rv);return rv},evaluate(pulse){const params=this.marshall(pulse.stamp);pulse=this.transform(params,pulse);params.clear();return pulse},transform(){}});const transforms={};exports.Dataflow=Dataflow;exports.EventStream=EventStream;exports.MultiPulse=MultiPulse;exports.Operator=Operator;exports.Parameters=Parameters;
exports.Pulse=Pulse;exports.Transform=Transform;exports.UniqueList=UniqueList;exports.asyncCallback=asyncCallback;exports.changeset=changeset;exports.definition=function(type){return(type=transform(type))&&type.Definition||null};exports.derive=function(t){return rederive(t,ingest$1({}))};exports.ingest=ingest$1;exports.isChangeSet=isChangeSet;exports.isTuple=function(t){return!(!t||!t[TUPLE_ID_KEY])};exports.rederive=rederive;exports.replace=function(t,d){d[TUPLE_ID_KEY]=t[TUPLE_ID_KEY];return d};
exports.stableCompare=function(cmp,f){return cmp?f?(a,b)=>cmp(a,b)||f(a)[TUPLE_ID_KEY]-f(b)[TUPLE_ID_KEY]:(a,b)=>cmp(a,b)||a[TUPLE_ID_KEY]-b[TUPLE_ID_KEY]:null};exports.transform=transform;exports.transforms=transforms;exports.tupleid=function(t){return t[TUPLE_ID_KEY]};Object.defineProperty(exports,"__esModule",{value:!0})})}
//# sourceMappingURL=module$node_modules$vega_dataflow$build$vega_dataflow.js.map
