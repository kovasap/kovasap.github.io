shadow$provide.module$node_modules$d3_array$dist$d3_array=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){"object"===typeof exports$jscomp$0&&"undefined"!==typeof module?factory(exports$jscomp$0):"function"===typeof define&&define.amd?define(["exports"],factory):(global="undefined"!==typeof globalThis?globalThis:global||self,factory(global.d3=global.d3||{}))})(this,function(exports){function ascending(a,b){return a<b?-1:a>b?1:a>=b?0:NaN}function bisector(f){function left(a,
x,lo,hi){null==lo&&(lo=0);null==hi&&(hi=a.length);for(;lo<hi;){const mid=lo+hi>>>1;0>compare(a[mid],x)?lo=mid+1:hi=mid}return lo}let delta=f,compare=f;1===f.length&&(delta=(d,x)=>f(d)-x,compare=ascendingComparator(f));return{left,center:function(a,x,lo,hi){null==lo&&(lo=0);null==hi&&(hi=a.length);hi=left(a,x,lo,hi-1);return hi>lo&&delta(a[hi-1],x)>-delta(a[hi],x)?hi-1:hi},right:function(a,x,lo,hi){null==lo&&(lo=0);null==hi&&(hi=a.length);for(;lo<hi;){const mid=lo+hi>>>1;0<compare(a[mid],x)?hi=mid:
lo=mid+1}return lo}}}function ascendingComparator(f){return(d,x)=>ascending(f(d),x)}function number(x){return null===x?NaN:+x}function*numbers(values,valueof){if(void 0===valueof)for(var value$jscomp$0 of values)null!=value$jscomp$0&&(value$jscomp$0=+value$jscomp$0)>=value$jscomp$0&&(yield value$jscomp$0);else{value$jscomp$0=-1;for(let value of values)null!=(value=valueof(value,++value$jscomp$0,values))&&(value=+value)>=value&&(yield value)}}function count$jscomp$0(values,valueof){let count=0;if(void 0===
valueof)for(var value$jscomp$0 of values)null!=value$jscomp$0&&(value$jscomp$0=+value$jscomp$0)>=value$jscomp$0&&++count;else{value$jscomp$0=-1;for(let value of values)null!=(value=valueof(value,++value$jscomp$0,values))&&(value=+value)>=value&&++count}return count}function length$1(array){return array.length|0}function empty(length){return!(0<length)}function arrayify(values){return"object"!==typeof values||"length"in values?values:Array.from(values)}function reducer(reduce){return values=>reduce(...values)}
function variance(values,valueof){let count=0,delta,mean=0,sum=0;if(void 0===valueof)for(var value$jscomp$0 of values)null!=value$jscomp$0&&(value$jscomp$0=+value$jscomp$0)>=value$jscomp$0&&(delta=value$jscomp$0-mean,mean+=delta/++count,sum+=delta*(value$jscomp$0-mean));else{value$jscomp$0=-1;for(let value of values)null!=(value=valueof(value,++value$jscomp$0,values))&&(value=+value)>=value&&(delta=value-mean,mean+=delta/++count,sum+=delta*(value-mean))}if(1<count)return sum/(count-1)}function deviation(values,
valueof){return(values=variance(values,valueof))?Math.sqrt(values):values}function extent(values,valueof){let min,max;if(void 0===valueof)for(var value$jscomp$0 of values)null!=value$jscomp$0&&(void 0===min?value$jscomp$0>=value$jscomp$0&&(min=max=value$jscomp$0):(min>value$jscomp$0&&(min=value$jscomp$0),max<value$jscomp$0&&(max=value$jscomp$0)));else{value$jscomp$0=-1;for(let value of values)null!=(value=valueof(value,++value$jscomp$0,values))&&(void 0===min?value>=value&&(min=max=value):(min>value&&
(min=value),max<value&&(max=value)))}return[min,max]}function intern_get({_intern,_key},value){_key=_key(value);return _intern.has(_key)?_intern.get(_key):value}function intern_set({_intern,_key},value){_key=_key(value);if(_intern.has(_key))return _intern.get(_key);_intern.set(_key,value);return value}function intern_delete({_intern,_key},value){_key=_key(value);_intern.has(_key)&&(value=_intern.get(value),_intern.delete(_key));return value}function keyof(value){return null!==value&&"object"===typeof value?
value.valueOf():value}function identity(x){return x}function group$jscomp$0(values,...keys){return nest(values,identity,identity,keys)}function rollup(values,reduce,...keys){return nest(values,identity,reduce,keys)}function unique(values){if(1!==values.length)throw Error("duplicate key");return values[0]}function nest(values$jscomp$1,map,reduce,keys){return function regroup(values$jscomp$0,i){if(i>=keys.length)return reduce(values$jscomp$0);const groups=new InternMap,keyof=keys[i++];let index=-1;
for(const value of values$jscomp$0){const key=keyof(value,++index,values$jscomp$0),group=groups.get(key);group?group.push(value):groups.set(key,[value])}for(const [key,values]of groups)groups.set(key,regroup(values,i));return map(groups)}(values$jscomp$1,0)}function permute(source,keys){return Array.from(keys,key=>source[key])}function sort(values,...F){if("function"!==typeof values[Symbol.iterator])throw new TypeError("values is not iterable");values=Array.from(values);let [f$jscomp$0=ascending]=
F;if(1===f$jscomp$0.length||1<F.length){const index=Uint32Array.from(values,(d,i)=>i);1<F.length?(F=F.map(f=>values.map(f)),index.sort((i,j)=>{for(const f of F){const c=ascending(f[i],f[j]);if(c)return c}})):(f$jscomp$0=values.map(f$jscomp$0),index.sort((i,j)=>ascending(f$jscomp$0[i],f$jscomp$0[j])));return permute(values,index)}return values.sort(f$jscomp$0)}function constant(x){return function(){return x}}function ticks(start,stop,count){var reverse,i=-1,step;stop=+stop;start=+start;count=+count;
if(start===stop&&0<count)return[start];if(reverse=stop<start){var n=start;start=stop;stop=n}if(0===(step=tickIncrement(start,stop,count))||!isFinite(step))return[];if(0<step)for(count=Math.round(start/step),n=Math.round(stop/step),count*step<start&&++count,n*step>stop&&--n,start=Array(n=n-count+1);++i<n;)start[i]=(count+i)*step;else for(step=-step,count=Math.round(start*step),n=Math.round(stop*step),count/step<start&&++count,n/step>stop&&--n,start=Array(n=n-count+1);++i<n;)start[i]=(count+i)/step;
reverse&&start.reverse();return start}function tickIncrement(start,stop,count){stop=(stop-start)/Math.max(0,count);start=Math.floor(Math.log(stop)/Math.LN10);stop/=Math.pow(10,start);return 0<=start?(stop>=e10?10:stop>=e5?5:stop>=e2?2:1)*Math.pow(10,start):-Math.pow(10,-start)/(stop>=e10?10:stop>=e5?5:stop>=e2?2:1)}function nice(start,stop,count){let prestep;for(;;){const step=tickIncrement(start,stop,count);if(step===prestep||0===step||!isFinite(step))return[start,stop];0<step?(start=Math.floor(start/
step)*step,stop=Math.ceil(stop/step)*step):0>step&&(start=Math.ceil(start*step)/step,stop=Math.floor(stop*step)/step);prestep=step}}function sturges(values){return Math.ceil(Math.log(count$jscomp$0(values))/Math.LN2)+1}function bin(){function histogram(data){Array.isArray(data)||(data=Array.from(data));var i,n=data.length,values=Array(n);for(i=0;i<n;++i)values[i]=value(data[i],i,data);var xz=domain(values),x0=xz[0];xz=xz[1];var tz=threshold(values,x0,xz);if(!Array.isArray(tz)){i=xz;var tn=+tz;domain===
extent&&([x0,xz]=nice(x0,xz,tn));tz=ticks(x0,xz,tn);tz[tz.length-1]>=xz&&(i>=xz&&domain===extent?(i=tickIncrement(x0,xz,tn),isFinite(i)&&(0<i?xz=(Math.floor(xz/i)+1)*i:0>i&&(xz=(Math.ceil(xz*-i)+1)/-i))):tz.pop())}for(tn=tz.length;tz[0]<=x0;)tz.shift(),--tn;for(;tz[tn-1]>xz;)tz.pop(),--tn;var bins=Array(tn+1);for(i=0;i<=tn;++i){var x=bins[i]=[];x.x0=0<i?tz[i-1]:x0;x.x1=i<tn?tz[i]:xz}for(i=0;i<n;++i)x=values[i],x0<=x&&x<=xz&&bins[bisectRight(tz,x,0,tn)].push(data[i]);return bins}var value=identity,
domain=extent,threshold=sturges;histogram.value=function(_){return arguments.length?(value="function"===typeof _?_:constant(_),histogram):value};histogram.domain=function(_){return arguments.length?(domain="function"===typeof _?_:constant([_[0],_[1]]),histogram):domain};histogram.thresholds=function(_){return arguments.length?(threshold="function"===typeof _?_:Array.isArray(_)?constant(slice.call(_)):constant(_),histogram):threshold};return histogram}function max$jscomp$0(values,valueof){let max;
if(void 0===valueof)for(var value$jscomp$0 of values)null!=value$jscomp$0&&(max<value$jscomp$0||void 0===max&&value$jscomp$0>=value$jscomp$0)&&(max=value$jscomp$0);else{value$jscomp$0=-1;for(let value of values)null!=(value=valueof(value,++value$jscomp$0,values))&&(max<value||void 0===max&&value>=value)&&(max=value)}return max}function min$jscomp$0(values,valueof){let min;if(void 0===valueof)for(var value$jscomp$0 of values)null!=value$jscomp$0&&(min>value$jscomp$0||void 0===min&&value$jscomp$0>=
value$jscomp$0)&&(min=value$jscomp$0);else{value$jscomp$0=-1;for(let value of values)null!=(value=valueof(value,++value$jscomp$0,values))&&(min>value||void 0===min&&value>=value)&&(min=value)}return min}function quickselect(array,k,left=0,right=array.length-1,compare=ascending){for(;right>left;){if(600<right-left){var n=right-left+1,m=k-left+1,z=Math.log(n),s=.5*Math.exp(2*z/3);z=.5*Math.sqrt(z*s*(n-s)/n)*(0>m-n/2?-1:1);quickselect(array,k,Math.max(left,Math.floor(k-m*s/n+z)),Math.min(right,Math.floor(k+
(n-m)*s/n+z)),compare)}n=array[k];m=left;s=right;swap(array,left,k);for(0<compare(array[right],n)&&swap(array,left,right);m<s;){swap(array,m,s);++m;for(--s;0>compare(array[m],n);)++m;for(;0<compare(array[s],n);)--s}0===compare(array[left],n)?swap(array,left,s):(++s,swap(array,s,right));s<=k&&(left=s+1);k<=s&&(right=s-1)}return array}function swap(array,i,j){const t=array[i];array[i]=array[j];array[j]=t}function quantile(values,p,valueof){values=Float64Array.from(numbers(values,valueof));if(valueof=
values.length){if(0>=(p=+p)||2>valueof)return min$jscomp$0(values);if(1<=p)return max$jscomp$0(values);p*=valueof-1;valueof=Math.floor(p);var value0=max$jscomp$0(quickselect(values,valueof).subarray(0,valueof+1));values=min$jscomp$0(values.subarray(valueof+1));return value0+(values-value0)*(p-valueof)}}function maxIndex(values,valueof){let max,maxIndex=-1,index=-1;if(void 0===valueof)for(const value of values)++index,null!=value&&(max<value||void 0===max&&value>=value)&&(max=value,maxIndex=index);
else for(let value of values)null!=(value=valueof(value,++index,values))&&(max<value||void 0===max&&value>=value)&&(max=value,maxIndex=index);return maxIndex}function*flatten(arrays){for(const array of arrays)yield*array}function minIndex(values,valueof){let min,minIndex=-1,index=-1;if(void 0===valueof)for(const value of values)++index,null!=value&&(min>value||void 0===min&&value>=value)&&(min=value,minIndex=index);else for(let value of values)null!=(value=valueof(value,++index,values))&&(min>value||
void 0===min&&value>=value)&&(min=value,minIndex=index);return minIndex}function pair(a,b){return[a,b]}function leastIndex(values,compare=ascending){if(1===compare.length)return minIndex(values,compare);let minValue,min=-1,index=-1;for(const value of values)if(++index,0>min?0===compare(value,value):0>compare(value,minValue))minValue=value,min=index;return min}function shuffler(random){return function(array,i0=0,i1=array.length){for(i1-=i0=+i0;i1;){const i=random()*i1--|0,t=array[i1+i0];array[i1+i0]=
array[i+i0];array[i+i0]=t}return array}}function transpose$jscomp$0(matrix){if(!(n=matrix.length))return[];for(var i=-1,m=min$jscomp$0(matrix,length$jscomp$0),transpose=Array(m);++i<m;)for(var j=-1,n,row=transpose[i]=Array(n);++j<n;)row[j]=matrix[j][i];return transpose}function length$jscomp$0(d){return d.length}function set(values){return values instanceof Set?values:new Set(values)}function superset(values,other){values=values[Symbol.iterator]();const set=new Set;for(const o of other){if(set.has(o))continue;
let done;for(;{value:other,done}=values.next();){if(done)return!1;set.add(other);if(Object.is(o,other))break}}return!0}var ascendingBisect=bisector(ascending);const bisectRight=ascendingBisect.right;ascendingBisect=ascendingBisect.left;const bisectCenter=bisector(number).center;class Adder{constructor(){this._partials=new Float64Array(32);this._n=0}add(x){const p=this._partials;let i=0;for(let j=0;j<this._n&&32>j;j++){const y=p[j],hi=x+y;(x=Math.abs(x)<Math.abs(y)?x-(hi-y):y-(hi-x))&&(p[i++]=x);x=
hi}p[i]=x;this._n=i+1;return this}valueOf(){const p=this._partials;let n=this._n;let y,hi=0;if(0<n){for(hi=p[--n];0<n;){var x=hi;y=p[--n];hi=x+y;if(x=y-(hi-x))break}0<n&&(0>x&&0>p[n-1]||0<x&&0<p[n-1])&&(y=2*x,x=hi+y,y==x-hi&&(hi=x))}return hi}}class InternMap extends Map{constructor(entries,key$jscomp$0=keyof){super();Object.defineProperties(this,{_intern:{value:new Map},_key:{value:key$jscomp$0}});if(null!=entries)for(const [key,value]of entries)this.set(key,value)}get(key){return super.get(intern_get(this,
key))}has(key){return super.has(intern_get(this,key))}set(key,value){return super.set(intern_set(this,key),value)}delete(key){return super.delete(intern_delete(this,key))}}class InternSet extends Set{constructor(values,key=keyof){super();Object.defineProperties(this,{_intern:{value:new Map},_key:{value:key}});if(null!=values)for(const value of values)this.add(value)}has(value){return super.has(intern_get(this,value))}add(value){return super.add(intern_set(this,value))}delete(value){return super.delete(intern_delete(this,
value))}}var slice=Array.prototype.slice,e10=Math.sqrt(50),e5=Math.sqrt(10),e2=Math.sqrt(2),shuffle=shuffler(Math.random);exports.Adder=Adder;exports.InternMap=InternMap;exports.InternSet=InternSet;exports.ascending=ascending;exports.bin=bin;exports.bisect=bisectRight;exports.bisectCenter=bisectCenter;exports.bisectLeft=ascendingBisect;exports.bisectRight=bisectRight;exports.bisector=bisector;exports.count=count$jscomp$0;exports.cross=function(...values){const reduce="function"===typeof values[values.length-
1]&&reducer(values.pop());values=values.map(arrayify);const lengths=values.map(length$1),j$jscomp$0=values.length-1,index=Array(j$jscomp$0+1).fill(0),product=[];if(0>j$jscomp$0||lengths.some(empty))return product;for(;;){product.push(index.map((j,i)=>values[i][j]));let i$jscomp$0=j$jscomp$0;for(;++index[i$jscomp$0]===lengths[i$jscomp$0];){if(0===i$jscomp$0)return reduce?product.map(reduce):product;index[i$jscomp$0--]=0}}};exports.cumsum=function(values,valueof){var sum=0,index=0;return Float64Array.from(values,
void 0===valueof?v=>sum+=+v||0:v=>sum+=+valueof(v,index++,values)||0)};exports.descending=function(a,b){return b<a?-1:b>a?1:b>=a?0:NaN};exports.deviation=deviation;exports.difference=function(values,...others){values=new Set(values);for(const other of others)for(const value of other)values.delete(value);return values};exports.disjoint=function(values,other){other=other[Symbol.iterator]();const set=new Set;for(const v of values){if(set.has(v))return!1;let done;for(;({value:values,done}=other.next())&&
!done;){if(Object.is(v,values))return!1;set.add(values)}}return!0};exports.every=function(values,test){if("function"!==typeof test)throw new TypeError("test is not a function");let index=-1;for(const value of values)if(!test(value,++index,values))return!1;return!0};exports.extent=extent;exports.fcumsum=function(values,valueof){const adder=new Adder;let index=-1;return Float64Array.from(values,void 0===valueof?v=>adder.add(+v||0):v=>adder.add(+valueof(v,++index,values)||0))};exports.filter=function(values,
test){if("function"!==typeof test)throw new TypeError("test is not a function");const array=[];let index=-1;for(const value of values)test(value,++index,values)&&array.push(value);return array};exports.fsum=function(values,valueof){const adder=new Adder;if(void 0===valueof)for(var value$jscomp$0 of values)(value$jscomp$0=+value$jscomp$0)&&adder.add(value$jscomp$0);else{value$jscomp$0=-1;for(let value of values)(value=+valueof(value,++value$jscomp$0,values))&&adder.add(value)}return+adder};exports.greatest=
function(values,compare=ascending){let max,defined=!1;if(1===compare.length){let maxValue;for(const element of values)if(values=compare(element),defined?0<ascending(values,maxValue):0===ascending(values,values))max=element,maxValue=values,defined=!0}else for(const value of values)if(defined?0<compare(value,max):0===compare(value,value))max=value,defined=!0;return max};exports.greatestIndex=function(values,compare=ascending){if(1===compare.length)return maxIndex(values,compare);let maxValue,max=-1,
index=-1;for(const value of values)if(++index,0>max?0===compare(value,value):0<compare(value,maxValue))maxValue=value,max=index;return max};exports.group=group$jscomp$0;exports.groupSort=function(values,reduce,key$jscomp$0){return(1===reduce.length?sort(rollup(values,reduce,key$jscomp$0),([ak,av],[bk,bv])=>ascending(av,bv)||ascending(ak,bk)):sort(group$jscomp$0(values,key$jscomp$0),([ak,av],[bk,bv])=>reduce(av,bv)||ascending(ak,bk))).map(([key])=>key)};exports.groups=function(values,...keys){return nest(values,
Array.from,identity,keys)};exports.histogram=bin;exports.index=function(values,...keys){return nest(values,identity,unique,keys)};exports.indexes=function(values,...keys){return nest(values,Array.from,unique,keys)};exports.intersection=function(values,...others){values=new Set(values);others=others.map(set);a:for(const value of values)for(const other of others)if(!other.has(value)){values.delete(value);continue a}return values};exports.least=function(values,compare=ascending){let min,defined=!1;if(1===
compare.length){let minValue;for(const element of values)if(values=compare(element),defined?0>ascending(values,minValue):0===ascending(values,values))min=element,minValue=values,defined=!0}else for(const value of values)if(defined?0>compare(value,min):0===compare(value,value))min=value,defined=!0;return min};exports.leastIndex=leastIndex;exports.map=function(values,mapper){if("function"!==typeof values[Symbol.iterator])throw new TypeError("values is not iterable");if("function"!==typeof mapper)throw new TypeError("mapper is not a function");
return Array.from(values,(value,index)=>mapper(value,index,values))};exports.max=max$jscomp$0;exports.maxIndex=maxIndex;exports.mean=function(values,valueof){let count=0,sum=0;if(void 0===valueof)for(var value$jscomp$0 of values)null!=value$jscomp$0&&(value$jscomp$0=+value$jscomp$0)>=value$jscomp$0&&(++count,sum+=value$jscomp$0);else{value$jscomp$0=-1;for(let value of values)null!=(value=valueof(value,++value$jscomp$0,values))&&(value=+value)>=value&&(++count,sum+=value)}if(count)return sum/count};
exports.median=function(values,valueof){return quantile(values,.5,valueof)};exports.merge=function(arrays){return Array.from(flatten(arrays))};exports.min=min$jscomp$0;exports.minIndex=minIndex;exports.nice=nice;exports.pairs=function(values,pairof=pair){const pairs=[];let previous,first=!1;for(const value of values)first&&pairs.push(pairof(previous,value)),previous=value,first=!0;return pairs};exports.permute=permute;exports.quantile=quantile;exports.quantileSorted=function(values,p,valueof=number){if(n=
values.length){if(0>=(p=+p)||2>n)return+valueof(values[0],0,values);if(1<=p)return+valueof(values[n-1],n-1,values);var n;p*=n-1;n=Math.floor(p);var value0=+valueof(values[n],n,values);values=+valueof(values[n+1],n+1,values);return value0+(values-value0)*(p-n)}};exports.quickselect=quickselect;exports.range=function(start,stop,step){start=+start;stop=+stop;step=2>(n=arguments.length)?(stop=start,start=0,1):3>n?1:+step;for(var i=-1,n=Math.max(0,Math.ceil((stop-start)/step))|0,range=Array(n);++i<n;)range[i]=
start+i*step;return range};exports.reduce=function(values,reducer,value){if("function"!==typeof reducer)throw new TypeError("reducer is not a function");const iterator=values[Symbol.iterator]();let done,next,index=-1;if(3>arguments.length){({done,value}=iterator.next());if(done)return;++index}for(;{done,value:next}=iterator.next(),!done;)value=reducer(value,next,++index,values);return value};exports.reverse=function(values){if("function"!==typeof values[Symbol.iterator])throw new TypeError("values is not iterable");
return Array.from(values).reverse()};exports.rollup=rollup;exports.rollups=function(values,reduce,...keys){return nest(values,Array.from,reduce,keys)};exports.scan=function(values,compare){values=leastIndex(values,compare);return 0>values?void 0:values};exports.shuffle=shuffle;exports.shuffler=shuffler;exports.some=function(values,test){if("function"!==typeof test)throw new TypeError("test is not a function");let index=-1;for(const value of values)if(test(value,++index,values))return!0;return!1};
exports.sort=sort;exports.subset=function(values,other){return superset(other,values)};exports.sum=function(values,valueof){let sum=0;if(void 0===valueof)for(var value$jscomp$0 of values){if(value$jscomp$0=+value$jscomp$0)sum+=value$jscomp$0}else{value$jscomp$0=-1;for(let value of values)if(value=+valueof(value,++value$jscomp$0,values))sum+=value}return sum};exports.superset=superset;exports.thresholdFreedmanDiaconis=function(values,min,max){return Math.ceil((max-min)/(2*(quantile(values,.75)-quantile(values,
.25))*Math.pow(count$jscomp$0(values),-1/3)))};exports.thresholdScott=function(values,min,max){return Math.ceil((max-min)/(3.5*deviation(values)*Math.pow(count$jscomp$0(values),-1/3)))};exports.thresholdSturges=sturges;exports.tickIncrement=tickIncrement;exports.tickStep=function(start,stop,count){var step0=Math.abs(stop-start)/Math.max(0,count);count=Math.pow(10,Math.floor(Math.log(step0)/Math.LN10));step0/=count;step0>=e10?count*=10:step0>=e5?count*=5:step0>=e2&&(count*=2);return stop<start?-count:
count};exports.ticks=ticks;exports.transpose=transpose$jscomp$0;exports.union=function(...others){const set=new Set;for(const other of others)for(const o of other)set.add(o);return set};exports.variance=variance;exports.zip=function(){return transpose$jscomp$0(arguments)};Object.defineProperty(exports,"__esModule",{value:!0})})}
//# sourceMappingURL=module$node_modules$d3_array$dist$d3_array.js.map
