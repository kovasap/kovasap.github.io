shadow$provide.module$node_modules$vega_crossfilter$build$vega_crossfilter=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){"object"===typeof exports$jscomp$0&&"undefined"!==typeof module?factory(exports$jscomp$0,require("module$node_modules$d3_array$dist$d3_array"),require("module$node_modules$vega_dataflow$build$vega_dataflow"),require("module$node_modules$vega_util$build$vega_util")):"function"===typeof define&&define.amd?define(["exports","d3-array","vega-dataflow",
"vega-util"],factory):(global="undefined"!==typeof globalThis?globalThis:global||self,factory((global.vega=global.vega||{},global.vega.transforms={}),global.d3,global.vega,global.vega))})(this,function(exports,d3Array,vegaDataflow,vegaUtil){function Bitmaps(){let width=8,data=[],seen=new Uint32Array(0),curr=array$jscomp$0(0,width),prev=array$jscomp$0(0,width);return{data:()=>data,seen:()=>{var JSCompiler_inline_result=seen;var length=data.length;JSCompiler_inline_result.length>=length||(length=new JSCompiler_inline_result.constructor(length),
length.set(JSCompiler_inline_result),JSCompiler_inline_result=length);return seen=JSCompiler_inline_result},add(array){for(let i=0,j=data.length,n=array.length,t;i<n;++i)t=array[i],t._index=j++,data.push(t)},remove(num,map){const n=data.length;num=Array(n-num);const reindex=data;let t,i,j;for(i=0;!map[i]&&i<n;++i)num[i]=data[i],reindex[i]=i;for(j=i;i<n;++i)t=data[i],map[i]?reindex[i]=-1:(reindex[i]=j,curr[j]=curr[i],prev[j]=prev[i],num[j]=t,t._index=j++),curr[i]=0;data=num;return reindex},size:()=>
data.length,curr:()=>curr,prev:()=>prev,reset:k=>prev[k]=curr[k],all:()=>257>width?255:65537>width?65535:4294967295,set(k,one){curr[k]|=one},clear(k,one){curr[k]&=~one},resize(n,m){if(n>curr.length||m>width)width=Math.max(m,width),curr=array$jscomp$0(n,width,curr),prev=array$jscomp$0(n,width)}}}function array$jscomp$0(n,m,array){n=(257>m?array8:65537>m?array16:array32)(n);array&&n.set(array);return n}function Dimension(index,i$jscomp$0,query){const bit=1<<i$jscomp$0;return{one:bit,zero:~bit,range:query.slice(),
bisect:index.bisect,index:index.index,size:index.size,onAdd(added,curr){var range=this.bisect(this.range,added.value);added=added.index;const lo=range[0];range=range[1];const n1=added.length;let i;for(i=0;i<lo;++i)curr[added[i]]|=bit;for(i=range;i<n1;++i)curr[added[i]]|=bit;return this}}}function SortedIndex(){let index$jscomp$0=new Uint32Array(0),value$jscomp$0=[],size=0;return{insert:function(key,data,base){if(!data.length)return[];const n0=size,n1=data.length,addi=new Uint32Array(n1);let addv=
Array(n1);var i$jscomp$0;for(i$jscomp$0=0;i$jscomp$0<n1;++i$jscomp$0)addv[i$jscomp$0]=key(data[i$jscomp$0]),addi[i$jscomp$0]=i$jscomp$0;addv=sort(addv,addi);if(n0){key=value$jscomp$0;data=index$jscomp$0;value$jscomp$0=Array(n0+n1);index$jscomp$0=new Uint32Array(n0+n1);i$jscomp$0=addv;var value=value$jscomp$0,index=index$jscomp$0;let i0=0,i1=0,i;for(i=0;i0<n0&&i1<n1;++i)key[i0]<i$jscomp$0[i1]?(value[i]=key[i0],index[i]=data[i0++]):(value[i]=i$jscomp$0[i1],index[i]=addi[i1++]+base);for(;i0<n0;++i0,
++i)value[i]=key[i0],index[i]=data[i0];for(;i1<n1;++i1,++i)value[i]=i$jscomp$0[i1],index[i]=addi[i1]+base}else{if(0<base)for(i$jscomp$0=0;i$jscomp$0<n1;++i$jscomp$0)addi[i$jscomp$0]+=base;value$jscomp$0=addv;index$jscomp$0=addi}size=n0+n1;return{index:addi,value:addv}},remove:function(num,map){const n=size;let idx,i,j;for(i=0;!map[index$jscomp$0[i]]&&i<n;++i);for(j=i;i<n;++i)map[idx=index$jscomp$0[i]]||(index$jscomp$0[j]=idx,value$jscomp$0[j]=value$jscomp$0[i],++j);size=n-num},bisect:function(range,
array){let n;array?n=array.length:(array=value$jscomp$0,n=size);return[d3Array.bisectLeft(array,range[0],0,n),d3Array.bisectRight(array,range[1],0,n)]},reindex:function(map){for(let i=0,n=size;i<n;++i)index$jscomp$0[i]=map[index$jscomp$0[i]]},index:()=>index$jscomp$0,size:()=>size}}function sort(values,index){values.sort.call(index,(a,b)=>{a=values[a];b=values[b];return a<b?-1:a>b?1:0});return d3Array.permute(values,index)}function CrossFilter(params){vegaDataflow.Transform.call(this,Bitmaps(),params);
this._dims=this._indices=null}function ResolveFilter(params){vegaDataflow.Transform.call(this,null,params)}const array8=n=>new Uint8Array(n),array16=n=>new Uint16Array(n),array32=n=>new Uint32Array(n);CrossFilter.Definition={type:"CrossFilter",metadata:{},params:[{name:"fields",type:"field",array:!0,required:!0},{name:"query",type:"array",array:!0,required:!0,content:{type:"number",array:!0,length:2}}]};vegaUtil.inherits(CrossFilter,vegaDataflow.Transform,{transform(_,pulse){return this._dims?_.modified("fields")||
_.fields.some(f=>pulse.modified(f.fields))?this.reinit(_,pulse):this.eval(_,pulse):this.init(_,pulse)},init(_,pulse){const fields=_.fields,query=_.query,indices=this._indices={},dims=this._dims=[],m=query.length;let i=0;for(var key;i<m;++i)key=fields[i].fname,key=indices[key]||(indices[key]=SortedIndex()),dims.push(Dimension(key,i,query[i]));return this.eval(_,pulse)},reinit(_,pulse){const output=pulse.materialize().fork(),fields=_.fields,query=_.query,indices=this._indices,dims=this._dims,bits=this.value,
curr=bits.curr(),prev=bits.prev(),all=bits.all(),out=output.rem=output.add,mod=output.mod,m=query.length,adds={};let index;var key;let remMap,modMap,i,f;prev.set(curr);pulse.rem.length&&(remMap=this.remove(_,pulse,output));pulse.add.length&&bits.add(pulse.add);if(pulse.mod.length){modMap={};var add=pulse.mod;i=0;for(key=add.length;i<key;++i)modMap[add[i]._index]=1}for(i=0;i<m;++i)if(f=fields[i],!dims[i]||_.modified("fields",i)||pulse.modified(f.fields))key=f.fname,(add=adds[key])||(indices[key]=index=
SortedIndex(),adds[key]=add=index.insert(f,pulse.source,0)),dims[i]=Dimension(index,i,query[i]).onAdd(add,curr);i=0;for(key=bits.data().length;i<key;++i)remMap[i]||(prev[i]!==curr[i]?out.push(i):modMap[i]&&curr[i]!==all&&mod.push(i));bits.mask=(1<<m)-1;return output},eval(_,pulse){const output=pulse.materialize().fork(),m=this._dims.length;let mask=0;pulse.rem.length&&(this.remove(_,pulse,output),mask|=(1<<m)-1);_.modified("query")&&!_.modified("fields")&&(mask|=this.update(_,pulse,output));pulse.add.length&&
(this.insert(_,pulse,output),mask|=(1<<m)-1);pulse.mod.length&&(this.modify(pulse,output),mask|=(1<<m)-1);this.value.mask=mask;return output},insert(_,pulse,output){pulse=pulse.add;var bits=this.value;const dims=this._dims,indices=this._indices;_=_.fields;const adds={};output=output.add;const n=bits.size()+pulse.length,m=dims.length;let k=bits.size();bits.resize(n,m);bits.add(pulse);const curr=bits.curr(),prev=bits.prev(),all=bits.all();for(bits=0;bits<m;++bits){var key=_[bits].fname;key=adds[key]||
(adds[key]=indices[key].insert(_[bits],pulse,k));dims[bits].onAdd(key,curr)}for(;k<n;++k)prev[k]=all,curr[k]!==all&&output.push(k)},modify(pulse,output){output=output.mod;var bits=this.value;const curr=bits.curr();bits=bits.all();pulse=pulse.mod;let i,n,k;i=0;for(n=pulse.length;i<n;++i)k=pulse[i]._index,curr[k]!==bits&&output.push(k)},remove(_,pulse,output){_=this._indices;var bits=this.value;const curr=bits.curr(),prev=bits.prev();bits=bits.all();const map={};output=output.rem;const tuples=pulse.rem;
let i,n,k,f;i=0;for(n=tuples.length;i<n;++i)k=tuples[i]._index,map[k]=1,prev[k]=f=curr[k],curr[k]=bits,f!==bits&&output.push(k);for(k in _)_[k].remove(n,map);this.reindex(pulse,n,map);return map},reindex(pulse,num,map){const indices=this._indices,bits=this.value;pulse.runAfter(()=>{const indexMap=bits.remove(num,map);for(const key in indices)indices[key].reindex(indexMap)})},update(_,pulse,output){const dims=this._dims,query=_.query;pulse=pulse.stamp;const m=dims.length;let mask=0,i,q;for(q=output.filters=
0;q<m;++q)_.modified("query",q)&&(i=q,++mask);if(1===mask)mask=dims[i].one,this.incrementOne(dims[i],query[i],output.add,output.rem);else for(mask=q=0;q<m;++q)_.modified("query",q)&&(mask|=dims[q].one,this.incrementAll(dims[q],query[q],pulse,output.add),output.rem=output.add);return mask},incrementAll(dim,query,stamp,out){var bits=this.value;const seen=bits.seen(),curr=bits.curr();bits=bits.prev();const index=dim.index();var old=dim.bisect(dim.range),range=dim.bisect(query);const lo1=range[0];range=
range[1];const lo0=old[0];old=old[1];const one=dim.one;let i,j,k;if(lo1<lo0)for(i=lo1,j=Math.min(lo0,range);i<j;++i)k=index[i],seen[k]!==stamp&&(bits[k]=curr[k],seen[k]=stamp,out.push(k)),curr[k]^=one;else if(lo1>lo0)for(i=lo0,j=Math.min(lo1,old);i<j;++i)k=index[i],seen[k]!==stamp&&(bits[k]=curr[k],seen[k]=stamp,out.push(k)),curr[k]^=one;if(range>old)for(i=Math.max(lo1,old),j=range;i<j;++i)k=index[i],seen[k]!==stamp&&(bits[k]=curr[k],seen[k]=stamp,out.push(k)),curr[k]^=one;else if(range<old)for(i=
Math.max(lo0,range),j=old;i<j;++i)k=index[i],seen[k]!==stamp&&(bits[k]=curr[k],seen[k]=stamp,out.push(k)),curr[k]^=one;dim.range=query.slice()},incrementOne(dim,query,add,rem){const curr=this.value.curr(),index=dim.index();var old=dim.bisect(dim.range),range=dim.bisect(query);const lo1=range[0];range=range[1];const lo0=old[0];old=old[1];const one=dim.one;let i,j,k;if(lo1<lo0)for(i=lo1,j=Math.min(lo0,range);i<j;++i)k=index[i],curr[k]^=one,add.push(k);else if(lo1>lo0)for(i=lo0,j=Math.min(lo1,old);i<
j;++i)k=index[i],curr[k]^=one,rem.push(k);if(range>old)for(i=Math.max(lo1,old),j=range;i<j;++i)k=index[i],curr[k]^=one,add.push(k);else if(range<old)for(i=Math.max(lo0,range),j=old;i<j;++i)k=index[i],curr[k]^=one,rem.push(k);dim.range=query.slice()}});ResolveFilter.Definition={type:"ResolveFilter",metadata:{},params:[{name:"ignore",type:"number",required:!0,description:"A bit mask indicating which filters to ignore."},{name:"filter",type:"object",required:!0,description:"Per-tuple filter bitmaps from a CrossFilter transform."}]};
vegaUtil.inherits(ResolveFilter,vegaDataflow.Transform,{transform(_,pulse){const ignore=~(_.ignore||0);_=_.filter;const mask=_.mask;if(0===(mask&ignore))return pulse.StopPropagation;pulse=pulse.fork(pulse.ALL);const data=_.data(),curr=_.curr(),prev=_.prev(),pass=k=>curr[k]&ignore?null:data[k];pulse.filter(pulse.MOD,pass);mask&mask-1?(pulse.filter(pulse.ADD,k=>{const c=curr[k]&ignore;return!c&&c^prev[k]&ignore?data[k]:null}),pulse.filter(pulse.REM,k=>{const c=curr[k]&ignore;return!c||c^c^prev[k]&ignore?
null:data[k]})):(pulse.filter(pulse.ADD,pass),pulse.filter(pulse.REM,k=>(curr[k]&ignore)===mask?data[k]:null));return pulse.filter(pulse.SOURCE,t=>pass(t._index))}});exports.crossfilter=CrossFilter;exports.resolvefilter=ResolveFilter;Object.defineProperty(exports,"__esModule",{value:!0})})}
//# sourceMappingURL=module$node_modules$vega_crossfilter$build$vega_crossfilter.js.map
