{"version":3,"sources":["clojure/core/rrb_vector/trees.cljs"],"mappings":";AAaA,yCAAA,zCAAMA,0FAAUC,KAAKC,KAAKC,MAAMC;AAAhC,AACE,GAAI,iBAAA,hBAAI,AAASH;AACf,QAAA,JAAOI;IAAIC,IAAEF;;AAAb,AACE,GAAI,CAAIC,MAAEF;AACRG;;AACA,IAAMC,MAAI,CAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA;IACJC,MAAI,AAACC,0BAAaP,KAAKK;AAD7B,AAEE,KAAA,JAAMA,WAAMD;;AACZ,eAAO,KAAA,JAAGD;eAAKG;;;;;;;;AACrB,QAAA,JAAOH;IAAIC,IAAEF;;AAAb,AACE,GAAI,CAAIC,MAAEF;AACRG;;AACA,IAAMC,MAAK,CAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA;IACLG,OAAK,CAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA;IACLF,MAAK,AAACC,0BAAaP,KAAKK;AAF9B,AAGE,KAAA,JAAMA,WAAMD;;AACZ,KAAA,JAAMC,YAAOG;;AACb,MAAA,QAAA,bAAMA;;AACN,MAAA,LAAMA,YAAO,AAAST;;AACtB,eAAO,KAAA,JAAGI;eAAKG;;;;;;;;;AAEzB,0CAAA,1CAAMG,4FAAWR,MAAMS,IAAIC,UAAUT,aAAaU;AAAlD,AACE,GAAI,AAACC,6CAASX;AACZ,IAAMG,MAAI,AAACS,iBAAO,AAAOZ;IACnBI,MAAI,AAACC,0BAAa,AAAQL,kBAAcG;AAD9C,AAEE,IAAOD,UAAEE;IAAIL,kBAAMA;;AAAnB,AACE,IAAMI,gBAAO,AAAOD;IACdW,eAAO,oCAAA,nCAAS,CAAiB,OAAA,NAAKL,cAAKT;AADjD,AAEE,GAAI,qBAAA,pBAAIA;AACN,CAAMI,cAAIU,gBAAOH;;AACjB,IAAAI,2BAAe,CAAMX,cAAIU;AAAzB,AAAA,oBAAAC;AAAA,kBAAAA,dAASC;AAAT,AACE,IAAMC,iBAAU,AAACJ,iBAAO,AAAOG;IACzBE,kBAAU,AAACZ,0BAAaI,UAAUO;AADxC,AAEE,CAAMb,cAAIU,gBAAOI;;AACjB,eAAOA;eAAU,mBAAA,lBAAGlB;;;;;AACtB,CAAMI,cAAIU,gBACJ,AAACjB,uCAAS,AAAOc,cACPD,UACA,mBAAA,lBAAGV,uBACHW;;;;;;AACxBN;;AACF,IAAMD,MAAK,AAACS,iBAAO,AAAOZ;IACpBM,OAAK,AAACY,0CAAYlB;IAClBmB,KAAK,gBAAA,fAAK,MAAA,LAAMb;IAChBF,MAAK,AAACC,0BAAa,AAAQL,kBAAcG;IACzCiB,OAAK,mBAAA,jBAAI,WAAA,VAAIrB,qBAEN,iBAAMgB,QAAM,CAAMZ,IAAIgB;IAChBE,OAAM,gEAAA,/DAAG,EAAI,MAAA,LAAMF,WACR,CAAG,CAAMb,KAAKa,OAAI,CAAMb,KAAK,MAAA,LAAKa,aAClC,MAAA,LAAMb;AAHvB,AASE,GAAA,GAAQ,AAACgB,8CAAUP,MAAM,SAAA,RAAGhB,aAASsB;AACnC,IAAAE,WAAW,SAAA,RAAGxB;IAAdyB,WAAuBH;IAAvBI,WAA4BhB;IAA5BiB,WACWX;IADXY,WAEWjB;AAFX,AAAA,sJAAAa,SAAAC,SAAAC,SAAAC,SAAAC,8DAAAJ,SAAAC,SAAAC,SAAAC,SAAAC,pRAACpB,wEAAAA,sHAAAA;;AADH;;;AAff,AAmBE,oBAAIa;AACF,AAAI,CAAMjB,IAAIgB,MAAGC;;AACb,CAAMd,KAAKa,MAAG,cAAA,bAAG,CAAMb,KAAKa;;AAC5Bf;;AACJ,AAAI,GAAM,OAAA,NAAIe;AAAV,AAEE,IAAMS,YAAI,CAAA,2EAAA,aAAA,4CAAA,yCAAA,9GAAwB,MAAA,LAAKT;iBAAvC,2CAAA,4DAAA,sDAAA,kFAAA,0EAAA,wDAAA,mDAAA,jbAIMU,8GAAa9B,wDAAYS,yEAAmBR,6EAC3BU,6DAAiBJ,qDAAUa,wDAChCC;AANlB,AAOE,MAAO,AAACU,gDAAQF,UAAIC;;AATxB;;AAUA,CAAM1B,IAAI,MAAA,LAAKgB,aACT,AAACvB,uCAAS,AAAOc,cACPD,UACA,SAAA,RAAGV,aACHW;;AAChB,CAAMJ,KAAK,MAAA,LAAKa,aAAI,cAAA,bAAG,CAAMb,KAAKa;;AAClC,MAAA,LAAMb,aAAQ,gBAAA,fAAK,MAAA,LAAMA;;AACzBF;;;;AAEZ,yCAAA,zCAAM2B,0FAAUhC,MAAMS,IAAIC,UAAUT;AAApC,AACE,GAAI,AAACW,6CAASX;AACZ,IAAMa,SAAO,0BAAA,zBAAS,CAAiB,OAAA,NAAGL,cAAOT;AAAjD,AACE,GACE,SAAA,RAAGA;AACH,IAAMkB,YAAU,iBAAAe,WAAU,SAAA,RAAGjC;IAAbkC,WAAsBzB;IAAtB0B,WAA0BzB;IAA1B0B,WACU,CAAM,AAAOnC,iBAAca;AADrC,AAAA,oJAAAmB,SAAAC,SAAAC,SAAAC,6DAAAH,SAAAC,SAAAC,SAAAC,/PAACJ,uEAAAA,4GAAAA;;AAAjB,AAEE,GAAI,EAAK,cAAA,bAAMd,wBAAW,YAAA,XAAOJ;AAAjC;;AAEE,IAAMV,MAAI,AAACS,iBAAO,AAAOZ;AAAzB,AACE,CAAMG,IAAIU,UAAOI;;AACjB,OAACZ,0BAAaI,UAAUN;;;AARhC,GAUE,YAAA,XAAOU;AAVT;;AAAA,AAcE,IAAMV,MAAI,AAACS,iBAAO,AAAOZ;AAAzB,AACE,eAAA,dAAMG,IAAIU;;AACV,OAACR,0BAAaI,UAAUN;;;;;AAC9B,IAAMG,OAAO,AAACY,0CAAYlB;IACpBa,SAAO,gBAAA,fAAK,MAAA,LAAMP;IAClB8B,WAAS,AAACxB,iBAAON;AAFvB,AAGE,GACE,SAAA,RAAGP;AACH,IAAMgB,QAAU,CAAM,AAAOf,iBAAca;IACrCwB,YAAU,EAAI,YAAA,XAAOxB,iBACT,MAAA,LAAMP,WACN,CAAG,CAAMA,KAAKO,WAAQ,CAAMP,KAAK,UAAA,TAAKO;IAClDI,YAAU,iBAAAqB,WAAU,SAAA,RAAGvC;IAAbwC,WAAsBF;IAAtBG,WAAgC/B;IAAhCgC,WAA0C1B;AAA1C,AAAA,oJAAAuB,SAAAC,SAAAC,SAAAC,6DAAAH,SAAAC,SAAAC,SAAAC,/PAACV,uEAAAA,4GAAAA;;AAJjB,AAKE,GACE,EAAK,cAAA,bAAMd,wBAAW,YAAA,XAAOJ;AAD/B;;AAAA,GAIE,AAACF,6CAASI;AACV,IAAMZ,MAAI,AAACS,iBAAO,AAAOZ;AAAzB,AACE,CAAMoC,SAASvB,UAAO,sBAAA,rBAAG,CAAMuB,SAASvB;;AACxC,CAAMV,IAAIU,UAAOI;;AACjB,KAAA,JAAMd,YAAOiC;;AACb,GAAI,cAAA,bAAMnB;AACR,UAAA,TAAMmB,iBAAY,oBAAA,nBAAK,UAAA,TAAMA;;AAD/B;;AAEA,OAAC/B,0BAAaI,UAAUN;;AAX5B,AAcE,IAAMuC,MAAK,AAACC,yCAAW5B;IACjB6B,OAAK,CAAGF,MAAI,iFAAA,/DAAIzB,WAAU,AAAC0B,yCAAW1B;IACtCd,MAAK,AAACS,iBAAO,AAAOZ;AAF1B,AAGE,CAAMoC,SAASvB,UAAO,CAAG,CAAMuB,SAASvB,WAAQ+B;;AAChD,CAAMzC,IAAIU,UAAOI;;AACjB,KAAA,JAAMd,YAAOiC;;AACb,GAAI,cAAA,bAAMnB;AACR,UAAA,TAAMmB,iBAAY,oBAAA,nBAAK,UAAA,TAAMA;;AAD/B;;AAEA,OAAC/B,0BAAaI,UAAUN;;;;;AA7BhC,GA+BE,YAAA,XAAOU;AA/BT;;AAAA,AAmCE,IAAMV,MAAS,AAACS,iBAAO,AAAOZ;IACxBe,QAAS,CAAMZ,IAAIU;IACnBuB,eAAS,AAACxB,iBAAON;AAFvB,AAGE,eAAA,dAAMH,IAAIU;;AACV,KAAA,JAAMV,YAAOiC;;AACb,wBAAA,vBAAMA,aAASvB;;AACf,cAAA,bAAMuB,qBAAY,wBAAA,vBAAK,cAAA,bAAMA;;AAC7B,OAAC/B,0BAAaI,UAAUN;;;;;;AAElC,yCAAA,zCAAM0C,0FAAU9C,MAAMC,aAAa8C,EAAEC;AAArC,AACE,GAAI,AAACpC,6CAASX;AACZ,IAAMgD,OAAK,AAACC,oCAAMlD,MAAMC;AAAxB,AACE,IAAOD,kBAAMA;IACNiD,iBAAMA;;AADb,AAEE,GAAI,qBAAA,pBAAOjD;AACT,IAAMI,YAAI,AAAO6C;AAAjB,AACE,CAAM7C,UAAI,KAAA,JAAS2C,aAAQC;;AAC7B,IAAM5C,YAAO,AAAO6C;IACdnC,eAAO,0BAAA,zBAAS,CAAiBiC,KAAE/C;IACnCgB,cAAO,AAACkC,oCAAMlD,gBAAM,CAAMI,UAAIU;AAFpC,AAGE,CAAMV,UAAIU,gBAAOE;;AACjB,eAAO,mBAAA,lBAAGhB;eAASgB;;;;;;;;AACzBiC;;AACF,IAAM7C,MAAO,AAACS,iBAAO,AAAOZ;IACtBM,OAAO,AAACY,0CAAYlB;IACpBa,SAAO,gBAAA,fAAS,CAAiBiC,KAAE/C;IACnCc,aAAO,iBAAOA,aAAOA;;AAAd,AACE,GAAI,CAAGiC,IAAE,sBAAA,rBAAK,CAAMxC,KAAKO;AACvBA;;AACA,eAAO,cAAA,bAAKA;;;;;;;IACvBiC,QAAO,EAAI,gBAAA,fAAOjC,qBAAQiC,EAAE,CAAGA,IAAE,CAAMxC,KAAK,cAAA,bAAKO;AAPvD,AAQE,CAAMV,IAAIU,cACJ,iBAAAqC,WAAU,SAAA,RAAGnD;IAAboD,WAAsB,CAAMhD,IAAIU;IAAhCuC,WAAwCN;IAAxCO,WAA0CN;AAA1C,AAAA,oJAAAG,SAAAC,SAAAC,SAAAC,6DAAAH,SAAAC,SAAAC,SAAAC,/PAACR,uEAAAA,4GAAAA;;;AACP,OAACxC,0BAAa,AAAQL,kBAAcG","names":["clojure.core.rrb-vector.trees/new-path","tail","edit","shift","current-node","s","n","arr","ret","cljs.core/->VectorNode","rngs","clojure.core.rrb-vector.trees/push-tail","cnt","root-edit","tail-node","clojure.core.rrb-vector.nodes/regular?","cljs.core/aclone","subidx","temp__5751__auto__","child","new-carr","new-child","clojure.core.rrb-vector.nodes/node-ranges","li","cret","ccnt","clojure.core.rrb-vector.nodes/overflow?","G__83189","G__83190","G__83191","G__83192","G__83193","msg","data","cljs.core.ex_info","clojure.core.rrb-vector.trees/pop-tail","G__83196","G__83197","G__83198","G__83199","new-rngs","child-cnt","G__83204","G__83205","G__83206","G__83207","rng","clojure.core.rrb-vector.nodes/last-range","diff","clojure.core.rrb-vector.trees/do-assoc","i","val","node","clojure.core.rrb-vector.nodes/clone","G__83219","G__83220","G__83221","G__83222"],"sourcesContent":[";   Copyright (c) Rich Hickey and contributors. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.core.rrb-vector.trees\n  (:refer-clojure :exclude [array-for push-tail pop-tail new-path do-assoc])\n  (:require [clojure.core.rrb-vector.nodes\n             :refer [regular? clone node-ranges last-range overflow?]]))\n\n(defn new-path [tail edit shift current-node]\n  (if (== (alength tail) 32)\n    (loop [s 0 n current-node]\n      (if (== s shift)\n        n\n        (let [arr (make-array 32)\n              ret (->VectorNode edit arr)]\n          (aset arr 0 n)\n          (recur (+ s 5) ret))))\n    (loop [s 0 n current-node]\n      (if (== s shift)\n        n\n        (let [arr  (make-array 33)\n              rngs (make-array 33)\n              ret  (->VectorNode edit arr)]\n          (aset arr 0 n)\n          (aset arr 32 rngs)\n          (aset rngs 32 1)\n          (aset rngs 0 (alength tail))\n          (recur (+ s 5) ret))))))\n\n(defn push-tail [shift cnt root-edit current-node tail-node]\n  (if (regular? current-node)\n    (let [arr (aclone (.-arr current-node))\n          ret (->VectorNode (.-edit current-node) arr)]\n      (loop [n ret shift shift]\n        (let [arr    (.-arr n)\n              subidx (bit-and (bit-shift-right (dec cnt) shift) 0x1f)]\n          (if (== shift 5)\n            (aset arr subidx tail-node)\n            (if-let [child (aget arr subidx)]\n              (let [new-carr  (aclone (.-arr child))\n                    new-child (->VectorNode root-edit new-carr)]\n                (aset arr subidx new-child)\n                (recur new-child (- shift 5)))\n              (aset arr subidx\n                    (new-path (.-arr tail-node)\n                              root-edit\n                              (- shift 5)\n                              tail-node))))))\n      ret)\n    (let [arr  (aclone (.-arr current-node))\n          rngs (node-ranges current-node)\n          li   (dec (aget rngs 32))\n          ret  (->VectorNode (.-edit current-node) arr)\n          cret (if (== shift 5)\n                 nil\n                 (let [child (aget arr li)\n                       ccnt  (+ (if (pos? li)\n                                  (- (aget rngs li) (aget rngs (dec li)))\n                                  (aget rngs 0))\n                                ;; add 32 elems to account for the new\n                                ;; 32-elem tail we plan to add to the\n                                ;; subtree.\n                                32)]\n                   ;; See Note 2 in file transients.cljs\n                   (if-not (overflow? child (- shift 5) ccnt)\n                     (push-tail (- shift 5) ccnt root-edit\n                                child\n                                tail-node))))]\n      (if cret\n        (do (aset arr li cret)\n            (aset rngs li (+ (aget rngs li) 32))\n            ret)\n        (do (when (>= li 31)\n              ;; See Note 1 in file transients.cljs\n              (let [msg (str \"Assigning index \" (inc li) \" of vector\"\n                             \" object array to become a node, when that\"\n                             \" index should only be used for storing\"\n                             \" range arrays.\")\n                    data {:shift shift, :cnt cnt, :current-node current-node,\n                          :tail-node tail-node, :rngs rngs, :li li,\n                          :cret cret}]\n                (throw (ex-info msg data))))\n            (aset arr (inc li)\n                  (new-path (.-arr tail-node)\n                            root-edit\n                            (- shift 5)\n                            tail-node))\n            (aset rngs (inc li) (+ (aget rngs li) 32))\n            (aset rngs 32 (inc (aget rngs 32)))\n            ret)))))\n\n(defn pop-tail [shift cnt root-edit current-node]\n  (if (regular? current-node)\n    (let [subidx (bit-and (bit-shift-right (- cnt 2) shift) 0x1f)]\n      (cond\n        (> shift 5)\n        (let [new-child (pop-tail (- shift 5) cnt root-edit\n                                  (aget (.-arr current-node) subidx))]\n          (if (and (nil? new-child) (zero? subidx))\n            nil\n            (let [arr (aclone (.-arr current-node))]\n              (aset arr subidx new-child)\n              (->VectorNode root-edit arr))))\n\n        (zero? subidx)\n        nil\n\n        :else\n        (let [arr (aclone (.-arr current-node))]\n          (aset arr subidx nil)\n          (->VectorNode root-edit arr))))\n    (let [rngs   (node-ranges current-node)\n          subidx (dec (aget rngs 32))\n          new-rngs (aclone rngs)]\n      (cond\n        (> shift 5)\n        (let [child     (aget (.-arr current-node) subidx)\n              child-cnt (if (zero? subidx)\n                          (aget rngs 0)\n                          (- (aget rngs subidx) (aget rngs (dec subidx))))\n              new-child (pop-tail (- shift 5) child-cnt root-edit child)]\n          (cond\n            (and (nil? new-child) (zero? subidx))\n            nil\n\n            (regular? child)\n            (let [arr (aclone (.-arr current-node))]\n              (aset new-rngs subidx (- (aget new-rngs subidx) 32))\n              (aset arr subidx new-child)\n              (aset arr 32 new-rngs)\n              (if (nil? new-child)\n                (aset new-rngs 32 (dec (aget new-rngs 32))))\n              (->VectorNode root-edit arr))\n\n            :else\n            (let [rng  (last-range child)\n                  diff (- rng (if new-child (last-range new-child) 0))\n                  arr  (aclone (.-arr current-node))]\n              (aset new-rngs subidx (- (aget new-rngs subidx) diff))\n              (aset arr subidx new-child)\n              (aset arr 32 new-rngs)\n              (if (nil? new-child)\n                (aset new-rngs 32 (dec (aget new-rngs 32))))\n              (->VectorNode root-edit arr))))\n\n        (zero? subidx)\n        nil\n\n        :else\n        (let [arr      (aclone (.-arr current-node))\n              child    (aget arr subidx)\n              new-rngs (aclone rngs)]\n          (aset arr subidx nil)\n          (aset arr 32 new-rngs)\n          (aset new-rngs subidx 0)\n          (aset new-rngs 32 (dec (aget new-rngs 32)))\n          (->VectorNode root-edit arr))))))\n\n(defn do-assoc [shift current-node i val]\n  (if (regular? current-node)\n    (let [node (clone shift current-node)]\n      (loop [shift shift\n             node  node]\n        (if (zero? shift)\n          (let [arr (.-arr node)]\n            (aset arr (bit-and i 0x1f) val))\n          (let [arr    (.-arr node)\n                subidx (bit-and (bit-shift-right i shift) 0x1f)\n                child  (clone shift (aget arr subidx))]\n            (aset arr subidx child)\n            (recur (- shift 5) child))))\n      node)\n    (let [arr    (aclone (.-arr current-node))\n          rngs   (node-ranges current-node)\n          subidx (bit-and (bit-shift-right i shift) 0x1f)\n          subidx (loop [subidx subidx]\n                   (if (< i (int (aget rngs subidx)))\n                     subidx\n                     (recur (inc subidx))))\n          i      (if (zero? subidx) i (- i (aget rngs (dec subidx))))]\n      (aset arr subidx\n            (do-assoc (- shift 5) (aget arr subidx) i val))\n      (->VectorNode (.-edit current-node) arr))))\n"]}