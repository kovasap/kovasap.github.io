shadow$provide.module$node_modules$vega_transforms$build$vega_transforms=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){"object"===typeof exports$jscomp$0&&"undefined"!==typeof module?factory(exports$jscomp$0,require("module$node_modules$vega_util$build$vega_util"),require("module$node_modules$vega_dataflow$build$vega_dataflow"),require("module$node_modules$vega_statistics$build$vega_statistics"),require("module$node_modules$d3_array$dist$d3_array"),require("module$node_modules$vega_time$build$vega_time")):
"function"===typeof define&&define.amd?define("exports vega-util vega-dataflow vega-statistics d3-array vega-time".split(" "),factory):(global="undefined"!==typeof globalThis?globalThis:global||self,factory(global.vega={},global.vega,global.vega,global.vega,global.d3,global.vega))})(this,function(exports,vegaUtil,vegaDataflow,vegaStatistics,d3Array,vegaTime){function multikey(f){return x=>{const n=f.length;let i=1,k=String(f[0](x));for(;i<n;++i)k+="|"+f[i](x);return k}}function groupkey(fields){return fields&&
fields.length?1===fields.length?fields[0]:multikey(fields):function(){return""}}function measure(key,value){return out=>vegaUtil.extend({name:key,out:out||key},base_op,value)}function compareIndex(a,b){return a.idx-b.idx}function resolve(agg){const map={};agg.forEach(a=>map[a.name]=a);const getreqs=a=>{a.req&&a.req.forEach(key=>{map[key]||getreqs(map[key]=AggregateOps[key]())})};agg.forEach(getreqs);return Object.values(map).sort(compareIndex)}function init$jscomp$0(){this.missing=this.valid=0;this._ops.forEach(op=>
op.init(this))}function add$jscomp$0(v,t){null==v||""===v?++this.missing:v===v&&(++this.valid,this._ops.forEach(op=>op.add(this,v,t)))}function rem$jscomp$0(v,t){null==v||""===v?--this.missing:v===v&&(--this.valid,this._ops.forEach(op=>op.rem(this,v,t)))}function set$jscomp$0(t){this._out.forEach(op=>t[op.out]=op.value(this));return t}function compileMeasures(agg,field){function ctr(cell){this._ops=ops;this._out=out;this.cell=cell;this.init()}field=field||vegaUtil.identity;const ops=resolve(agg),
out=agg.slice().sort(compareIndex);ctr.prototype.init=init$jscomp$0;ctr.prototype.add=add$jscomp$0;ctr.prototype.rem=rem$jscomp$0;ctr.prototype.set=set$jscomp$0;ctr.prototype.get=field;ctr.fields=agg.map(op=>op.out);return ctr}function TupleStore(key){this._key=key?vegaUtil.field(key):vegaDataflow.tupleid;this.reset()}function Aggregate(params){vegaDataflow.Transform.call(this,null,params);this._adds=[];this._mods=[];this._mlen=this._alen=0;this._drop=!0;this._cross=!1;this._dims=[];this._dnames=
[];this._measures=[];this._countOnly=!1;this._outputs=this._inputs=this._prev=this._counts=null}function Bin(params){vegaDataflow.Transform.call(this,null,params)}function SortedList(idFunc,source,input){let data=source||[],add=input||[],rem={},cnt=0;return{add:t=>add.push(t),remove:t=>rem[idFunc(t)]=++cnt,size:()=>data.length,data:(compare,resort)=>{cnt&&(data=data.filter(t=>!rem[idFunc(t)]),rem={},cnt=0);resort&&compare&&data.sort(compare);add.length&&(data=compare?vegaUtil.merge(compare,data,add.sort(compare)):
data.concat(add),add=[]);return data}}}function Collect(params){vegaDataflow.Transform.call(this,[],params)}function Compare(params){vegaDataflow.Operator.call(this,null,update$5,params)}function update$5(_){return this.value&&!_.modified()?this.value:vegaUtil.compare(_.fields,_.orders)}function CountPattern(params){vegaDataflow.Transform.call(this,null,params)}function Cross(params){vegaDataflow.Transform.call(this,null,params)}function parse(def,data){var func=def["function"];vegaUtil.hasOwnProperty(Distributions,
func)||vegaUtil.error("Unknown distribution function: "+func);func=Distributions[func]();for(const name in def)if("field"===name)func.data((def.from||data()).map(def[name]));else if("distributions"===name)func[name](def[name].map(_=>parse(_,data)));else if("function"===typeof func[name])func[name](def[name]);return func}function Density(params){vegaDataflow.Transform.call(this,null,params)}function source$jscomp$0(pulse){return()=>pulse.materialize(pulse.SOURCE).source}function fieldNames(fields,
as){return fields?fields.map((f,i)=>as[i]||vegaUtil.accessorName(f)):null}function partition$1(data,groupby,field){const groups=[],get=f=>f(t);let map,i,n,t,k,g;if(null==groupby)groups.push(data.map(field));else for(map={},i=0,n=data.length;i<n;++i)t=data[i],k=groupby.map(get),g=map[k],g||(map[k]=g=[],g.dims=k,groups.push(g)),g.push(field(t));return groups}function DotBin(params){vegaDataflow.Transform.call(this,null,params)}function Expression(params){vegaDataflow.Operator.call(this,null,update$4,
params);this.modified(!0)}function update$4(_){const expr=_.expr;return this.value&&!_.modified("expr")?this.value:vegaUtil.accessor(datum=>expr(datum,_),vegaUtil.accessorFields(expr),vegaUtil.accessorName(expr))}function Extent(params){vegaDataflow.Transform.call(this,[void 0,void 0],params)}function Subflow(pulse,parent){vegaDataflow.Operator.call(this,pulse);this.parent=parent;this.count=0}function Facet(params){vegaDataflow.Transform.call(this,{},params);this._keys=vegaUtil.fastmap();const a=
this._targets=[];a.active=0;a.forEach=f=>{for(let i=0,n=a.active;i<n;++i)f(a[i],i,a)}}function Field(params){vegaDataflow.Operator.call(this,null,update$3,params)}function update$3(_){return this.value&&!_.modified()?this.value:vegaUtil.isArray(_.name)?vegaUtil.array(_.name).map(f=>vegaUtil.field(f)):vegaUtil.field(_.name,_.as)}function Filter(params){vegaDataflow.Transform.call(this,vegaUtil.fastmap(),params)}function Flatten(params){vegaDataflow.Transform.call(this,[],params)}function Fold(params){vegaDataflow.Transform.call(this,
[],params)}function Formula(params){vegaDataflow.Transform.call(this,null,params)}function Generate(params){vegaDataflow.Transform.call(this,[],params)}function Impute(params){vegaDataflow.Transform.call(this,[],params)}function getValue(_){var m=_.method||Methods.value;if(null==Methods[m])vegaUtil.error("Unrecognized imputation method: "+m);else{if(m===Methods.value){var v=void 0!==_.value?_.value:0;return()=>v}return Methods[m]}}function getField(_){const f=_.field;return t=>t?f(t):NaN}function partition(data,
groupby,key,keyvals){var get=f=>f(t),groups=[];keyvals=keyvals?keyvals.slice():[];var kMap={},gMap={},group,n;keyvals.forEach((k,i)=>kMap[k]=i+1);var i$jscomp$0=0;for(n=data.length;i$jscomp$0<n;++i$jscomp$0){var t=data[i$jscomp$0];var gVals=key(t);var j=kMap[gVals]||(kMap[gVals]=keyvals.push(gVals));var gKey=(gVals=groupby?groupby.map(get):Empty)+"";(group=gMap[gKey])||(group=gMap[gKey]=[],groups.push(group),group.values=gVals);group[j-1]=t}groups.domain=keyvals;return groups}function JoinAggregate(params){Aggregate.call(this,
params)}function KDE(params){vegaDataflow.Transform.call(this,null,params)}function Key(params){vegaDataflow.Operator.call(this,null,update$2,params)}function update$2(_){return this.value&&!_.modified()?this.value:vegaUtil.key(_.fields,_.flat)}function Load(params){vegaDataflow.Transform.call(this,[],params);this._pending=null}function stop$jscomp$0(_){return _.modified("async")&&!(_.modified("values")||_.modified("url")||_.modified("format"))}function output$jscomp$0(op,pulse,data){data.forEach(vegaDataflow.ingest);
pulse=pulse.fork(pulse.NO_FIELDS&pulse.NO_SOURCE);pulse.rem=op.value;op.value=pulse.source=pulse.add=data;op._pending=null;pulse.rem.length&&pulse.clean(!0);return pulse}function Lookup(params){vegaDataflow.Transform.call(this,{},params)}function MultiExtent(params){vegaDataflow.Operator.call(this,null,update$1,params)}function update$1(_){if(this.value&&!_.modified())return this.value;_=_.extents;const n=_.length;let min=Infinity,max=-Infinity,i,e;for(i=0;i<n;++i)e=_[i],e[0]<min&&(min=e[0]),e[1]>
max&&(max=e[1]);return[min,max]}function MultiValues(params){vegaDataflow.Operator.call(this,null,update$jscomp$0,params)}function update$jscomp$0(_$jscomp$0){return this.value&&!_$jscomp$0.modified()?this.value:_$jscomp$0.values.reduce((data,_)=>data.concat(_),[])}function Params(params){vegaDataflow.Transform.call(this,null,params)}function Pivot(params){Aggregate.call(this,params)}function aggregateParams(_,pulse){const key=_.field,value=_.value,op=("count"===_.op?"__count__":_.op)||"sum",fields=
vegaUtil.accessorFields(key).concat(vegaUtil.accessorFields(value)),keys=pivotKeys(key,_.limit||0,pulse);pulse.changed()&&_.set("__pivot__",null,null,!0);return{key:_.key,groupby:_.groupby,ops:keys.map(()=>op),fields:keys.map(k=>get$jscomp$0(k,key,value,fields)),as:keys.map(k=>k+""),modified:_.modified.bind(_)}}function get$jscomp$0(k,key,value,fields){return vegaUtil.accessor(d=>key(d)===k?value(d):NaN,fields,k+"")}function pivotKeys(key,limit,pulse){const map={},list=[];pulse.visit(pulse.SOURCE,
t=>{t=key(t);map[t]||(map[t]=1,list.push(t))});list.sort(vegaUtil.ascending);return limit?list.slice(0,limit):list}function PreFacet(params){Facet.call(this,params)}function Project(params){vegaDataflow.Transform.call(this,null,params)}function Proxy(params){vegaDataflow.Transform.call(this,null,params)}function Quantile(params){vegaDataflow.Transform.call(this,null,params)}function Relay(params){vegaDataflow.Transform.call(this,null,params)}function Sample(params){vegaDataflow.Transform.call(this,
[],params);this.count=0}function Sequence(params){vegaDataflow.Transform.call(this,null,params)}function Sieve(params){vegaDataflow.Transform.call(this,null,params);this.modified(!0)}function TimeUnit(params){vegaDataflow.Transform.call(this,null,params)}function TupleIndex(params){vegaDataflow.Transform.call(this,vegaUtil.fastmap(),params)}function Values(params){vegaDataflow.Transform.call(this,null,params)}function WindowOp(op,field,param,as){const fn=WindowOps[op](field,param);return{init:fn.init||
vegaUtil.zero,update:function(w,t){t[as]=fn.next(w)}}}function WindowState(_$jscomp$0){function visitInputs(f){vegaUtil.array(vegaUtil.accessorFields(f)).forEach(_=>inputs[_]=1)}const ops=vegaUtil.array(_$jscomp$0.ops),fields=vegaUtil.array(_$jscomp$0.fields),params=vegaUtil.array(_$jscomp$0.params),as=vegaUtil.array(_$jscomp$0.as),outputs=this.outputs=[],windows=this.windows=[],inputs={},map={},counts=[],measures=[];let countOnly=!0;visitInputs(_$jscomp$0.sort);ops.forEach((op,i)=>{const field=fields[i],
mname=vegaUtil.accessorName(field),name=as[i]||op+(mname?"_"+mname:"");visitInputs(field);outputs.push(name);vegaUtil.hasOwnProperty(WindowOps,op)?windows.push(WindowOp(op,fields[i],params[i],name)):(null==field&&"count"!==op&&vegaUtil.error("Null aggregate field specified."),"count"===op?counts.push(name):(countOnly=!1,i=map[mname],i||(i=map[mname]=[],i.field=field,measures.push(i)),i.push(AggregateOps[op](name))))});if(counts.length||measures.length)this.cell=cell(measures,counts,countOnly);this.inputs=
Object.keys(inputs)}function cell(measures,counts,countOnly){measures=measures.map(m=>compileMeasures(m,m.field));const cell={num:0,agg:null,store:!1,count:counts};if(!countOnly)for(var n$jscomp$0=measures.length,a=cell.agg=Array(n$jscomp$0),i$jscomp$0=0;i$jscomp$0<n$jscomp$0;++i$jscomp$0)a[i$jscomp$0]=new measures[i$jscomp$0](cell);if(cell.store)var store=cell.data=new TupleStore;cell.add=function(t){cell.num+=1;if(!countOnly){store&&store.add(t);for(let i=0;i<n$jscomp$0;++i)a[i].add(a[i].get(t),
t)}};cell.rem=function(t){--cell.num;if(!countOnly){store&&store.rem(t);for(let i=0;i<n$jscomp$0;++i)a[i].rem(a[i].get(t),t)}};cell.set=function(t){let i,n;store&&store.values();i=0;for(n=counts.length;i<n;++i)t[counts[i]]=cell.num;if(!countOnly)for(i=0,n=a.length;i<n;++i)a[i].set(t)};cell.init=function(){cell.num=0;store&&store.reset();for(let i=0;i<n$jscomp$0;++i)a[i].init()};return cell}function Window(params){vegaDataflow.Transform.call(this,{},params);this._mlen=0;this._mods=[]}function processPartition(list,
state,cmp,_){var sort=_.sort;const range=sort&&!_.ignorePeers;_=_.frame||[null,0];list=list.data(cmp);cmp=list.length;const b=range?d3Array.bisector(sort):null;sort={i0:0,i1:0,p0:0,p1:0,index:0,data:list,compare:sort||vegaUtil.constant(-1)};state.init();for(let i=0;i<cmp;++i){var w=sort,f=_,i$jscomp$0=i,n$jscomp$0=cmp;w.p0=w.i0;w.p1=w.i1;w.i0=null==f[0]?0:Math.max(0,i$jscomp$0-Math.abs(f[0]));w.i1=null==f[1]?n$jscomp$0:Math.min(n$jscomp$0,i$jscomp$0+Math.abs(f[1])+1);w.index=i$jscomp$0;if(range){w=
sort;f=b;i$jscomp$0=w.i0;n$jscomp$0=w.i1-1;const c=w.compare,d=w.data,n=d.length-1;0<i$jscomp$0&&!c(d[i$jscomp$0],d[i$jscomp$0-1])&&(w.i0=f.left(d,d[i$jscomp$0]));n$jscomp$0<n&&!c(d[n$jscomp$0],d[n$jscomp$0+1])&&(w.i1=f.right(d,d[n$jscomp$0]))}state.update(sort,list[i])}}var noop=()=>{};const base_op={init:noop,add:noop,rem:noop,idx:0},AggregateOps={values:{init:m=>m.cell.store=!0,value:m=>m.cell.data.values(),idx:-1},count:{value:m=>m.cell.num},__count__:{value:m=>m.missing+m.valid},missing:{value:m=>
m.missing},valid:{value:m=>m.valid},sum:{init:m=>m.sum=0,value:m=>m.sum,add:(m,v)=>m.sum+=+v,rem:(m,v)=>m.sum-=v},product:{init:m=>m.product=1,value:m=>m.valid?m.product:void 0,add:(m,v)=>m.product*=v,rem:(m,v)=>m.product/=v},mean:{init:m=>m.mean=0,value:m=>m.valid?m.mean:void 0,add:(m,v)=>(m.mean_d=v-m.mean,m.mean+=m.mean_d/m.valid),rem:(m,v)=>(m.mean_d=v-m.mean,m.mean-=m.valid?m.mean_d/m.valid:m.mean)},average:{value:m=>m.valid?m.mean:void 0,req:["mean"],idx:1},variance:{init:m=>m.dev=0,value:m=>
1<m.valid?m.dev/(m.valid-1):void 0,add:(m,v)=>m.dev+=m.mean_d*(v-m.mean),rem:(m,v)=>m.dev-=m.mean_d*(v-m.mean),req:["mean"],idx:1},variancep:{value:m=>1<m.valid?m.dev/m.valid:void 0,req:["variance"],idx:2},stdev:{value:m=>1<m.valid?Math.sqrt(m.dev/(m.valid-1)):void 0,req:["variance"],idx:2},stdevp:{value:m=>1<m.valid?Math.sqrt(m.dev/m.valid):void 0,req:["variance"],idx:2},stderr:{value:m=>1<m.valid?Math.sqrt(m.dev/(m.valid*(m.valid-1))):void 0,req:["variance"],idx:2},distinct:{value:m=>m.cell.data.distinct(m.get),
req:["values"],idx:3},ci0:{value:m=>m.cell.data.ci0(m.get),req:["values"],idx:3},ci1:{value:m=>m.cell.data.ci1(m.get),req:["values"],idx:3},median:{value:m=>m.cell.data.q2(m.get),req:["values"],idx:3},q1:{value:m=>m.cell.data.q1(m.get),req:["values"],idx:3},q3:{value:m=>m.cell.data.q3(m.get),req:["values"],idx:3},min:{init:m=>m.min=void 0,value:m=>m.min=Number.isNaN(m.min)?m.cell.data.min(m.get):m.min,add:(m,v)=>{if(v<m.min||void 0===m.min)m.min=v},rem:(m,v)=>{v<=m.min&&(m.min=NaN)},req:["values"],
idx:4},max:{init:m=>m.max=void 0,value:m=>m.max=Number.isNaN(m.max)?m.cell.data.max(m.get):m.max,add:(m,v)=>{if(v>m.max||void 0===m.max)m.max=v},rem:(m,v)=>{v>=m.max&&(m.max=NaN)},req:["values"],idx:4},argmin:{init:m=>m.argmin=void 0,value:m=>m.argmin||m.cell.data.argmin(m.get),add:(m,v,t)=>{v<m.min&&(m.argmin=t)},rem:(m,v)=>{v<=m.min&&(m.argmin=void 0)},req:["min","values"],idx:3},argmax:{init:m=>m.argmax=void 0,value:m=>m.argmax||m.cell.data.argmax(m.get),add:(m,v,t)=>{v>m.max&&(m.argmax=t)},rem:(m,
v)=>{v>=m.max&&(m.argmax=void 0)},req:["max","values"],idx:3}};noop=Object.keys(AggregateOps);noop.forEach(key=>{AggregateOps[key]=measure(key,AggregateOps[key])});var prototype$1=TupleStore.prototype;prototype$1.reset=function(){this._add=[];this._rem=[];this._q=this._get=this._ext=null};prototype$1.add=function(v){this._add.push(v)};prototype$1.rem=function(v){this._rem.push(v)};prototype$1.values=function(){this._get=null;if(0===this._rem.length)return this._add;const a=this._add;var r=this._rem;
const k=this._key,n=a.length,m=r.length,x=Array(n-m),map={};let i,v;for(i=0;i<m;++i)map[k(r[i])]=1;for(r=i=0;i<n;++i)map[k(v=a[i])]?map[k(v)]=0:x[r++]=v;this._rem=[];return this._add=x};prototype$1.distinct=function(get){const v=this.values(),map={};let n=v.length,count=0,s;for(;0<=--n;)s=get(v[n])+"",vegaUtil.hasOwnProperty(map,s)||(map[s]=1,++count);return count};prototype$1.extent=function(get){if(this._get!==get||!this._ext){const v=this.values(),i=vegaUtil.extentIndex(v,get);this._ext=[v[i[0]],
v[i[1]]];this._get=get}return this._ext};prototype$1.argmin=function(get){return this.extent(get)[0]||{}};prototype$1.argmax=function(get){return this.extent(get)[1]||{}};prototype$1.min=function(get){const m=this.extent(get)[0];return null!=m?get(m):void 0};prototype$1.max=function(get){const m=this.extent(get)[1];return null!=m?get(m):void 0};prototype$1.quartile=function(get){this._get===get&&this._q||(this._q=vegaStatistics.quartiles(this.values(),get),this._get=get);return this._q};prototype$1.q1=
function(get){return this.quartile(get)[0]};prototype$1.q2=function(get){return this.quartile(get)[1]};prototype$1.q3=function(get){return this.quartile(get)[2]};prototype$1.ci=function(get){this._get===get&&this._ci||(this._ci=vegaStatistics.bootstrapCI(this.values(),1E3,.05,get),this._get=get);return this._ci};prototype$1.ci0=function(get){return this.ci(get)[0]};prototype$1.ci1=function(get){return this.ci(get)[1]};Aggregate.Definition={type:"Aggregate",metadata:{generates:!0,changes:!0},params:[{name:"groupby",
type:"field",array:!0},{name:"ops",type:"enum",array:!0,values:noop},{name:"fields",type:"field","null":!0,array:!0},{name:"as",type:"string","null":!0,array:!0},{name:"drop",type:"boolean","default":!0},{name:"cross",type:"boolean","default":!1},{name:"key",type:"field"}]};vegaUtil.inherits(Aggregate,vegaDataflow.Transform,{transform(_,pulse){const aggr=this,out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS),mod=_.modified();aggr.stamp=out.stamp;aggr.value&&(mod||pulse.modified(aggr._inputs,!0))?(aggr._prev=
aggr.value,aggr.value=mod?aggr.init(_):{},pulse.visit(pulse.SOURCE,t=>aggr.add(t))):(aggr.value=aggr.value||aggr.init(_),pulse.visit(pulse.REM,t=>aggr.rem(t)),pulse.visit(pulse.ADD,t=>aggr.add(t)));out.modifies(aggr._outputs);aggr._drop=!1!==_.drop;_.cross&&1<aggr._dims.length&&(aggr._drop=!1,aggr.cross());pulse.clean()&&aggr._drop&&out.clean(!0).runAfter(()=>this.clean());return aggr.changes(out)},cross(){function collect(cells){let key,i,t,v;for(key in cells)for(t=cells[key].tuple,i=0;i<n;++i)vals[i][v=
t[dims[i]]]=v}function generate(base,tuple,index){const name=dims[index],v=vals[index++];for(const k in v){const key=base?base+"|"+k:k;tuple[name]=v[k];index<n?generate(key,tuple,index):curr[key]||aggr.cell(key,tuple)}}const aggr=this,curr=aggr.value,dims=aggr._dnames,vals=dims.map(()=>({})),n=dims.length;collect(aggr._prev);collect(curr);generate("",{},0)},init(_){function inputVisit(get){get=vegaUtil.array(vegaUtil.accessorFields(get));const n=get.length;let i=0,f;for(;i<n;++i)inputMap[f=get[i]]||
(inputMap[f]=1,inputs.push(f))}const inputs=this._inputs=[],outputs=this._outputs=[],inputMap={};this._dims=vegaUtil.array(_.groupby);this._dnames=this._dims.map(d=>{const dname=vegaUtil.accessorName(d);inputVisit(d);outputs.push(dname);return dname});this.cellkey=_.key?_.key:groupkey(this._dims);this._countOnly=!0;this._counts=[];this._measures=[];const fields=_.fields||[null],ops=_.ops||["count"];_=_.as||[];const n$jscomp$0=fields.length,map={};let field,op,m$jscomp$0,mname,outname,i$jscomp$0;n$jscomp$0!==
ops.length&&vegaUtil.error("Unmatched number of fields and aggregate ops.");for(i$jscomp$0=0;i$jscomp$0<n$jscomp$0;++i$jscomp$0)field=fields[i$jscomp$0],op=ops[i$jscomp$0],null==field&&"count"!==op&&vegaUtil.error("Null aggregate field specified."),mname=vegaUtil.accessorName(field),outname=_[i$jscomp$0]||op+(mname?"_"+mname:""),outputs.push(outname),"count"===op?this._counts.push(outname):(m$jscomp$0=map[mname],m$jscomp$0||(inputVisit(field),m$jscomp$0=map[mname]=[],m$jscomp$0.field=field,this._measures.push(m$jscomp$0)),
"count"!==op&&(this._countOnly=!1),m$jscomp$0.push(AggregateOps[op](outname)));this._measures=this._measures.map(m=>compileMeasures(m,m.field));return{}},cellkey:groupkey(),cell(key,t){let cell=this.value[key];cell?0===cell.num&&this._drop&&cell.stamp<this.stamp?(cell.stamp=this.stamp,this._adds[this._alen++]=cell):cell.stamp<this.stamp&&(cell.stamp=this.stamp,this._mods[this._mlen++]=cell):(cell=this.value[key]=this.newcell(key,t),this._adds[this._alen++]=cell);return cell},newcell(key,t){key={key,
num:0,agg:null,tuple:this.newtuple(t,this._prev&&this._prev[key]),stamp:this.stamp,store:!1};if(!this._countOnly){t=this._measures;const n=t.length;key.agg=Array(n);for(let i=0;i<n;++i)key.agg[i]=new t[i](key)}key.store&&(key.data=new TupleStore);return key},newtuple(t,p){const names=this._dnames,dims=this._dims,n=dims.length,x={};for(let i=0;i<n;++i)x[names[i]]=dims[i](t);return p?vegaDataflow.replace(p.tuple,x):vegaDataflow.ingest(x)},clean(){const cells=this.value;for(const key in cells)0===cells[key].num&&
delete cells[key]},add(t){var key=this.cellkey(t);key=this.cell(key,t);key.num+=1;if(!this._countOnly){key.store&&key.data.add(t);key=key.agg;for(let i=0,n=key.length;i<n;++i)key[i].add(key[i].get(t),t)}},rem(t){var key=this.cellkey(t);key=this.cell(key,t);--key.num;if(!this._countOnly){key.store&&key.data.rem(t);key=key.agg;for(let i=0,n=key.length;i<n;++i)key[i].rem(key[i].get(t),t)}},celltuple(cell){const tuple=cell.tuple,counts=this._counts;cell.store&&cell.data.values();for(let i=0,n=counts.length;i<
n;++i)tuple[counts[i]]=cell.num;if(!this._countOnly){cell=cell.agg;for(let i=0,n=cell.length;i<n;++i)cell[i].set(tuple)}return tuple},changes(out){const adds=this._adds,mods=this._mods;var prev=this._prev;const drop=this._drop,add=out.add,rem=out.rem,mod=out.mod;let cell;var key;if(prev)for(key in prev)cell=prev[key],drop&&!cell.num||rem.push(cell.tuple);prev=0;for(key=this._alen;prev<key;++prev)add.push(this.celltuple(adds[prev])),adds[prev]=null;prev=0;for(key=this._mlen;prev<key;++prev)cell=mods[prev],
(0===cell.num&&drop?rem:mod).push(this.celltuple(cell)),mods[prev]=null;this._alen=this._mlen=0;this._prev=null;return out}});Bin.Definition={type:"Bin",metadata:{modifies:!0},params:[{name:"field",type:"field",required:!0},{name:"interval",type:"boolean","default":!0},{name:"anchor",type:"number"},{name:"maxbins",type:"number","default":20},{name:"base",type:"number","default":10},{name:"divide",type:"number",array:!0,"default":[5,2]},{name:"extent",type:"number",array:!0,length:2,required:!0},{name:"span",
type:"number"},{name:"step",type:"number"},{name:"steps",type:"number",array:!0},{name:"minstep",type:"number","default":0},{name:"nice",type:"boolean","default":!0},{name:"name",type:"string"},{name:"as",type:"string",array:!0,length:2,"default":["bin0","bin1"]}]};vegaUtil.inherits(Bin,vegaDataflow.Transform,{transform(_,pulse){const band=!1!==_.interval,bins=this._bins(_),start=bins.start,step=bins.step,as=_.as||["bin0","bin1"],b0=as[0],b1=as[1];_.modified()?(pulse=pulse.reflow(!0),_=pulse.SOURCE):
_=pulse.modified(vegaUtil.accessorFields(_.field))?pulse.ADD_MOD:pulse.ADD;pulse.visit(_,band?t=>{const v=bins(t);t[b0]=v;t[b1]=null==v?null:start+step*(1+(v-start)/step)}:t=>t[b0]=bins(t));return pulse.modifies(band?as:b0)},_bins(_){if(this.value&&!_.modified())return this.value;const field=_.field,bins=vegaStatistics.bin(_),step=bins.step;let start=bins.start,stop=start+Math.ceil((bins.stop-start)/step)*step;var a;null!=(a=_.anchor)&&(a-=start+step*Math.floor((a-start)/step),start+=a,stop+=a);a=
function(t){t=vegaUtil.toNumber(field(t));return null==t?null:t<start?-Infinity:t>stop?Infinity:(t=Math.max(start,Math.min(t,stop-step)),start+step*Math.floor(1E-14+(t-start)/step))};a.start=start;a.stop=bins.stop;a.step=step;return this.value=vegaUtil.accessor(a,vegaUtil.accessorFields(field),_.name||"bin_"+vegaUtil.accessorName(field))}});Collect.Definition={type:"Collect",metadata:{source:!0},params:[{name:"sort",type:"compare"}]};vegaUtil.inherits(Collect,vegaDataflow.Transform,{transform(_,pulse){const out=
pulse.fork(pulse.ALL),list=SortedList(vegaDataflow.tupleid,this.value,out.materialize(out.ADD).add),sort=_.sort;_=pulse.changed()||sort&&(_.modified("sort")||pulse.modified(sort.fields));out.visit(out.REM,list.remove);this.modified(_);this.value=out.source=list.data(vegaDataflow.stableCompare(sort),_);pulse.source&&pulse.source.root&&(this.value.root=pulse.source.root);return out}});vegaUtil.inherits(Compare,vegaDataflow.Operator);CountPattern.Definition={type:"CountPattern",metadata:{generates:!0,
changes:!0},params:[{name:"field",type:"field",required:!0},{name:"case",type:"enum",values:["upper","lower","mixed"],"default":"mixed"},{name:"pattern",type:"string","default":'[\\w"]+'},{name:"stopwords",type:"string","default":""},{name:"as",type:"string",array:!0,length:2,"default":["text","count"]}]};vegaUtil.inherits(CountPattern,vegaDataflow.Transform,{transform(_,pulse){var process=update=>tuple=>{tuple=get(tuple);var match=match$jscomp$0;switch(_.case){case "upper":tuple=tuple.toUpperCase();
break;case "lower":tuple=tuple.toLowerCase()}tuple=tuple.match(match)||[];var t;match=0;for(var n=tuple.length;match<n;++match)stop.test(t=tuple[match])||update(t)};const init=this._parameterCheck(_,pulse),counts=this._counts,match$jscomp$0=this._match,stop=this._stop,get=_.field,as=_.as||["text","count"],add=process(t=>counts[t]=1+(counts[t]||0));process=process(t=>--counts[t]);init?pulse.visit(pulse.SOURCE,add):(pulse.visit(pulse.ADD,add),pulse.visit(pulse.REM,process));return this._finish(pulse,
as)},_parameterCheck(_,pulse){let init=!1;if(_.modified("stopwords")||!this._stop)this._stop=new RegExp("^"+(_.stopwords||"")+"$","i"),init=!0;if(_.modified("pattern")||!this._match)this._match=new RegExp(_.pattern||"[\\w']+","g"),init=!0;if(_.modified("field")||pulse.modified(_.field.fields))init=!0;init&&(this._counts={});return init},_finish(pulse,as){const counts=this._counts,tuples=this._tuples||(this._tuples={}),text=as[0],count=as[1];pulse=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS);let w,
t,c;for(w in counts)t=tuples[w],c=counts[w]||0,!t&&c?(tuples[w]=t=vegaDataflow.ingest({}),t[text]=w,t[count]=c,pulse.add.push(t)):0===c?(t&&pulse.rem.push(t),counts[w]=null,tuples[w]=null):t[count]!==c&&(t[count]=c,pulse.mod.push(t));return pulse.modifies(as)}});Cross.Definition={type:"Cross",metadata:{generates:!0},params:[{name:"filter",type:"expr"},{name:"as",type:"string",array:!0,length:2,"default":["a","b"]}]};vegaUtil.inherits(Cross,vegaDataflow.Transform,{transform(_,pulse){const out=pulse.fork(pulse.NO_SOURCE),
as=_.as||["a","b"],a=as[0],b=as[1];var reset=!this.value||pulse.changed(pulse.ADD_REM)||_.modified("as")||_.modified("filter"),data=this.value;if(reset){data&&(out.rem=data);pulse=data=pulse.materialize(pulse.SOURCE).source;_=_.filter||vegaUtil.truthy;reset=[];data={};for(var n=pulse.length,i=0,j,left;i<n;++i)for(data[a]=left=pulse[i],j=0;j<n;++j)data[b]=pulse[j],_(data)&&(reset.push(vegaDataflow.ingest(data)),data={},data[a]=left);out.add=this.value=reset}else out.mod=data;out.source=this.value;
return out.modifies(as)}});const Distributions={kde:vegaStatistics.randomKDE,mixture:vegaStatistics.randomMixture,normal:vegaStatistics.randomNormal,lognormal:vegaStatistics.randomLogNormal,uniform:vegaStatistics.randomUniform};prototype$1=[{key:{"function":"normal"},params:[{name:"mean",type:"number","default":0},{name:"stdev",type:"number","default":1}]},{key:{"function":"lognormal"},params:[{name:"mean",type:"number","default":0},{name:"stdev",type:"number","default":1}]},{key:{"function":"uniform"},
params:[{name:"min",type:"number","default":0},{name:"max",type:"number","default":1}]},{key:{"function":"kde"},params:[{name:"field",type:"field",required:!0},{name:"from",type:"data"},{name:"bandwidth",type:"number","default":0}]}];Density.Definition={type:"Density",metadata:{generates:!0},params:[{name:"extent",type:"number",array:!0,length:2},{name:"steps",type:"number"},{name:"minsteps",type:"number","default":25},{name:"maxsteps",type:"number","default":200},{name:"method",type:"string","default":"pdf",
values:["pdf","cdf"]},{name:"distribution",type:"param",params:prototype$1.concat({key:{"function":"mixture"},params:[{name:"distributions",type:"param",array:!0,params:prototype$1},{name:"weights",type:"number",array:!0}]})},{name:"as",type:"string",array:!0,"default":["value","density"]}]};vegaUtil.inherits(Density,vegaDataflow.Transform,{transform(_,pulse){const out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS);if(!this.value||pulse.changed()||_.modified()){const dist=parse(_.distribution,source$jscomp$0(pulse));
pulse=_.steps||_.minsteps||25;const maxsteps=_.steps||_.maxsteps||200;let method=_.method||"pdf";"pdf"!==method&&"cdf"!==method&&vegaUtil.error("Invalid density method: "+method);_.extent||dist.data||vegaUtil.error("Missing density extent parameter.");method=dist[method];const as=_.as||["value","density"];_=_.extent||vegaUtil.extent(dist.data());_=vegaStatistics.sampleCurve(method,_,pulse,maxsteps).map(v=>{const tuple={};tuple[as[0]]=v[0];tuple[as[1]]=v[1];return vegaDataflow.ingest(tuple)});this.value&&
(out.rem=this.value);this.value=out.add=out.source=_}return out}});DotBin.Definition={type:"DotBin",metadata:{modifies:!0},params:[{name:"field",type:"field",required:!0},{name:"groupby",type:"field",array:!0},{name:"step",type:"number"},{name:"smooth",type:"boolean","default":!1},{name:"as",type:"string","default":"bin"}]};vegaUtil.inherits(DotBin,vegaDataflow.Transform,{transform(_,pulse){if(this.value&&!_.modified()&&!pulse.changed())return pulse;var source=pulse.materialize(pulse.SOURCE).source;
const groups=partition$1(pulse.source,_.groupby,vegaUtil.identity),smooth=_.smooth||!1,field=_.field;source=_.step||vegaUtil.span(vegaUtil.extent(source,field))/30;const sort=vegaDataflow.stableCompare((a,b)=>field(a)-field(b));_=_.as||"bin";const n=groups.length;let min=Infinity,max=-Infinity,i=0,j;for(;i<n;++i){const g=groups[i].sort(sort);j=-1;for(const v of vegaStatistics.dotbin(g,source,smooth,field))v<min&&(min=v),v>max&&(max=v),g[++j][_]=v}this.value={start:min,stop:max,step:source};return pulse.reflow(!0).modifies(_)}});
vegaUtil.inherits(Expression,vegaDataflow.Operator);Extent.Definition={type:"Extent",metadata:{},params:[{name:"field",type:"field",required:!0}]};vegaUtil.inherits(Extent,vegaDataflow.Transform,{transform(_,pulse){var extent=this.value;const field=_.field;_=pulse.changed()||pulse.modified(field.fields)||_.modified("field");let min=extent[0],max=extent[1];if(_||null==min)min=Infinity,max=-Infinity;pulse.visit(_?pulse.SOURCE:pulse.ADD,t=>{t=vegaUtil.toNumber(field(t));null!=t&&(t<min&&(min=t),t>max&&
(max=t))});Number.isFinite(min)&&Number.isFinite(max)||((extent=vegaUtil.accessorName(field))&&(extent=` for field "${extent}"`),pulse.dataflow.warn(`Infinite extent${extent}: [${min}, ${max}]`),min=max=void 0);this.value=[min,max]}});vegaUtil.inherits(Subflow,vegaDataflow.Operator,{connect(target){this.detachSubflow=target.detachSubflow;this.targets().add(target);return target.source=this},add(t){this.count+=1;this.value.add.push(t)},rem(t){--this.count;this.value.rem.push(t)},mod(t){this.value.mod.push(t)},
init(pulse){this.value.init(pulse,pulse.NO_SOURCE)},evaluate(){return this.value}});vegaUtil.inherits(Facet,vegaDataflow.Transform,{activate(flow){this._targets[this._targets.active++]=flow},subflow(key,flow,pulse,parent){const flows=this.value;let sf=vegaUtil.hasOwnProperty(flows,key)&&flows[key],p;sf?sf.value.stamp<pulse.stamp&&(sf.init(pulse),this.activate(sf)):(p=parent||(p=this._group[key])&&p.tuple,parent=pulse.dataflow,sf=new Subflow(pulse.fork(pulse.NO_SOURCE),this),parent.add(sf).connect(flow(parent,
key,p)),flows[key]=sf,this.activate(sf));return sf},clean(){var flows=this.value;let detached=0;for(const key in flows)if(0===flows[key].count){const detach=flows[key].detachSubflow;detach&&detach();delete flows[key];++detached}detached&&(flows=this._targets.filter(sf=>sf&&0<sf.count),this.initTargets(flows))},initTargets(act){const a=this._targets,n=a.length,m=act?act.length:0;let i=0;for(;i<m;++i)a[i]=act[i];for(;i<n&&null!=a[i];++i)a[i]=null;a.active=m},transform(_,pulse){const df=pulse.dataflow,
key$jscomp$0=_.key,flow=_.subflow,cache=this._keys,rekey=_.modified("key"),subflow=key=>this.subflow(key,flow,pulse);this._group=_.group||{};this.initTargets();pulse.visit(pulse.REM,t=>{const id=vegaDataflow.tupleid(t),k=cache.get(id);void 0!==k&&(cache.delete(id),subflow(k).rem(t))});pulse.visit(pulse.ADD,t=>{const k=key$jscomp$0(t);cache.set(vegaDataflow.tupleid(t),k);subflow(k).add(t)});rekey||pulse.modified(key$jscomp$0.fields)?pulse.visit(pulse.MOD,t=>{const id=vegaDataflow.tupleid(t),k0=cache.get(id),
k1=key$jscomp$0(t);k0===k1?subflow(k1).mod(t):(cache.set(id,k1),subflow(k0).rem(t),subflow(k1).add(t))}):pulse.changed(pulse.MOD)&&pulse.visit(pulse.MOD,t=>{subflow(cache.get(vegaDataflow.tupleid(t))).mod(t)});rekey&&pulse.visit(pulse.REFLOW,t=>{const id=vegaDataflow.tupleid(t),k0=cache.get(id),k1=key$jscomp$0(t);k0!==k1&&(cache.set(id,k1),subflow(k0).rem(t),subflow(k1).add(t))});pulse.clean()?df.runAfter(()=>{this.clean();cache.clean()}):cache.empty>df.cleanThreshold&&df.runAfter(cache.clean);return pulse}});
vegaUtil.inherits(Field,vegaDataflow.Operator);Filter.Definition={type:"Filter",metadata:{changes:!0},params:[{name:"expr",type:"expr",required:!0}]};vegaUtil.inherits(Filter,vegaDataflow.Transform,{transform(_,pulse){function revisit(t){const id=vegaDataflow.tupleid(t),b=test(t,_),s=cache.get(id);b&&s?(cache.delete(id),add.push(t)):b||s?isMod&&b&&!s&&mod.push(t):(cache.set(id,1),rem.push(t))}const df=pulse.dataflow,cache=this.value,output=pulse.fork(),add=output.add,rem=output.rem,mod=output.mod,
test=_.expr;let isMod=!0;pulse.visit(pulse.REM,t=>{const id=vegaDataflow.tupleid(t);cache.has(id)?cache.delete(id):rem.push(t)});pulse.visit(pulse.ADD,t=>{test(t,_)?add.push(t):cache.set(vegaDataflow.tupleid(t),1)});pulse.visit(pulse.MOD,revisit);_.modified()&&(isMod=!1,pulse.visit(pulse.REFLOW,revisit));cache.empty>df.cleanThreshold&&df.runAfter(cache.clean);return output}});Flatten.Definition={type:"Flatten",metadata:{generates:!0},params:[{name:"fields",type:"field",array:!0,required:!0},{name:"index",
type:"string"},{name:"as",type:"string",array:!0}]};vegaUtil.inherits(Flatten,vegaDataflow.Transform,{transform(_,pulse){const out=pulse.fork(pulse.NO_SOURCE),fields=_.fields,as=fieldNames(fields,_.as||[]),index=_.index||null,m=as.length;out.rem=this.value;pulse.visit(pulse.SOURCE,t=>{const arrays=fields.map(f=>f(t)),maxlen=arrays.reduce((l,a)=>Math.max(l,a.length),0);let i=0,j,d,v;for(;i<maxlen;++i){d=vegaDataflow.derive(t);for(j=0;j<m;++j)d[as[j]]=null==(v=arrays[j][i])?null:v;index&&(d[index]=
i);out.add.push(d)}});this.value=out.source=out.add;index&&out.modifies(index);return out.modifies(as)}});Fold.Definition={type:"Fold",metadata:{generates:!0},params:[{name:"fields",type:"field",array:!0,required:!0},{name:"as",type:"string",array:!0,length:2,"default":["key","value"]}]};vegaUtil.inherits(Fold,vegaDataflow.Transform,{transform(_,pulse){const out=pulse.fork(pulse.NO_SOURCE),fields=_.fields,fnames=fields.map(vegaUtil.accessorName);_=_.as||["key","value"];const k=_[0],v=_[1],n=fields.length;
out.rem=this.value;pulse.visit(pulse.SOURCE,t=>{for(let i=0,d;i<n;++i)d=vegaDataflow.derive(t),d[k]=fnames[i],d[v]=fields[i](t),out.add.push(d)});this.value=out.source=out.add;return out.modifies(_)}});Formula.Definition={type:"Formula",metadata:{modifies:!0},params:[{name:"expr",type:"expr",required:!0},{name:"as",type:"string",required:!0},{name:"initonly",type:"boolean"}]};vegaUtil.inherits(Formula,vegaDataflow.Transform,{transform(_,pulse){const func=_.expr,as=_.as,mod=_.modified(),flag=_.initonly?
pulse.ADD:mod?pulse.SOURCE:pulse.modified(func.fields)||pulse.modified(as)?pulse.ADD_MOD:pulse.ADD;mod&&(pulse=pulse.materialize().reflow(!0));_.initonly||pulse.modifies(as);return pulse.visit(flag,t=>t[as]=func(t,_))}});vegaUtil.inherits(Generate,vegaDataflow.Transform,{transform(_,pulse){pulse=pulse.fork(pulse.ALL);const gen=_.generator;let data=this.value,num=_.size-data.length,add,t;if(0<num){for(add=[];0<=--num;)add.push(t=vegaDataflow.ingest(gen(_))),data.push(t);pulse.add=pulse.add.length?
pulse.materialize(pulse.ADD).add.concat(add):add}else _=data.slice(0,-num),pulse.rem=pulse.rem.length?pulse.materialize(pulse.REM).rem.concat(_):_,data=data.slice(-num);pulse.source=this.value=data;return pulse}});const Methods={value:"value",median:d3Array.median,mean:d3Array.mean,min:d3Array.min,max:d3Array.max},Empty=[];Impute.Definition={type:"Impute",metadata:{changes:!0},params:[{name:"field",type:"field",required:!0},{name:"key",type:"field",required:!0},{name:"keyvals",array:!0},{name:"groupby",
type:"field",array:!0},{name:"method",type:"enum","default":"value",values:["value","mean","median","max","min"]},{name:"value","default":0}]};vegaUtil.inherits(Impute,vegaDataflow.Transform,{transform(_,pulse){var out=pulse.fork(pulse.ALL),impute=getValue(_),field=getField(_),fName=vegaUtil.accessorName(_.field),kName=vegaUtil.accessorName(_.key),gNames=(_.groupby||[]).map(vegaUtil.accessorName);_=partition(pulse.source,_.groupby,_.key,_.keyvals);pulse=[];var prev=this.value,m=_.domain.length,j,
l,n;var g=0;for(l=_.length;g<l;++g){var group=_[g];var gVals=group.values;var value=NaN;for(j=0;j<m;++j)if(null==group[j]){var kVal=_.domain[j];var t={_impute:!0};var i=0;for(n=gVals.length;i<n;++i)t[gNames[i]]=gVals[i];t[kName]=kVal;t[fName]=Number.isNaN(value)?value=impute(group,field):value;pulse.push(vegaDataflow.ingest(t))}}pulse.length&&(out.add=out.materialize(out.ADD).add.concat(pulse));prev.length&&(out.rem=out.materialize(out.REM).rem.concat(prev));this.value=pulse;return out}});JoinAggregate.Definition=
{type:"JoinAggregate",metadata:{modifies:!0},params:[{name:"groupby",type:"field",array:!0},{name:"fields",type:"field","null":!0,array:!0},{name:"ops",type:"enum",array:!0,values:noop},{name:"as",type:"string","null":!0,array:!0},{name:"key",type:"field"}]};vegaUtil.inherits(JoinAggregate,Aggregate,{transform(_,pulse){const aggr=this,mod=_.modified();let cells;aggr.value&&(mod||pulse.modified(aggr._inputs,!0))?(cells=aggr.value=mod?aggr.init(_):{},pulse.visit(pulse.SOURCE,t=>aggr.add(t))):(cells=
aggr.value=aggr.value||this.init(_),pulse.visit(pulse.REM,t=>aggr.rem(t)),pulse.visit(pulse.ADD,t=>aggr.add(t)));aggr.changes();pulse.visit(pulse.SOURCE,t=>{vegaUtil.extend(t,cells[aggr.cellkey(t)].tuple)});return pulse.reflow(mod).modifies(this._outputs)},changes(){const adds=this._adds,mods=this._mods;let i,n;i=0;for(n=this._alen;i<n;++i)this.celltuple(adds[i]),adds[i]=null;i=0;for(n=this._mlen;i<n;++i)this.celltuple(mods[i]),mods[i]=null;this._alen=this._mlen=0}});KDE.Definition={type:"KDE",metadata:{generates:!0},
params:[{name:"groupby",type:"field",array:!0},{name:"field",type:"field",required:!0},{name:"cumulative",type:"boolean","default":!1},{name:"counts",type:"boolean","default":!1},{name:"bandwidth",type:"number","default":0},{name:"extent",type:"number",array:!0,length:2},{name:"resolve",type:"enum",values:["shared","independent"],"default":"independent"},{name:"steps",type:"number"},{name:"minsteps",type:"number","default":25},{name:"maxsteps",type:"number","default":200},{name:"as",type:"string",
array:!0,"default":["value","density"]}]};vegaUtil.inherits(KDE,vegaDataflow.Transform,{transform(_,pulse){const out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS);if(!this.value||pulse.changed()||_.modified()){pulse=pulse.materialize(pulse.SOURCE).source;const groups=partition$1(pulse,_.groupby,_.field),names=(_.groupby||[]).map(vegaUtil.accessorName),bandwidth=_.bandwidth,method=_.cumulative?"cdf":"pdf",as=_.as||["value","density"],values=[];let domain=_.extent,minsteps=_.steps||_.minsteps||25,maxsteps=
_.steps||_.maxsteps||200;"pdf"!==method&&"cdf"!==method&&vegaUtil.error("Invalid density method: "+method);"shared"===_.resolve&&(domain||(domain=vegaUtil.extent(pulse,_.field)),minsteps=maxsteps=_.steps||maxsteps);groups.forEach(g=>{const density=vegaStatistics.randomKDE(g,bandwidth)[method],scale=_.counts?g.length:1,local=domain||vegaUtil.extent(g);vegaStatistics.sampleCurve(density,local,minsteps,maxsteps).forEach(v=>{const t={};for(let i=0;i<names.length;++i)t[names[i]]=g.dims[i];t[as[0]]=v[0];
t[as[1]]=v[1]*scale;values.push(vegaDataflow.ingest(t))})});this.value&&(out.rem=this.value);this.value=out.add=out.source=values}return out}});vegaUtil.inherits(Key,vegaDataflow.Operator);vegaUtil.inherits(Load,vegaDataflow.Transform,{transform(_,pulse){const df$jscomp$0=pulse.dataflow;return this._pending?output$jscomp$0(this,pulse,this._pending):stop$jscomp$0(_)?pulse.StopPropagation:_.values?output$jscomp$0(this,pulse,df$jscomp$0.parse(_.values,_.format)):_.async?{async:df$jscomp$0.request(_.url,
_.format).then(res=>{this._pending=vegaUtil.array(res.data);return df=>df.touch(this)})}:df$jscomp$0.request(_.url,_.format).then(res=>output$jscomp$0(this,pulse,vegaUtil.array(res.data)))}});Lookup.Definition={type:"Lookup",metadata:{modifies:!0},params:[{name:"index",type:"index",params:[{name:"from",type:"data",required:!0},{name:"key",type:"field",required:!0}]},{name:"values",type:"field",array:!0},{name:"fields",type:"field",array:!0,required:!0},{name:"as",type:"string",array:!0},{name:"default",
"default":null}]};vegaUtil.inherits(Lookup,vegaDataflow.Transform,{transform(_,pulse){const keys=_.fields,index=_.index,values=_.values,defaultValue=null==_.default?null:_.default;var reset=_.modified();const n=keys.length;let flag=reset?pulse.SOURCE:pulse.ADD,out=pulse,as=_.as,m;values?(m=values.length,1<n&&!as&&vegaUtil.error('Multi-field lookup requires explicit "as" parameter.'),as&&as.length!==n*m&&vegaUtil.error('The "as" parameter has too few output field names.'),as=as||values.map(vegaUtil.accessorName),
_=function(t){for(var i=0,k=0,j,v;i<n;++i)if(v=index.get(keys[i](t)),null==v)for(j=0;j<m;++j,++k)t[as[k]]=defaultValue;else for(j=0;j<m;++j,++k)t[as[k]]=values[j](v)}):(as||vegaUtil.error("Missing output field names."),_=function(t){for(var i=0,v;i<n;++i)v=index.get(keys[i](t)),t[as[i]]=null==v?defaultValue:v});reset?out=pulse.reflow(!0):(reset=keys.some(k=>pulse.modified(k.fields)),flag|=reset?pulse.MOD:0);pulse.visit(flag,_);return out.modifies(as)}});vegaUtil.inherits(MultiExtent,vegaDataflow.Operator);
vegaUtil.inherits(MultiValues,vegaDataflow.Operator);vegaUtil.inherits(Params,vegaDataflow.Transform,{transform(_,pulse){this.modified(_.modified());this.value=_;return pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS)}});Pivot.Definition={type:"Pivot",metadata:{generates:!0,changes:!0},params:[{name:"groupby",type:"field",array:!0},{name:"field",type:"field",required:!0},{name:"value",type:"field",required:!0},{name:"op",type:"enum",values:noop,"default":"sum"},{name:"limit",type:"number","default":0},
{name:"key",type:"field"}]};vegaUtil.inherits(Pivot,Aggregate,{_transform:Aggregate.prototype.transform,transform(_,pulse){return this._transform(aggregateParams(_,pulse),pulse)}});vegaUtil.inherits(PreFacet,Facet,{transform(_$jscomp$0,pulse){const flow=_$jscomp$0.subflow,field=_$jscomp$0.field,subflow=t=>this.subflow(vegaDataflow.tupleid(t),flow,pulse,t);(_$jscomp$0.modified("field")||field&&pulse.modified(vegaUtil.accessorFields(field)))&&vegaUtil.error("PreFacet does not support field modification.");
this.initTargets();field?(pulse.visit(pulse.MOD,t=>{const sf=subflow(t);field(t).forEach(_=>sf.mod(_))}),pulse.visit(pulse.ADD,t=>{const sf=subflow(t);field(t).forEach(_=>sf.add(vegaDataflow.ingest(_)))}),pulse.visit(pulse.REM,t=>{const sf=subflow(t);field(t).forEach(_=>sf.rem(_))})):(pulse.visit(pulse.MOD,t=>subflow(t).mod(t)),pulse.visit(pulse.ADD,t=>subflow(t).add(t)),pulse.visit(pulse.REM,t=>subflow(t).rem(t)));pulse.clean()&&pulse.runAfter(()=>this.clean());return pulse}});Project.Definition=
{type:"Project",metadata:{generates:!0,changes:!0},params:[{name:"fields",type:"field",array:!0},{name:"as",type:"string","null":!0,array:!0}]};vegaUtil.inherits(Project,vegaDataflow.Transform,{transform(_,pulse){const out=pulse.fork(pulse.NO_SOURCE),fields=_.fields,as=fieldNames(_.fields,_.as||[]),derive=fields?(s,t)=>{for(let i=0,n=fields.length;i<n;++i)t[as[i]]=fields[i](s);return t}:vegaDataflow.rederive;let lut;this.value?lut=this.value:(pulse=pulse.addAll(),lut=this.value={});pulse.visit(pulse.REM,
t=>{t=vegaDataflow.tupleid(t);out.rem.push(lut[t]);lut[t]=null});pulse.visit(pulse.ADD,t=>{const dt=derive(t,vegaDataflow.ingest({}));lut[vegaDataflow.tupleid(t)]=dt;out.add.push(dt)});pulse.visit(pulse.MOD,t=>{out.mod.push(derive(t,lut[vegaDataflow.tupleid(t)]))});return out}});vegaUtil.inherits(Proxy,vegaDataflow.Transform,{transform(_,pulse){this.value=_.value;return _.modified("value")?pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS):pulse.StopPropagation}});Quantile.Definition={type:"Quantile",metadata:{generates:!0,
changes:!0},params:[{name:"groupby",type:"field",array:!0},{name:"field",type:"field",required:!0},{name:"probs",type:"number",array:!0},{name:"step",type:"number","default":.01},{name:"as",type:"string",array:!0,"default":["prob","value"]}]};vegaUtil.inherits(Quantile,vegaDataflow.Transform,{transform(_,pulse){const out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS),as=_.as||["prob","value"];if(this.value&&!_.modified()&&!pulse.changed())return out.source=this.value,out;pulse=pulse.materialize(pulse.SOURCE).source;
pulse=partition$1(pulse,_.groupby,_.field);const names=(_.groupby||[]).map(vegaUtil.accessorName),values=[],step=_.step||.01,p=_.probs||d3Array.range(step/2,1-1E-14,step),n=p.length;pulse.forEach(g=>{const q=vegaStatistics.quantiles(g,p);for(let i$jscomp$0=0;i$jscomp$0<n;++i$jscomp$0){const t={};for(let i=0;i<names.length;++i)t[names[i]]=g.dims[i];t[as[0]]=p[i$jscomp$0];t[as[1]]=q[i$jscomp$0];values.push(vegaDataflow.ingest(t))}});this.value&&(out.rem=this.value);this.value=out.add=out.source=values;
return out}});vegaUtil.inherits(Relay,vegaDataflow.Transform,{transform(_,pulse){let out,lut;this.value?lut=this.value:(out=pulse=pulse.addAll(),lut=this.value={});_.derive&&(out=pulse.fork(pulse.NO_SOURCE),pulse.visit(pulse.REM,t=>{t=vegaDataflow.tupleid(t);out.rem.push(lut[t]);lut[t]=null}),pulse.visit(pulse.ADD,t=>{const dt=vegaDataflow.derive(t);lut[vegaDataflow.tupleid(t)]=dt;out.add.push(dt)}),pulse.visit(pulse.MOD,t=>{const dt=lut[vegaDataflow.tupleid(t)];for(const k in t)dt[k]=t[k],out.modifies(k);
out.mod.push(dt)}));return out}});Sample.Definition={type:"Sample",metadata:{},params:[{name:"size",type:"number","default":1E3}]};vegaUtil.inherits(Sample,vegaDataflow.Transform,{transform(_,pulse){function update(t){let p,idx;res.length<num?res.push(t):(idx=~~((cnt+1)*vegaStatistics.random()),idx<res.length&&idx>=cap&&(p=res[idx],map[vegaDataflow.tupleid(p)]&&out.rem.push(p),res[idx]=t));++cnt}const out=pulse.fork(pulse.NO_SOURCE);var mod=_.modified("size");const num=_.size,map=this.value.reduce((m,
t)=>(m[vegaDataflow.tupleid(t)]=1,m),{});let res=this.value,cnt=this.count,cap=0;pulse.rem.length&&(pulse.visit(pulse.REM,t=>{const id=vegaDataflow.tupleid(t);map[id]&&(map[id]=-1,out.rem.push(t));--cnt}),res=res.filter(t=>-1!==map[vegaDataflow.tupleid(t)]));(pulse.rem.length||mod)&&res.length<num&&pulse.source&&(cap=cnt=res.length,pulse.visit(pulse.SOURCE,t=>{map[vegaDataflow.tupleid(t)]||update(t)}),cap=-1);if(mod&&res.length>num){_=res.length-num;for(mod=0;mod<_;++mod)map[vegaDataflow.tupleid(res[mod])]=
-1,out.rem.push(res[mod]);res=res.slice(_)}pulse.mod.length&&pulse.visit(pulse.MOD,t=>{map[vegaDataflow.tupleid(t)]&&out.mod.push(t)});pulse.add.length&&pulse.visit(pulse.ADD,update);if(pulse.add.length||0>cap)out.add=res.filter(t=>!map[vegaDataflow.tupleid(t)]);this.count=cnt;this.value=out.source=res;return out}});Sequence.Definition={type:"Sequence",metadata:{generates:!0,changes:!0},params:[{name:"start",type:"number",required:!0},{name:"stop",type:"number",required:!0},{name:"step",type:"number",
"default":1},{name:"as",type:"string","default":"data"}]};vegaUtil.inherits(Sequence,vegaDataflow.Transform,{transform(_,pulse){if(!this.value||_.modified()){var out=pulse.materialize().fork(pulse.MOD),as=_.as||"data";out.rem=this.value?pulse.rem.concat(this.value):pulse.rem;this.value=d3Array.range(_.start,_.stop,_.step||1).map(v=>{const t={};t[as]=v;return vegaDataflow.ingest(t)});out.add=pulse.add.concat(this.value);return out}}});vegaUtil.inherits(Sieve,vegaDataflow.Transform,{transform(_,pulse){this.value=
pulse.source;return pulse.changed()?pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS):pulse.StopPropagation}});const OUTPUT=["unit0","unit1"];TimeUnit.Definition={type:"TimeUnit",metadata:{modifies:!0},params:[{name:"field",type:"field",required:!0},{name:"interval",type:"boolean","default":!0},{name:"units",type:"enum",values:vegaTime.TIME_UNITS,array:!0},{name:"step",type:"number","default":1},{name:"maxbins",type:"number","default":40},{name:"extent",type:"date",array:!0},{name:"timezone",type:"enum",
"default":"local",values:["local","utc"]},{name:"as",type:"string",array:!0,length:2,"default":OUTPUT}]};vegaUtil.inherits(TimeUnit,vegaDataflow.Transform,{transform(_,pulse){const field=_.field,band=!1!==_.interval;var utc="utc"===_.timezone;const floor=this._floor(_,pulse),offset=(utc?vegaTime.utcInterval:vegaTime.timeInterval)(floor.unit).offset;utc=_.as||OUTPUT;const u0=utc[0],u1=utc[1],step=floor.step;let min=floor.start||Infinity,max=floor.stop||-Infinity,flag=pulse.ADD;if(_.modified()||pulse.modified(vegaUtil.accessorFields(field)))pulse=
pulse.reflow(!0),flag=pulse.SOURCE,min=Infinity,max=-Infinity;pulse.visit(flag,t=>{var v=field(t);let b;null==v?(t[u0]=null,band&&(t[u1]=null)):(t[u0]=v=b=floor(v),band&&(t[u1]=b=offset(v,step)),v<min&&(min=v),b>max&&(max=b))});floor.start=min;floor.stop=max;return pulse.modifies(band?utc:u0)},_floor(_,pulse){var utc="utc"===_.timezone;const {units,step}=_.units?{units:_.units,step:_.step||1}:vegaTime.timeBin({extent:_.extent||vegaUtil.extent(pulse.materialize(pulse.SOURCE).source,_.field),maxbins:_.maxbins});
_=vegaTime.timeUnits(units);pulse=this.value||{};utc=(utc?vegaTime.utcFloor:vegaTime.timeFloor)(_,step);utc.unit=vegaUtil.peek(_);utc.units=_;utc.step=step;utc.start=pulse.start;utc.stop=pulse.stop;return this.value=utc}});vegaUtil.inherits(TupleIndex,vegaDataflow.Transform,{transform(_,pulse){const df=pulse.dataflow,field=_.field,index=this.value,set=t=>index.set(field(t),t);let mod=!0;_.modified("field")||pulse.modified(field.fields)?(index.clear(),pulse.visit(pulse.SOURCE,set)):pulse.changed()?
(pulse.visit(pulse.REM,t=>index.delete(field(t))),pulse.visit(pulse.ADD,set)):mod=!1;this.modified(mod);index.empty>df.cleanThreshold&&df.runAfter(index.clean);return pulse.fork()}});vegaUtil.inherits(Values,vegaDataflow.Transform,{transform(_,pulse){if(!this.value||_.modified("field")||_.modified("sort")||pulse.changed()||_.sort&&pulse.modified(_.sort.fields))this.value=(_.sort?pulse.source.slice().sort(vegaDataflow.stableCompare(_.sort)):pulse.source).map(_.field)}});const WindowOps={row_number:function(){return{next:w=>
w.index+1}},rank:function(){let rank;return{init:()=>rank=1,next:w=>{const i=w.index,data=w.data;return i&&w.compare(data[i-1],data[i])?rank=i+1:rank}}},dense_rank:function(){let drank;return{init:()=>drank=1,next:w=>{const i=w.index,d=w.data;return i&&w.compare(d[i-1],d[i])?++drank:drank}}},percent_rank:function(){const rank=WindowOps.rank(),next=rank.next;return{init:rank.init,next:w=>(next(w)-1)/(w.data.length-1)}},cume_dist:function(){let cume;return{init:()=>cume=0,next:w=>{const d=w.data,c=
w.compare;w=w.index;if(cume<w){for(;w+1<d.length&&!c(d[w],d[w+1]);)++w;cume=w}return(1+cume)/d.length}}},ntile:function(field,num){num=+num;0<num||vegaUtil.error("ntile num must be greater than zero.");field=WindowOps.cume_dist();const next=field.next;return{init:field.init,next:w=>Math.ceil(num*next(w))}},lag:function(field,offset){offset=+offset||1;return{next:w=>{const i=w.index-offset;return 0<=i?field(w.data[i]):null}}},lead:function(field,offset){offset=+offset||1;return{next:w=>{const i=w.index+
offset;w=w.data;return i<w.length?field(w[i]):null}}},first_value:function(field){return{next:w=>field(w.data[w.i0])}},last_value:function(field){return{next:w=>field(w.data[w.i1-1])}},nth_value:function(field,nth){nth=+nth;0<nth||vegaUtil.error("nth_value nth must be greater than zero.");return{next:w=>{const i=w.i0+(nth-1);return i<w.i1?field(w.data[i]):null}}},prev_value:function(field){let prev;return{init:()=>prev=null,next:w=>{w=field(w.data[w.index]);return null!=w?prev=w:prev}}},next_value:function(field){let v,
i;return{init:()=>(v=null,i=-1),next:w=>{var d=w.data;if(w.index<=i)d=v;else{a:{w=w.index;for(let n=d.length;w<n;++w)if(null!=field(d[w]))break a;w=-1}d=0>(i=w)?(i=d.length,v=null):v=field(d[i])}return d}}}};prototype$1=Object.keys(WindowOps);const prototype=WindowState.prototype;prototype.init=function(){this.windows.forEach(_=>_.init());this.cell&&this.cell.init()};prototype.update=function(w,t){const cell=this.cell,wind=this.windows,data=w.data,m=wind&&wind.length;let j;if(cell){for(j=w.p0;j<w.i0;++j)cell.rem(data[j]);
for(j=w.p1;j<w.i1;++j)cell.add(data[j]);cell.set(t)}for(j=0;j<m;++j)wind[j].update(w,t)};Window.Definition={type:"Window",metadata:{modifies:!0},params:[{name:"sort",type:"compare"},{name:"groupby",type:"field",array:!0},{name:"ops",type:"enum",array:!0,values:prototype$1.concat(noop)},{name:"params",type:"number","null":!0,array:!0},{name:"fields",type:"field","null":!0,array:!0},{name:"as",type:"string","null":!0,array:!0},{name:"frame",type:"number","null":!0,array:!0,length:2,"default":[null,
0]},{name:"ignorePeers",type:"boolean","default":!1}]};vegaUtil.inherits(Window,vegaDataflow.Transform,{transform(_,pulse){this.stamp=pulse.stamp;const mod=_.modified(),cmp=vegaDataflow.stableCompare(_.sort),key=groupkey(_.groupby),group=t=>this.group(key(t));let state=this.state;if(!state||mod)state=this.state=new WindowState(_);mod||pulse.modified(state.inputs)?(this.value={},pulse.visit(pulse.SOURCE,t=>group(t).add(t))):(pulse.visit(pulse.REM,t=>group(t).remove(t)),pulse.visit(pulse.ADD,t=>group(t).add(t)));
for(let i=0,n=this._mlen;i<n;++i)processPartition(this._mods[i],state,cmp,_);this._mlen=0;this._mods=[];return pulse.reflow(mod).modifies(state.outputs)},group(key){let group=this.value[key];group||(group=this.value[key]=SortedList(vegaDataflow.tupleid),group.stamp=-1);group.stamp<this.stamp&&(group.stamp=this.stamp,this._mods[this._mlen++]=group);return group}});exports.aggregate=Aggregate;exports.bin=Bin;exports.collect=Collect;exports.compare=Compare;exports.countpattern=CountPattern;exports.cross=
Cross;exports.density=Density;exports.dotbin=DotBin;exports.expression=Expression;exports.extent=Extent;exports.facet=Facet;exports.field=Field;exports.filter=Filter;exports.flatten=Flatten;exports.fold=Fold;exports.formula=Formula;exports.generate=Generate;exports.impute=Impute;exports.joinaggregate=JoinAggregate;exports.kde=KDE;exports.key=Key;exports.load=Load;exports.lookup=Lookup;exports.multiextent=MultiExtent;exports.multivalues=MultiValues;exports.params=Params;exports.pivot=Pivot;exports.prefacet=
PreFacet;exports.project=Project;exports.proxy=Proxy;exports.quantile=Quantile;exports.relay=Relay;exports.sample=Sample;exports.sequence=Sequence;exports.sieve=Sieve;exports.subflow=Subflow;exports.timeunit=TimeUnit;exports.tupleindex=TupleIndex;exports.values=Values;exports.window=Window;Object.defineProperty(exports,"__esModule",{value:!0})})}
//# sourceMappingURL=module$node_modules$vega_transforms$build$vega_transforms.js.map
