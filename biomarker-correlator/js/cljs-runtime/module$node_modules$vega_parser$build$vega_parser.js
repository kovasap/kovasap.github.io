shadow$provide.module$node_modules$vega_parser$build$vega_parser=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){"object"===typeof exports$jscomp$0&&"undefined"!==typeof module?factory(exports$jscomp$0,require("module$node_modules$vega_util$build$vega_util"),require("module$node_modules$vega_functions$build$vega_functions"),require("module$node_modules$vega_event_selector$build$vega_event_selector"),require("module$node_modules$vega_scale$build$vega_scale"),require("module$node_modules$vega_dataflow$build$vega_dataflow")):
"function"===typeof define&&define.amd?define("exports vega-util vega-functions vega-event-selector vega-scale vega-dataflow".split(" "),factory):(global="undefined"!==typeof globalThis?globalThis:global||self,factory(global.vega={},global.vega,global.vega,global.vega,global.vega,global.vega))})(this,function(exports,vegaUtil,vegaFunctions,vegaEventSelector,vegaScale,vegaDataflow){function parseAutosize(spec){return vegaUtil.isObject(spec)?spec:{type:spec||"pad"}}function parsePadding(spec){vegaUtil.isObject(spec)?
spec=spec.signal?spec:{top:+spec.top||0,bottom:+spec.bottom||0,left:+spec.left||0,right:+spec.right||0}:(spec=+spec||0,spec={top:spec,bottom:spec,left:spec,right:spec});return spec}function addEncode(object,name,value,set){return null!=value?(vegaUtil.isObject(value)&&!vegaUtil.isArray(value)||vegaUtil.isArray(value)&&value.length&&vegaUtil.isObject(value[0])?object.update[name]=value:object[set||"enter"][name]={value},1):0}function addEncoders(object,enter,update){for(const name in enter)addEncode(object,
name,enter[name]);for(const name in update)addEncode(object,name,update[name],"update")}function extendEncode(encode,extra,skip){for(const name in extra)skip&&vegaUtil.hasOwnProperty(skip,name)||(encode[name]=vegaUtil.extend(encode[name]||{},extra[name]));return encode}function has(key,encode){return encode&&(encode.enter&&encode.enter[key]||encode.update&&encode.update[key])}function applyDefaults(encode,type,role,style,config){const defaults={},enter={};let update,key$jscomp$0;key$jscomp$0="lineBreak";
"text"!==type||null==config[key$jscomp$0]||has(key$jscomp$0,encode)||applyDefault(defaults,key$jscomp$0,config[key$jscomp$0]);if("legend"==role||String(role).startsWith("axis"))role=null;role="frame"===role?config.group:"mark"===role?vegaUtil.extend({},config.mark,config[type]):null;for(key$jscomp$0 in role)(type=has(key$jscomp$0,encode)||("fill"===key$jscomp$0||"stroke"===key$jscomp$0)&&(has("fill",encode)||has("stroke",encode)))||applyDefault(defaults,key$jscomp$0,role[key$jscomp$0]);vegaUtil.array(style).forEach(name=>
{name=config.style&&config.style[name];for(const key in name)has(key,encode)||applyDefault(defaults,key,name[key])});encode=vegaUtil.extend({},encode);for(key$jscomp$0 in defaults)role=defaults[key$jscomp$0],role.signal?(update=update||{})[key$jscomp$0]=role:enter[key$jscomp$0]=role;encode.enter=vegaUtil.extend(enter,encode.enter);update&&(encode.update=vegaUtil.extend(update,encode.update));return encode}function applyDefault(defaults,key,value){defaults[key]=value&&value.signal?{signal:value.signal}:
{value}}function entry$1(enc){if(null!=enc.gradient)return gradient(enc);if(enc.signal)var JSCompiler_temp=`(${enc.signal})`;else enc.color?(JSCompiler_temp=enc.color,JSCompiler_temp=JSCompiler_temp.c?_color("hcl",JSCompiler_temp.h,JSCompiler_temp.c,JSCompiler_temp.l):JSCompiler_temp.h||JSCompiler_temp.s?_color("hsl",JSCompiler_temp.h,JSCompiler_temp.s,JSCompiler_temp.l):JSCompiler_temp.l||JSCompiler_temp.a?_color("lab",JSCompiler_temp.l,JSCompiler_temp.a,JSCompiler_temp.b):JSCompiler_temp.r||JSCompiler_temp.g||
JSCompiler_temp.b?_color("rgb",JSCompiler_temp.r,JSCompiler_temp.g,JSCompiler_temp.b):null):JSCompiler_temp=null!=enc.field?field$jscomp$0(enc.field):void 0!==enc.value?vegaUtil.stringValue(enc.value):void 0;if(null!=enc.scale){const scale=scaleRef(enc.scale);null!=enc.range?JSCompiler_temp=`lerp(_range(${scale}), ${+enc.range})`:(void 0!==JSCompiler_temp&&(JSCompiler_temp=`_scale(${scale}, ${JSCompiler_temp})`),enc.band&&(JSCompiler_temp=(JSCompiler_temp?JSCompiler_temp+"+":"")+`_bandwidth(${scale})`+
(1===+enc.band?"":"*"+property$jscomp$0(enc.band)),enc.extra&&(JSCompiler_temp=`(datum.extra ? _scale(${scale}, datum.extra.value) : ${JSCompiler_temp})`)),null==JSCompiler_temp&&(JSCompiler_temp="0"))}void 0===JSCompiler_temp&&(JSCompiler_temp=null);null!=enc.exponent&&(JSCompiler_temp=`pow(${JSCompiler_temp},${property$jscomp$0(enc.exponent)})`);null!=enc.mult&&(JSCompiler_temp+=`*${property$jscomp$0(enc.mult)}`);null!=enc.offset&&(JSCompiler_temp+=`+${property$jscomp$0(enc.offset)}`);enc.round&&
(JSCompiler_temp=`round(${JSCompiler_temp})`);return JSCompiler_temp}function gradient(enc){const args=[enc.start,enc.stop,enc.count].map(_=>null==_?null:vegaUtil.stringValue(_));for(;args.length&&null==vegaUtil.peek(args);)args.pop();args.unshift(scaleRef(enc.gradient));return`gradient(${args.join(",")})`}function property$jscomp$0(property){return vegaUtil.isObject(property)?"("+entry$1(property)+")":property}function field$jscomp$0(ref){return resolveField(vegaUtil.isObject(ref)?ref:{datum:ref})}
function resolveField(ref){let object;if(ref.signal){object="datum";var level=ref.signal}else if(ref.group||ref.parent){level=Math.max(1,ref.level||1);for(object="item";0<level--;)object+=".mark.group";ref.parent?(level=ref.parent,object+=".datum"):level=ref.group}else ref.datum?(object="datum",level=ref.datum):vegaUtil.error("Invalid field reference: "+vegaUtil.stringValue(ref));ref.signal||(level=vegaUtil.isString(level)?vegaUtil.splitAccessPath(level).map(vegaUtil.stringValue).join("]["):resolveField(level));
return object+"["+level+"]"}function rule$jscomp$0(enc){let code="";enc.forEach(rule=>{const value=entry$1(rule);code+=rule.test?`(${rule.test})?${value}:`:value});":"===vegaUtil.peek(code)&&(code+="null");return code}function parseEncode(encode,type,role,style,scope$jscomp$0,params$jscomp$0){const enc={};params$jscomp$0=params$jscomp$0||{};params$jscomp$0.encoders={$encode:enc};encode=applyDefaults(encode,type,role,style,scope$jscomp$0.config);for(const key in encode){role=encode[key];style=type;
var params=params$jscomp$0,scope=scope$jscomp$0;const channels={},fields={};for(const name in role)if(null!=role[name]){var JSCompiler_temp_const=parse$1;var JSCompiler_inline_result=role[name];JSCompiler_inline_result=vegaUtil.isArray(JSCompiler_inline_result)?rule$jscomp$0(JSCompiler_inline_result):entry$1(JSCompiler_inline_result);channels[name]=JSCompiler_temp_const(JSCompiler_inline_result,scope,params,fields)}role={$expr:{marktype:style,channels},$fields:Object.keys(fields),$output:Object.keys(role)};
enc[key]=role}return params$jscomp$0}function parse$1(code,scope,params,fields){code=vegaFunctions.parseExpression(code,scope);code.$fields.forEach(name=>fields[name]=1);vegaUtil.extend(params,code.$params);return code.$expr}function outerError(prefix,name){vegaUtil.error(prefix+' for "outer" push: '+vegaUtil.stringValue(name))}function parseSignal(signal,scope){const name=signal.name;if("outer"===signal.push)scope.signals[name]||outerError("No prior signal definition",name),OUTER_INVALID.forEach(prop=>
{void 0!==signal[prop]&&outerError("Invalid property ",prop)});else{const op=scope.addSignal(name,signal.value);!1===signal.react&&(op.react=!1);signal.bind&&scope.addBinding(name,signal.bind)}}function Entry(type,value,params,parent){this.id=-1;this.type=type;this.value=value;this.params=params;parent&&(this.parent=parent)}function ref$jscomp$0(op){const ref={$ref:op.id};0>op.id&&(op.refs=op.refs||[]).push(ref);return ref}function fieldRef$1(field,name){return name?{$field:field,$name:name}:{$field:field}}
function keyRef(fields,flat){fields={$key:fields};flat&&(fields.$flat=!0);return fields}function aggrField(op,field){return(op&&op.signal?"$"+op.signal:op||"")+(op&&field?"_":"")+(field&&field.signal?"$"+field.signal:field||"")}function isSignal(_){return _&&_.signal}function hasSignal(_){if(isSignal(_))return!0;if(vegaUtil.isObject(_))for(const key in _)if(hasSignal(_[key]))return!0;return!1}function value$jscomp$0(specValue,defaultValue){return null!=specValue?specValue:defaultValue}function deref(v){return v&&
v.signal||v}function parseStream(stream,scope){return(stream.merge?mergeStream:stream.stream?nestedStream:stream.type?eventStream:vegaUtil.error("Invalid stream specification: "+vegaUtil.stringValue(stream)))(stream,scope)}function mergeStream(stream,scope){const list=stream.merge.map(s=>parseStream(s,scope));stream=streamParameters({merge:list},stream,scope);return scope.addStream(stream).id}function nestedStream(stream,scope){const id=parseStream(stream.stream,scope);stream=streamParameters({stream:id},
stream,scope);return scope.addStream(stream).id}function eventStream(stream,scope){if("timer"===stream.type){var id=scope.event("timer",stream.throttle);stream={between:stream.between,filter:stream.filter}}else id=stream.source,id=scope.event.call(scope,"scope"===id?"view":id||"view",stream.type);stream=streamParameters({stream:id},stream,scope);return 1===Object.keys(stream).length?id:scope.addStream(stream).id}function streamParameters(entry,stream,scope){let param=stream.between;param&&(2!==param.length&&
vegaUtil.error('Stream "between" parameter must have 2 entries: '+vegaUtil.stringValue(stream)),entry.between=[parseStream(param[0],scope),parseStream(param[1],scope)]);param=stream.filter?[].concat(stream.filter):[];if(stream.marktype||stream.markname||stream.markrole){var JSCompiler_temp_const=param,type=stream.marktype,name=stream.markname,role=stream.markrole;JSCompiler_temp_const.push.call(JSCompiler_temp_const,"event.item"+(type&&"*"!==type?"\x26\x26event.item.mark.marktype\x3d\x3d\x3d'"+type+
"'":"")+(role?"\x26\x26event.item.mark.role\x3d\x3d\x3d'"+role+"'":"")+(name?"\x26\x26event.item.mark.name\x3d\x3d\x3d'"+name+"'":""))}"scope"===stream.source&&param.push("inScope(event.item)");param.length&&(entry.filter=vegaFunctions.parseExpression("("+param.join(")\x26\x26(")+")",scope).$expr);null!=(param=stream.throttle)&&(entry.throttle=+param);null!=(param=stream.debounce)&&(entry.debounce=+param);stream.consume&&(entry.consume=!0);return entry}function parseUpdate(spec,scope,target){const encode=
spec.encode,entry={target};target=spec.events;let update=spec.update,sources=[];target||vegaUtil.error("Signal update missing events specification.");vegaUtil.isString(target)&&(target=vegaEventSelector.parseSelector(target,scope.isSubscope()?"scope":"view"));target=vegaUtil.array(target).filter(s=>s.signal||s.scale?(sources.push(s),0):1);1<sources.length&&(sources=[mergeSources(sources)]);target.length&&sources.push(1<target.length?{merge:target}:target[0]);null!=encode&&(update&&vegaUtil.error("Signal encode and update are mutually exclusive."),
update="encode(item(),"+vegaUtil.stringValue(encode)+")");entry.update=vegaUtil.isString(update)?vegaFunctions.parseExpression(update,scope):null!=update.expr?vegaFunctions.parseExpression(update.expr,scope):null!=update.value?update.value:null!=update.signal?{$expr:OP_VALUE_EXPR,$params:{$value:scope.signalRef(update.signal)}}:vegaUtil.error("Invalid signal update specification.");spec.force&&(entry.options={force:!0});sources.forEach(source=>{var JSCompiler_temp_const=scope.addUpdate,JSCompiler_temp_const$jscomp$0=
vegaUtil.extend;source={source:source.signal?scope.signalRef(source.signal):source.scale?scope.scaleRef(source.scale):parseStream(source,scope)};return JSCompiler_temp_const.call(scope,JSCompiler_temp_const$jscomp$0.call(vegaUtil,source,entry))})}function mergeSources(sources){return{signal:"["+sources.map(s=>s.scale?'scale("'+s.scale+'")':s.signal)+"]"}}function parseSignalUpdates(signal,scope){const op=scope.getSignal(signal.name);let expr=signal.update;signal.init&&(expr?vegaUtil.error("Signals can not include both init and update expressions."):
(expr=signal.init,op.initonly=!0));expr&&(expr=vegaFunctions.parseExpression(expr,scope),op.update=expr.$expr,op.params=expr.$params);signal.on&&signal.on.forEach(_=>parseUpdate(_,scope,op.id))}function parseLiteral(v,scope){return vegaUtil.isObject(v)?v.signal?scope.signalRef(v.signal):vegaUtil.error("Unsupported object: "+vegaUtil.stringValue(v)):v}function parseArray(v$jscomp$0,scope){return v$jscomp$0.signal?scope.signalRef(v$jscomp$0.signal):v$jscomp$0.map(v=>parseLiteral(v,scope))}function dataLookupError(name){vegaUtil.error("Can not find data set: "+
vegaUtil.stringValue(name))}function parseScaleDomain(domain,spec,scope){if(domain)return domain.signal?scope.signalRef(domain.signal):(vegaUtil.isArray(domain)?explicitDomain:domain.fields?multipleDomain:singularDomain)(domain,spec,scope);null==spec.domainMin&&null==spec.domainMax||vegaUtil.error("No scale domain defined for domainMin/domainMax to override.")}function explicitDomain(domain,spec,scope){return domain.map(v=>parseLiteral(v,scope))}function singularDomain(domain,spec,scope){const data=
scope.getData(domain.data);data||dataLookupError(domain.data);return vegaScale.isDiscrete(spec.type)?data.valuesRef(scope,domain.field,parseSort(domain.sort,!1)):vegaScale.isQuantile(spec.type)?data.domainRef(scope,domain.field):data.extentRef(scope,domain.field)}function multipleDomain(domain,spec,scope){const data$jscomp$0=domain.data,fields=domain.fields.reduce((dom,d)=>{if(vegaUtil.isString(d))d={data:data$jscomp$0,field:d};else if(vegaUtil.isArray(d)||d.signal){var data=d;d="_:vega:_"+FIELD_REF_ID++;
const coll=Collect({});vegaUtil.isArray(data)?coll.value={$ingest:data}:data.signal&&(data="setdata("+vegaUtil.stringValue(d)+","+data.signal+")",coll.params.input=scope.signalRef(data));scope.addDataPipeline(d,[coll,Sieve({})]);d={data:d,field:"data"}}dom.push(d);return dom},[]);return(vegaScale.isDiscrete(spec.type)?ordinalMultipleDomain:vegaScale.isQuantile(spec.type)?quantileMultipleDomain:numericMultipleDomain)(domain,scope,fields)}function ordinalMultipleDomain(domain,scope,fields){const sort=
parseSort(domain.sort,!0);domain=fields.map(f=>{const data=scope.getData(f.data);data||dataLookupError(f.data);return data.countsRef(scope,f.field,sort)});const p={groupby:keyFieldRef,pulse:domain};sort&&(domain=sort.op||"count",fields=sort.field?aggrField(domain,sort.field):"count",p.ops=[MULTIDOMAIN_SORT_OPS[domain]],p.fields=[scope.fieldRef(fields)],p.as=[fields]);domain=scope.add(Aggregate(p));domain=scope.add(Collect({pulse:ref$jscomp$0(domain)}));fields=scope.add(Values({field:keyFieldRef,sort:scope.sortRef(sort),
pulse:ref$jscomp$0(domain)}));return ref$jscomp$0(fields)}function parseSort(sort,multidomain){sort&&(sort.field||sort.op?sort.field||"count"===sort.op?multidomain&&sort.field&&sort.op&&!MULTIDOMAIN_SORT_OPS[sort.op]&&vegaUtil.error("Multiple domain scales can not be sorted using "+sort.op):vegaUtil.error("No field provided for sort aggregate op: "+sort.op):vegaUtil.isObject(sort)?sort.field="key":sort={field:"key"});return sort}function quantileMultipleDomain(domain,scope,fields){domain=fields.map(f=>
{const data=scope.getData(f.data);data||dataLookupError(f.data);return data.domainRef(scope,f.field)});return ref$jscomp$0(scope.add(MultiValues({values:domain})))}function numericMultipleDomain(domain,scope,fields){domain=fields.map(f=>{const data=scope.getData(f.data);data||dataLookupError(f.data);return data.extentRef(scope,f.field)});return ref$jscomp$0(scope.add(MultiExtent({extents:domain})))}function parseScaleRange(spec,scope,params){const config=scope.config.range;let range=spec.range;if(range.signal)return scope.signalRef(range.signal);
if(vegaUtil.isString(range)){if(config&&vegaUtil.hasOwnProperty(config,range))return spec=vegaUtil.extend({},spec,{range:config[range]}),parseScaleRange(spec,scope,params);"width"===range?range=[0,{signal:"width"}]:"height"===range?range=vegaScale.isDiscrete(spec.type)?[0,{signal:"height"}]:[{signal:"height"},0]:vegaUtil.error("Unrecognized scale range value: "+vegaUtil.stringValue(range))}else{if(range.scheme){params.scheme=vegaUtil.isArray(range.scheme)?parseArray(range.scheme,scope):parseLiteral(range.scheme,
scope);range.extent&&(params.schemeExtent=parseArray(range.extent,scope));range.count&&(params.schemeCount=parseLiteral(range.count,scope));return}if(range.step){params.rangeStep=parseLiteral(range.step,scope);return}if(vegaScale.isDiscrete(spec.type)&&!vegaUtil.isArray(range))return parseScaleDomain(range,spec,scope);vegaUtil.isArray(range)||vegaUtil.error("Unsupported range type: "+vegaUtil.stringValue(range))}return range.map(v=>(vegaUtil.isArray(v)?parseArray:parseLiteral)(v,scope))}function parseParameter$1(_$jscomp$0,
name,scope){return vegaUtil.isArray(_$jscomp$0)?_$jscomp$0.map(_=>parseParameter$1(_,name,scope)):vegaUtil.isObject(_$jscomp$0)?_$jscomp$0.signal?scope.signalRef(_$jscomp$0.signal):"fit"===name?_$jscomp$0:vegaUtil.error("Unsupported parameter object: "+vegaUtil.stringValue(_$jscomp$0)):_$jscomp$0}function guideGroup(mark){mark.type="group";mark.interactive=mark.interactive||!1;return mark}function lookup$jscomp$0(spec,config){const _=(name,dflt)=>value$jscomp$0(spec[name],value$jscomp$0(config[name],
dflt));_.isVertical=s=>"vertical"===value$jscomp$0(spec.direction,config.direction||(s?config.symbolDirection:config.gradientDirection));_.gradientLength=()=>value$jscomp$0(spec.gradientLength,config.gradientLength||config.gradientWidth);_.gradientThickness=()=>value$jscomp$0(spec.gradientThickness,config.gradientThickness||config.gradientHeight);_.entryColumns=()=>value$jscomp$0(spec.columns,value$jscomp$0(config.columns,+_.isVertical(!0)));return _}function getEncoding(name,encode){return(name=
encode&&(encode.update&&encode.update[name]||encode.enter&&encode.enter[name]))&&name.signal?name:name?name.value:null}function anchorExpr(s,e,m){return`item.anchor === '${"start"}' ? ${s} : item.anchor === '${"end"}' ? ${e} : ${m}`}function extendOffset(value,offset){return offset?value?vegaUtil.isObject(value)?Object.assign({},value,{offset:extendOffset(value.offset,offset)}):{value,offset}:offset:value}function guideMark(mark,extras){extras?(mark.name=extras.name,mark.style=extras.style||mark.style,
mark.interactive=!!extras.interactive,mark.encode=extendEncode(mark.encode,extras,Skip)):mark.interactive=!1;return mark}function legendGradient(spec,scale,config,userEncode){spec=lookup$jscomp$0(spec,config);config=spec.isVertical();var thickness=spec.gradientThickness();const length=spec.gradientLength();let enter,stop,width;config?(config=[0,1],stop=[0,0],width=thickness,thickness=length):(config=[0,0],stop=[1,0],width=length);thickness={enter:enter={opacity:zero$jscomp$0,x:zero$jscomp$0,y:zero$jscomp$0,
width:encoder(width),height:encoder(thickness)},update:vegaUtil.extend({},enter,{opacity:one,fill:{gradient:scale,start:config,stop}}),exit:{opacity:zero$jscomp$0}};addEncoders(thickness,{stroke:spec("gradientStrokeColor"),strokeWidth:spec("gradientStrokeWidth")},{opacity:spec("gradientOpacity")});return guideMark({type:"rect",role:"legend-gradient",encode:thickness},userEncode)}function legendGradientDiscrete(spec,scale,config,userEncode,dataRef){spec=lookup$jscomp$0(spec,config);const vertical=
spec.isVertical();config=spec.gradientThickness();const length=spec.gradientLength();var u;let v,uu,vv,adjust="";vertical?(u="y",uu="y2",v="x",vv="width",adjust="1-"):(u="x",uu="x2",v="y",vv="height");scale={opacity:zero$jscomp$0,fill:{scale,field:"value"}};scale[u]={signal:adjust+"datum.perc",mult:length};scale[v]=zero$jscomp$0;scale[uu]={signal:adjust+"datum.perc2",mult:length};scale[vv]=encoder(config);u={enter:scale,update:vegaUtil.extend({},scale,{opacity:one}),exit:{opacity:zero$jscomp$0}};
addEncoders(u,{stroke:spec("gradientStrokeColor"),strokeWidth:spec("gradientStrokeWidth")},{opacity:spec("gradientOpacity")});return guideMark({type:"rect",role:"legend-band",key:"value",from:dataRef,encode:u},userEncode)}function legendGradientLabels(spec,config,userEncode,dataRef){const _=lookup$jscomp$0(spec,config);var vertical=_.isVertical();const thickness=encoder(_.gradientThickness()),length=_.gradientLength();let overlap=_("labelOverlap"),enter,update,v,adjust="";const encode={enter:enter=
{opacity:zero$jscomp$0},update:update={opacity:one,text:{field:"label"}},exit:{opacity:zero$jscomp$0}};addEncoders(encode,{fill:_("labelColor"),fillOpacity:_("labelOpacity"),font:_("labelFont"),fontSize:_("labelFontSize"),fontStyle:_("labelFontStyle"),fontWeight:_("labelFontWeight"),limit:value$jscomp$0(spec.labelLimit,config.gradientLabelLimit)});vertical?(enter.align={value:"left"},enter.baseline=update.baseline={signal:'datum.perc\x3c\x3d0?"bottom":datum.perc\x3e\x3d1?"top":"middle"'},vertical=
"y",v="x",adjust="1-"):(enter.align=update.align={signal:'datum.perc\x3c\x3d0?"left":datum.perc\x3e\x3d1?"right":"center"'},enter.baseline={value:"top"},vertical="x",v="y");enter[vertical]=update[vertical]={signal:adjust+"datum.perc",mult:length};enter[v]=update[v]=thickness;thickness.offset=value$jscomp$0(spec.labelOffset,config.gradientLabelOffset)||0;overlap=overlap?{separation:_("labelSeparation"),method:overlap,order:"datum.index"}:void 0;return guideMark({type:"text",role:"legend-label",style:"guide-label",
key:"value",from:dataRef,encode,overlap},userEncode)}function legendSymbolGroups(spec,config,userEncode,dataRef,columns){var _=lookup$jscomp$0(spec,config);const entries=userEncode.entries,interactive=!(!entries||!entries.interactive),name=entries?entries.name:void 0,height=_("clipHeight"),symbolOffset=_("symbolOffset"),valueRef={data:"value"},xSignal=`(${columns}) ? datum.${"offset"} : datum.${"size"}`,yEncode=height?encoder(height):{field:"size"},ncols=`max(1, ${columns})`;let enter,update;yEncode.mult=
.5;var encode={enter:enter={opacity:zero$jscomp$0,x:{signal:xSignal,mult:.5,offset:symbolOffset},y:yEncode},update:update={opacity:one,x:enter.x,y:enter.y},exit:{opacity:zero$jscomp$0}};let baseFill=null,baseStroke=null;spec.fill||(baseFill=config.symbolBaseFillColor,baseStroke=config.symbolBaseStrokeColor);addEncoders(encode,{fill:_("symbolFillColor",baseFill),shape:_("symbolType"),size:_("symbolSize"),stroke:_("symbolStrokeColor",baseStroke),strokeDash:_("symbolDash"),strokeDashOffset:_("symbolDashOffset"),
strokeWidth:_("symbolStrokeWidth")},{opacity:_("symbolOpacity")});LegendScales.forEach(scale=>{spec[scale]&&(update[scale]=enter[scale]={scale:spec[scale],field:"value"})});config=guideMark({type:"symbol",role:"legend-symbol",key:"value",from:valueRef,clip:height?!0:void 0,encode},userEncode.symbols);encode=encoder(symbolOffset);encode.offset=_("labelOffset");encode={enter:enter={opacity:zero$jscomp$0,x:{signal:xSignal,offset:encode},y:yEncode},update:update={opacity:one,text:{field:"label"},x:enter.x,
y:enter.y},exit:{opacity:zero$jscomp$0}};addEncoders(encode,{align:_("labelAlign"),baseline:_("labelBaseline"),fill:_("labelColor"),fillOpacity:_("labelOpacity"),font:_("labelFont"),fontSize:_("labelFontSize"),fontStyle:_("labelFontStyle"),fontWeight:_("labelFontWeight"),limit:_("labelLimit")});userEncode=guideMark({type:"text",role:"legend-label",style:"guide-label",key:"value",from:valueRef,encode},userEncode.labels);encode={enter:{noBound:{value:!height},width:zero$jscomp$0,height:height?encoder(height):
zero$jscomp$0,opacity:zero$jscomp$0},exit:{opacity:zero$jscomp$0},update:update={opacity:one,row:{signal:null},column:{signal:null}}};_.isVertical(!0)?(_=`ceil(item.mark.items.length / ${ncols})`,update.row.signal=`${"datum.index"}%${_}`,update.column.signal=`floor(${"datum.index"} / ${_})`,_={field:["row","datum.index"]}):(update.row.signal=`floor(${"datum.index"} / ${ncols})`,update.column.signal=`${"datum.index"} % ${ncols}`,_={field:"datum.index"});update.column.signal=`(${columns})?${update.column.signal}:${"datum.index"}`;
dataRef={facet:{data:dataRef,name:"value",groupby:"index"}};return guideGroup({role:"scope",from:dataRef,encode:extendEncode(encode,entries,Skip),marks:[config,userEncode],name,interactive,sort:_})}function legendSymbolLayout(spec,config){spec=lookup$jscomp$0(spec,config);return{align:spec("gridAlign"),columns:spec.entryColumns(),center:{row:!0,column:!1},padding:{row:spec("rowPadding"),column:spec("columnPadding")}}}function legendTitle(spec,config,userEncode,dataRef){config=lookup$jscomp$0(spec,
config);const encode={enter:{opacity:zero$jscomp$0},update:{opacity:one,x:{field:{group:"padding"}},y:{field:{group:"padding"}}},exit:{opacity:zero$jscomp$0}};addEncoders(encode,{orient:config("titleOrient"),_anchor:config("titleAnchor"),anchor:{signal:'item._anchor || ((item.orient \x3d\x3d\x3d "left" || item.orient \x3d\x3d\x3d "right") ? "middle" : "start")'},angle:{signal:'datum.vgrad \x26\x26 (item.orient \x3d\x3d\x3d "left" || item.orient \x3d\x3d\x3d "right") ? (item.orient \x3d\x3d\x3d "left" ? -90 : 90) : 0'},
align:{signal:exprAlign},baseline:{signal:exprBaseline},text:spec.title,fill:config("titleColor"),fillOpacity:config("titleOpacity"),font:config("titleFont"),fontSize:config("titleFontSize"),fontStyle:config("titleFontStyle"),fontWeight:config("titleFontWeight"),limit:config("titleLimit"),lineHeight:config("titleLineHeight")},{align:config("titleAlign"),baseline:config("titleBaseline")});return guideMark({type:"text",role:"legend-title",style:"guide-title",from:dataRef,encode},userEncode)}function clip$jscomp$0(clip,
scope){let expr;vegaUtil.isObject(clip)&&(clip.signal?expr=clip.signal:clip.path?expr="pathShape("+param$jscomp$0(clip.path)+")":clip.sphere&&(expr="geoShape("+param$jscomp$0(clip.sphere)+', {type: "Sphere"})'));return expr?scope.signalRef(expr):!!clip}function param$jscomp$0(value){return vegaUtil.isObject(value)&&value.signal?value.signal:vegaUtil.stringValue(value)}function getRole(spec){const role=spec.role||"";return role.indexOf("axis")&&role.indexOf("legend")&&role.indexOf("title")?"group"===
spec.type?"scope":role||"mark":role}function definition(spec){return{marktype:spec.type,name:spec.name||void 0,role:spec.role||getRole(spec),zindex:+spec.zindex||void 0,aria:spec.aria,description:spec.description}}function interactive(spec,scope){return spec&&spec.signal?scope.signalRef(spec.signal):!1===spec?!1:!0}function parseTransform(spec,scope){const def=vegaDataflow.definition(spec.type);def||vegaUtil.error("Unrecognized transform type: "+vegaUtil.stringValue(spec.type));var JSCompiler_inline_result=
def.type.toLowerCase();var params=parseParameters(def,spec,scope);JSCompiler_inline_result=new Entry(JSCompiler_inline_result,null,params,void 0);spec.signal&&scope.addSignal(spec.signal,scope.proxy(JSCompiler_inline_result));JSCompiler_inline_result.metadata=def.metadata||{};return JSCompiler_inline_result}function parseParameters(def,spec,scope){const params={},n=def.params.length;for(let i=0;i<n;++i){const pdef=def.params[i];params[pdef.name]=parseParameter(pdef,spec,scope)}return params}function parseParameter(def,
spec,scope){const type=def.type,value=spec[def.name];if("index"===type)return parseIndexParameter(def,spec,scope);if(void 0===value)def.required&&vegaUtil.error("Missing required "+vegaUtil.stringValue(spec.type)+" parameter: "+vegaUtil.stringValue(def.name));else return"param"===type?parseSubParameters(def,spec,scope):"projection"===type?scope.projectionRef(spec[def.name]):def.array&&!isSignal(value)?value.map(v=>parameterValue(def,v,scope)):parameterValue(def,value,scope)}function parameterValue(def,
value,scope){const type=def.type;return isSignal(value)?"expr"===type?vegaUtil.error("Expression references can not be signals."):"field"===type?scope.fieldRef(value):"compare"===type?scope.compareRef(value):scope.signalRef(value.signal):(def=def.expr||"field"===type)&&value&&value.expr?scope.exprRef(value.expr,value.as):def&&value&&value.field?fieldRef$1(value.field,value.as):"expr"===type?vegaFunctions.parseExpression(value,scope):"data"===type?ref$jscomp$0(scope.getData(value).values):"field"===
type?fieldRef$1(value):"compare"===type?scope.compareRef(value):value}function parseIndexParameter(def,spec,scope){vegaUtil.isString(spec.from)||vegaUtil.error('Lookup "from" parameter must be a string literal.');return scope.getData(spec.from).lookupRef(scope,spec.key)}function parseSubParameters(def,spec,scope){spec=spec[def.name];return def.array?(vegaUtil.isArray(spec)||vegaUtil.error("Expected an array of sub-parameters. Instead: "+vegaUtil.stringValue(spec)),spec.map(v=>parseSubParameter(def,
v,scope))):parseSubParameter(def,spec,scope)}function parseSubParameter(def,value,scope){const n=def.params.length;let pdef;for(let i=0;i<n;++i){pdef=def.params[i];for(const k in pdef.key)if(pdef.key[k]!==value[k]){pdef=null;break}if(pdef)break}pdef||vegaUtil.error("Unsupported parameter: "+vegaUtil.stringValue(value));def=vegaUtil.extend(parseParameters(pdef,value,scope),pdef.key);return ref$jscomp$0(scope.add(Params(def)))}function parseData$1(from,group,scope){let facet,key,dataRef,parent;if(!from)dataRef=
ref$jscomp$0(scope.add(Collect(null,[{}])));else if(facet=from.facet)group||vegaUtil.error("Only group marks can be faceted."),null!=facet.field?dataRef=parent=getDataRef(facet,scope):(from.data?parent=ref$jscomp$0(scope.getData(from.data).aggregate):(group=parseTransform(vegaUtil.extend({type:"aggregate",groupby:vegaUtil.array(facet.groupby)},facet.aggregate),scope),group.params.key=scope.keyRef(facet.groupby),group.params.pulse=getDataRef(facet,scope),dataRef=parent=ref$jscomp$0(scope.add(group))),
key=scope.keyRef(facet.groupby,!0));dataRef||(dataRef=getDataRef(from,scope));return{key,pulse:dataRef,parent}}function getDataRef(from,scope){return from.$ref?from:from.data&&from.data.$ref?from.data:ref$jscomp$0(scope.getData(from.data).output)}function DataScope(scope,input,output,values,aggr){this.scope=scope;this.input=input;this.output=output;this.values=values;this.aggregate=aggr;this.index={}}function fieldKey(field){return vegaUtil.isString(field)?field:null}function addSortField(scope,p,
sort){const as=aggrField(sort.op,sort.field);let s;if(p.ops)for(let i=0,n=p.as.length;i<n;++i){if(p.as[i]===as)return}else p.ops=["count"],p.fields=[null],p.as=["count"];sort.op&&(p.ops.push((s=sort.op.signal)?scope.signalRef(s):sort.op),p.fields.push(scope.fieldRef(sort.field)),p.as.push(as))}function cache$jscomp$0(scope,ds,name,optype,field,counts,index){name=ds[name]||(ds[name]={});var JSCompiler_inline_result=vegaUtil.isObject(counts)?("descending"===counts.order?"-":"+")+aggrField(counts.op,
counts.field):"";let k=fieldKey(field);if(null!=k){scope=ds.scope;k+=JSCompiler_inline_result?"|"+JSCompiler_inline_result:"";var v=name[k]}v||(v=counts?{field:keyFieldRef,pulse:ds.countsRef(scope,field,counts)}:{field:scope.fieldRef(field),pulse:ref$jscomp$0(ds.output)},JSCompiler_inline_result&&(v.sort=scope.sortRef(counts)),scope=scope.add(new Entry(optype,void 0,v,void 0)),index&&(ds.index[field]=scope),v=ref$jscomp$0(scope),null!=k&&(name[k]=v));return v}function parseFacet(spec,scope,group){var facet=
spec.from.facet;const name=facet.name,data=getDataRef(facet,scope);let op;facet.name||vegaUtil.error("Facet must have a name: "+vegaUtil.stringValue(facet));facet.data||vegaUtil.error("Facet must reference a data set: "+vegaUtil.stringValue(facet));facet.field?op=scope.add(PreFacet({field:scope.fieldRef(facet.field),pulse:data})):facet.groupby?op=scope.add(Facet({key:scope.keyRef(facet.groupby),group:ref$jscomp$0(scope.proxy(group.parent)),pulse:data})):vegaUtil.error("Facet must specify groupby or field: "+
vegaUtil.stringValue(facet));scope=scope.fork();group=scope.add(Collect());facet=scope.add(Sieve({pulse:ref$jscomp$0(group)}));scope.addData(name,new DataScope(scope,group,group,facet));scope.addSignal("parent",null);op.params.subflow={$subflow:scope.parse(spec).toRuntime()}}function parseSubflow(spec,scope,input){input=scope.add(PreFacet({pulse:input.pulse}));scope=scope.fork();scope.add(Sieve());scope.addSignal("parent",null);input.params.subflow={$subflow:scope.parse(spec).toRuntime()}}function parseTrigger(spec,
scope,name){const remove=spec.remove,insert=spec.insert,toggle=spec.toggle,modify=spec.modify,values=spec.values,op=scope.add(new Entry("operator",void 0,void 0,void 0));spec="if("+spec.trigger+',modify("'+name+'",'+[insert,remove,toggle,modify,values].map(_=>null==_?"null":_).join(",")+"),0)";scope=vegaFunctions.parseExpression(spec,scope);op.update=scope.$expr;op.params=scope.$params}function parseMark(spec,scope){var role=getRole(spec),group="group"===spec.type,facet=spec.from&&spec.from.facet;
const overlap=spec.overlap;let layout=spec.layout||"scope"===role||"frame"===role,ops,op,store,enc,name,layoutRef;const nested="mark"===role||layout||facet,input=parseData$1(spec.from,group,scope);op=scope.add(DataJoin({key:input.key||(spec.key?fieldRef$1(spec.key):void 0),pulse:input.pulse,clean:!group}));const joinRef=ref$jscomp$0(op);op=store=scope.add(Collect({pulse:joinRef}));op=scope.add(Mark({markdef:definition(spec),interactive:interactive(spec.interactive,scope),clip:clip$jscomp$0(spec.clip,
scope),context:{$context:!0},groups:scope.lookup(),parent:scope.signals.parent?scope.signalRef("parent"):null,index:scope.markpath(),pulse:ref$jscomp$0(op)}));var boundRef=ref$jscomp$0(op);op=enc=scope.add(Encode(parseEncode(spec.encode,spec.type,role,spec.style,scope,{mod:!1,pulse:boundRef})));op.params.parent=scope.encode();spec.transform&&spec.transform.forEach(_=>{_=parseTransform(_,scope);const md=_.metadata;(md.generates||md.changes)&&vegaUtil.error("Mark transforms should not generate new data.");
md.nomod||(enc.params.mod=!0);_.params.pulse=ref$jscomp$0(op);scope.add(op=_)});spec.sort&&(op=scope.add(SortItems({sort:scope.compareRef(spec.sort),pulse:ref$jscomp$0(op)})));role=ref$jscomp$0(op);if(facet||layout)layout=scope.add(ViewLayout({layout:scope.objectProperty(spec.layout),legends:scope.legends,mark:boundRef,pulse:role})),layoutRef=ref$jscomp$0(layout);const bound=scope.add(Bound({mark:boundRef,pulse:layoutRef||role}));boundRef=ref$jscomp$0(bound);group&&(nested&&(ops=scope.operators,ops.pop(),
layout&&ops.pop()),scope.pushState(role,layoutRef||boundRef,joinRef),facet?parseFacet(spec,scope,input):nested?parseSubflow(spec,scope,input):scope.parse(spec),scope.popState(),nested&&(layout&&ops.push(layout),ops.push(bound)));overlap&&(boundRef=parseOverlap(overlap,boundRef,scope));group=scope.add(Render({pulse:boundRef}));facet=scope.add(Sieve({pulse:ref$jscomp$0(group)},void 0,scope.parent()));null!=spec.name&&(name=spec.name,scope.addData(name,new DataScope(scope,store,group,facet)),spec.on&&
spec.on.forEach(on=>{(on.insert||on.remove||on.toggle)&&vegaUtil.error("Marks only support modify triggers.");parseTrigger(on,scope,name)}))}function parseOverlap(overlap,source,scope){const method=overlap.method,bound=overlap.bound,sep=overlap.separation;source={separation:isSignal(sep)?scope.signalRef(sep.signal):sep,method:isSignal(method)?scope.signalRef(method.signal):method,pulse:source};overlap.order&&(source.sort=scope.compareRef({field:overlap.order}));bound&&(overlap=bound.tolerance,source.boundTolerance=
isSignal(overlap)?scope.signalRef(overlap.signal):+overlap,source.boundScale=scope.scaleRef(bound.scale),source.boundOrient=bound.orient);return ref$jscomp$0(scope.add(Overlap(source)))}function parseLegend(spec,scope){const config=scope.config.legend,encode=spec.encode||{},_=lookup$jscomp$0(spec,config),legendEncode=encode.legend||{},name=legendEncode.name||void 0,interactive=legendEncode.interactive,style=legendEncode.style,scales={};let scale=0,entryLayout,params;LegendScales.forEach(s=>spec[s]?
(scales[s]=spec[s],scale=scale||spec[s]):0);scale||vegaUtil.error("Missing valid scale for legend.");var children=legendType(spec,scope.scaleType(scale));const datum={title:null!=spec.title,scales,type:children,vgrad:"symbol"!==children&&_.isVertical()},dataRef=ref$jscomp$0(scope.add(Collect(null,[datum]))),entryRef=ref$jscomp$0(scope.add(LegendEntries(params={type:children,scale:scope.scaleRef(scale),count:scope.objectProperty(_("tickCount")),limit:scope.property(_("symbolLimit")),values:scope.objectProperty(spec.values),
minstep:scope.property(spec.tickMinStep),formatType:scope.property(spec.formatType),formatSpecifier:scope.property(spec.format)})));"gradient"===children?(children=[legendGradient(spec,scale,config,encode.gradient),legendGradientLabels(spec,config,encode.labels,entryRef)],params.count=params.count||scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`)):"discrete"===children?children=[legendGradientDiscrete(spec,scale,config,encode.gradient,entryRef),legendGradientLabels(spec,config,
encode.labels,entryRef)]:(entryLayout=legendSymbolLayout(spec,config),children=[legendSymbolGroups(spec,config,encode,entryRef,deref(entryLayout.columns))],params.size=sizeExpression(spec,scope,children[0].marks));children=[guideGroup({role:"legend-entry",from:dataRef,encode:{enter:{x:{value:0},y:{value:0}}},marks:children,layout:entryLayout,interactive})];datum.title&&children.push(legendTitle(spec,config,encode.title,dataRef));return parseMark(guideGroup({role:"legend",from:dataRef,encode:extendEncode(buildLegendEncode(_,
spec,config),legendEncode,Skip),marks:children,aria:_("aria"),description:_("description"),zindex:_("zindex"),name,interactive,style}),scope)}function legendType(spec,scaleType){let type=spec.type||"symbol";spec.type||1!==scaleCount(spec)||!spec.fill&&!spec.stroke||(type=vegaScale.isContinuous(scaleType)?"gradient":vegaScale.isDiscretizing(scaleType)?"discrete":"symbol");return"gradient"!==type?type:vegaScale.isDiscretizing(scaleType)?"discrete":"gradient"}function scaleCount(spec){return LegendScales.reduce((count,
type)=>count+(spec[type]?1:0),0)}function buildLegendEncode(_,spec,config){const encode={enter:{},update:{}};addEncoders(encode,{orient:_("orient"),offset:_("offset"),padding:_("padding"),titlePadding:_("titlePadding"),cornerRadius:_("cornerRadius"),fill:_("fillColor"),stroke:_("strokeColor"),strokeWidth:config.strokeWidth,strokeDash:config.strokeDash,x:_("legendX"),y:_("legendY"),format:spec.format,formatType:spec.formatType});return encode}function sizeExpression(spec,scope,marks){const size=deref(getChannel("size",
spec,marks));spec=deref(getChannel("strokeWidth",spec,marks));(marks=getEncoding("fontSize",marks[1].encode))||(marks=(marks=scope.config.style["guide-label"])&&marks.fontSize);marks=deref(marks);return vegaFunctions.parseExpression(`max(ceil(sqrt(${size})+${spec}),${marks})`,scope)}function getChannel(name,spec,marks){return spec[name]?`scale("${spec[name]}",datum)`:getEncoding(name,marks[0].encode)}function parseTitle(spec,scope){spec=vegaUtil.isString(spec)?{text:spec}:spec;const _=lookup$jscomp$0(spec,
scope.config.title);var encode=spec.encode||{},userEncode=encode.group||{};const name=userEncode.name||void 0,interactive=userEncode.interactive,style=userEncode.style,children=[],dataRef=ref$jscomp$0(scope.add(Collect(null,[{}])));var JSCompiler_temp_const=children.push,JSCompiler_temp_const$jscomp$0=spec;var JSCompiler_inline_result=(JSCompiler_inline_result=spec.encode)&&JSCompiler_inline_result.title||vegaUtil.extend({name:spec.name,interactive:spec.interactive,style:spec.style},JSCompiler_inline_result);
var zero={value:0};zero={enter:{opacity:zero},update:{opacity:{value:1}},exit:{opacity:zero}};addEncoders(zero,{text:JSCompiler_temp_const$jscomp$0.text,align:{signal:"item.mark.group.align"},angle:{signal:"item.mark.group.angle"},limit:{signal:"item.mark.group.limit"},baseline:"top",dx:_("dx"),dy:_("dy"),fill:_("color"),font:_("font"),fontSize:_("fontSize"),fontStyle:_("fontStyle"),fontWeight:_("fontWeight"),lineHeight:_("lineHeight")},{align:_("align"),angle:_("angle"),baseline:_("baseline")});
JSCompiler_temp_const$jscomp$0=guideMark({type:"text",role:"title-text",style:"group-title",from:dataRef,encode:zero},JSCompiler_inline_result);JSCompiler_temp_const.call(children,JSCompiler_temp_const$jscomp$0);spec.subtitle&&(JSCompiler_temp_const=children.push,encode=encode.subtitle,JSCompiler_temp_const$jscomp$0={value:0},JSCompiler_temp_const$jscomp$0={enter:{opacity:JSCompiler_temp_const$jscomp$0},update:{opacity:{value:1}},exit:{opacity:JSCompiler_temp_const$jscomp$0}},addEncoders(JSCompiler_temp_const$jscomp$0,
{text:spec.subtitle,align:{signal:"item.mark.group.align"},angle:{signal:"item.mark.group.angle"},limit:{signal:"item.mark.group.limit"},baseline:"top",dx:_("dx"),dy:_("dy"),fill:_("subtitleColor"),font:_("subtitleFont"),fontSize:_("subtitleFontSize"),fontStyle:_("subtitleFontStyle"),fontWeight:_("subtitleFontWeight"),lineHeight:_("subtitleLineHeight")},{align:_("align"),angle:_("angle"),baseline:_("baseline")}),spec=guideMark({type:"text",role:"title-subtitle",style:"group-subtitle",from:dataRef,
encode:JSCompiler_temp_const$jscomp$0},encode),JSCompiler_temp_const.call(children,spec));spec={enter:{},update:{}};addEncoders(spec,{orient:_("orient"),anchor:_("anchor"),align:{signal:alignExpr$1},angle:{signal:'item.orient\x3d\x3d\x3d"left"?-90:item.orient\x3d\x3d\x3d"right"?90:0'},limit:_("limit"),frame:_("frame"),offset:_("offset")||0,padding:_("subtitlePadding")});userEncode=extendEncode(spec,userEncode,Skip);return parseMark(guideGroup({role:"title",from:dataRef,encode:userEncode,marks:children,
aria:_("aria"),description:_("description"),zindex:_("zindex"),name,interactive,style}),scope)}function parseData(data,scope){const transforms=[];data.transform&&data.transform.forEach(tx=>{transforms.push(parseTransform(tx,scope))});data.on&&data.on.forEach(on=>{parseTrigger(on,scope,data.name)});scope.addDataPipeline(data.name,analyze(data,scope,transforms))}function analyze(data,scope,ops){const output=[];let source=null,modify=!1,generate=!1,upstream,n,t,m;data.values?isSignal(data.values)||hasSignal(data.format)?
(output.push(load(scope,data)),output.push(source=collect())):output.push(source=collect({$ingest:data.values,$format:data.format})):data.url?hasSignal(data.url)||hasSignal(data.format)?(output.push(load(scope,data)),output.push(source=collect())):output.push(source=collect({$request:data.url,$format:data.format})):data.source&&(source=upstream=vegaUtil.array(data.source).map(d=>ref$jscomp$0(scope.getData(d).output)),output.push(null));data=0;for(n=ops.length;data<n;++data)t=ops[data],m=t.metadata,
source||m.source||output.push(source=collect()),output.push(t),m.generates&&(generate=!0),m.modifies&&!generate&&(modify=!0),m.source?source=t:m.changes&&(source=null);upstream&&(n=upstream.length-1,output[0]=Relay({derive:modify,pulse:n?upstream:upstream[0]}),(modify||n)&&output.splice(1,0,collect()));source||output.push(collect());output.push(Sieve({}));return output}function collect(values){values=Collect({},values);values.metadata={source:!0};return values}function load(scope,data){return Load({url:data.url?
scope.property(data.url):void 0,async:data.async?scope.property(data.async):void 0,values:data.values?scope.property(data.values):void 0,format:scope.objectProperty(data.format)})}function fallback(prop,config,axisConfig,style){let styleProp;if(config&&vegaUtil.hasOwnProperty(config,prop))return config[prop];if(vegaUtil.hasOwnProperty(axisConfig,prop))return axisConfig[prop];if(prop.startsWith("title")){switch(prop){case "titleColor":styleProp="fill";break;case "titleFont":case "titleFontSize":case "titleFontWeight":styleProp=
prop[5].toLowerCase()+prop.slice(6)}return style["guide-title"][styleProp]}if(prop.startsWith("label")){switch(prop){case "labelColor":styleProp="fill";break;case "labelFont":case "labelFontSize":styleProp=prop[5].toLowerCase()+prop.slice(6)}return style["guide-label"][styleProp]}return null}function keys(objects){const map={};for(const obj of objects)if(obj)for(const key in obj)map[key]=1;return Object.keys(map)}function flushExpr(scale,threshold,a,b,c){return{signal:'flush(range("'+scale+'"), scale("'+
scale+'", datum.value), '+threshold+","+a+","+b+","+c+")"}}function autoLayout(_,orient,encode,userEncode){const auto=(value,dim)=>null!=value?(encode.update[dim]=patch(encoder(value),encode.update[dim]),!1):has(dim,userEncode)?!1:!0,autoY=auto(_("titleX"),"x");_=auto(_("titleY"),"y");encode.enter.auto=_===autoY?encoder(_):ifX(orient,encoder(_),encoder(autoY))}function parseScope(spec,scope,preprocessed){const signals=vegaUtil.array(spec.signals),scales=vegaUtil.array(spec.scales);preprocessed||signals.forEach(_=>
parseSignal(_,scope));vegaUtil.array(spec.projections).forEach(_=>{const config=scope.config.projection||{},params={};for(const name in _)"name"!==name&&(params[name]=parseParameter$1(_[name],name,scope));for(const name in config)null==params[name]&&(params[name]=parseParameter$1(config[name],name,scope));scope.addProjection(_.name,params)});scales.forEach(_=>{const type=_.type||"linear";vegaScale.isValidScaleType(type)||vegaUtil.error("Unrecognized scale type: "+vegaUtil.stringValue(type));scope.addScale(_.name,
{type,domain:void 0})});vegaUtil.array(spec.data).forEach(_=>parseData(_,scope));scales.forEach(_=>{const params=scope.getScale(_.name).params;let key;params.domain=parseScaleDomain(_.domain,_,scope);null!=_.range&&(params.range=parseScaleRange(_,scope,params));if(null!=_.interpolate){var interpolate=_.interpolate;params.interpolate=parseLiteral(interpolate.type||interpolate);null!=interpolate.gamma&&(params.interpolateGamma=parseLiteral(interpolate.gamma))}null!=_.nice&&(interpolate=_.nice,interpolate=
vegaUtil.isObject(interpolate)?{interval:parseLiteral(interpolate.interval),step:parseLiteral(interpolate.step)}:parseLiteral(interpolate),params.nice=interpolate);null!=_.bins&&(interpolate=_.bins,interpolate=interpolate.signal||vegaUtil.isArray(interpolate)?parseArray(interpolate,scope):scope.objectProperty(interpolate),params.bins=interpolate);for(key in _)vegaUtil.hasOwnProperty(params,key)||"name"===key||(params[key]=parseLiteral(_[key],scope))});(preprocessed||signals).forEach(_=>parseSignalUpdates(_,
scope));vegaUtil.array(spec.axes).forEach(_$jscomp$1=>{var config=scope.config,style=config.style,axis=config.axis,band="band"===scope.scaleType(_$jscomp$1.scale)&&config.axisBand,orient$jscomp$0=_$jscomp$1.orient,key;if(isSignal(orient$jscomp$0)){const xyKeys=keys([config.axisX,config.axisY]),orientKeys=keys([config.axisTop,config.axisBottom,config.axisLeft,config.axisRight]);var xy={};for(key of xyKeys)xy[key]=ifX(orient$jscomp$0,fallback(key,config.axisX,axis,style),fallback(key,config.axisY,axis,
style));var or={};for(key of orientKeys){var JSCompiler_temp_const=or,JSCompiler_temp_const$jscomp$0=key,$orient=orient$jscomp$0.signal,t=fallback(key,config.axisTop,axis,style),b=fallback(key,config.axisBottom,axis,style),l=fallback(key,config.axisLeft,axis,style),r=fallback(key,config.axisRight,axis,style);var JSCompiler_inline_result={signal:(null!=l?`${$orient} === '${"left"}' ? (${toExpr(l)}) : `:"")+(null!=b?`${$orient} === '${"bottom"}' ? (${toExpr(b)}) : `:"")+(null!=r?`${$orient} === '${"right"}' ? (${toExpr(r)}) : `:
"")+(null!=t?`${$orient} === '${"top"}' ? (${toExpr(t)}) : `:"")+"(null)"};JSCompiler_temp_const[JSCompiler_temp_const$jscomp$0]=JSCompiler_inline_result}}else xy="top"===orient$jscomp$0||"bottom"===orient$jscomp$0?config.axisX:config.axisY,or=config["axis"+orient$jscomp$0[0].toUpperCase()+orient$jscomp$0.slice(1)];var JSCompiler_inline_result$jscomp$0=xy||or||band?vegaUtil.extend({},axis,xy,or,band):axis;const encode$jscomp$0=_$jscomp$1.encode||{},axisEncode=encode$jscomp$0.axis||{},name=axisEncode.name||
void 0,interactive=axisEncode.interactive,style$jscomp$0=axisEncode.style,_$jscomp$0=lookup$jscomp$0(_$jscomp$1,JSCompiler_inline_result$jscomp$0),v=_$jscomp$0("tickBand");let offset$jscomp$0=_$jscomp$0("tickOffset"),band$jscomp$0,extra;v?v.signal?(band$jscomp$0={signal:`(${v.signal}) === 'extent' ? 1 : 0.5`},extra={signal:`(${v.signal}) === 'extent'`},vegaUtil.isObject(offset$jscomp$0)||(offset$jscomp$0={signal:`(${v.signal}) === 'extent' ? 0 : ${offset$jscomp$0}`})):"extent"===v?(band$jscomp$0=
1,extra=!0,offset$jscomp$0=0):(band$jscomp$0=.5,extra=!1):(band$jscomp$0=_$jscomp$0("bandPosition"),extra=_$jscomp$0("tickExtra"));var JSCompiler_object_inline_extra_2838=extra;var JSCompiler_object_inline_band_2839=band$jscomp$0;var JSCompiler_object_inline_offset_2840=offset$jscomp$0;const datum={scale:_$jscomp$1.scale,ticks:!!_$jscomp$0("ticks"),labels:!!_$jscomp$0("labels"),grid:!!_$jscomp$0("grid"),domain:!!_$jscomp$0("domain"),title:null!=_$jscomp$1.title},dataRef=ref$jscomp$0(scope.add(Collect({},
[datum]))),ticksRef=ref$jscomp$0(scope.add(AxisTicks({scale:scope.scaleRef(_$jscomp$1.scale),extra:scope.property(JSCompiler_object_inline_extra_2838),count:scope.objectProperty(_$jscomp$1.tickCount),values:scope.objectProperty(_$jscomp$1.values),minstep:scope.property(_$jscomp$1.tickMinStep),formatType:scope.property(_$jscomp$1.formatType),formatSpecifier:scope.property(_$jscomp$1.format)}))),children=[];let size;if(datum.grid){var JSCompiler_temp_const$jscomp$1=children.push,userEncode=encode$jscomp$0.grid;
const _=lookup$jscomp$0(_$jscomp$1,JSCompiler_inline_result$jscomp$0),orient=_$jscomp$1.orient,vscale=_$jscomp$1.gridScale,sign=getSign(orient,1,-1);a:{var offset$jscomp$1=_$jscomp$1.offset,sign$jscomp$0=sign;if(1!==sign$jscomp$0)if(vegaUtil.isObject(offset$jscomp$1)){let entry=offset$jscomp$1=vegaUtil.extend({},offset$jscomp$1);for(;null!=entry.mult;)if(vegaUtil.isObject(entry.mult))entry=entry.mult=vegaUtil.extend({},entry.mult);else{entry.mult=isSignal(sign$jscomp$0)?{signal:`(${entry.mult}) * (${sign$jscomp$0.signal})`}:
entry.mult*sign$jscomp$0;var JSCompiler_inline_result$jscomp$1=offset$jscomp$1;break a}entry.mult=sign$jscomp$0}else offset$jscomp$1=isSignal(sign$jscomp$0)?{signal:`(${sign$jscomp$0.signal}) * (${offset$jscomp$1||0})`}:sign$jscomp$0*(offset$jscomp$1||0);JSCompiler_inline_result$jscomp$1=offset$jscomp$1}const offset=JSCompiler_inline_result$jscomp$1;let enter,exit,update;const encode={enter:enter={opacity:zero$jscomp$0},update:update={opacity:one},exit:exit={opacity:zero$jscomp$0}};addEncoders(encode,
{stroke:_("gridColor"),strokeCap:_("gridCap"),strokeDash:_("gridDash"),strokeDashOffset:_("gridDashOffset"),strokeOpacity:_("gridOpacity"),strokeWidth:_("gridWidth")});const tickPos={scale:_$jscomp$1.scale,field:"value",band:JSCompiler_object_inline_band_2839,extra:JSCompiler_object_inline_extra_2838,offset:JSCompiler_object_inline_offset_2840,round:_("tickRound")},sz=ifX(orient,{signal:"height"},{signal:"width"}),gridStart=vscale?{scale:vscale,range:0,mult:sign,offset}:{value:0,offset},gridEnd=vscale?
{scale:vscale,range:1,mult:sign,offset}:vegaUtil.extend(sz,{mult:sign,offset});enter.x=update.x=ifX(orient,tickPos,gridStart);enter.y=update.y=ifY(orient,tickPos,gridStart);enter.x2=update.x2=ifY(orient,gridEnd);enter.y2=update.y2=ifX(orient,gridEnd);exit.x=ifX(orient,tickPos);exit.y=ifY(orient,tickPos);var JSCompiler_inline_result$jscomp$2=guideMark({type:"rule",role:"axis-grid",key:"value",from:ticksRef,encode},userEncode);JSCompiler_temp_const$jscomp$1.call(children,JSCompiler_inline_result$jscomp$2)}if(datum.ticks){size=
_$jscomp$0("tickSize");var JSCompiler_temp_const$jscomp$2=children.push,userEncode$jscomp$0=encode$jscomp$0.ticks,size$jscomp$0=size;const _=lookup$jscomp$0(_$jscomp$1,JSCompiler_inline_result$jscomp$0),orient=_$jscomp$1.orient,sign=getSign(orient,-1,1);let enter,exit,update;const encode={enter:enter={opacity:zero$jscomp$0},update:update={opacity:one},exit:exit={opacity:zero$jscomp$0}};addEncoders(encode,{stroke:_("tickColor"),strokeCap:_("tickCap"),strokeDash:_("tickDash"),strokeDashOffset:_("tickDashOffset"),
strokeOpacity:_("tickOpacity"),strokeWidth:_("tickWidth")});const tickSize=encoder(size$jscomp$0);tickSize.mult=sign;const tickPos={scale:_$jscomp$1.scale,field:"value",band:JSCompiler_object_inline_band_2839,extra:JSCompiler_object_inline_extra_2838,offset:JSCompiler_object_inline_offset_2840,round:_("tickRound")};update.y=enter.y=ifX(orient,zero$jscomp$0,tickPos);update.y2=enter.y2=ifX(orient,tickSize);exit.x=ifX(orient,tickPos);update.x=enter.x=ifY(orient,zero$jscomp$0,tickPos);update.x2=enter.x2=
ifY(orient,tickSize);exit.y=ifY(orient,tickPos);var JSCompiler_inline_result$jscomp$3=guideMark({type:"rule",role:"axis-tick",key:"value",from:ticksRef,encode},userEncode$jscomp$0);JSCompiler_temp_const$jscomp$2.call(children,JSCompiler_inline_result$jscomp$3)}if(datum.labels){size=datum.ticks?size:0;var JSCompiler_temp_const$jscomp$3=children.push,userEncode$jscomp$1=encode$jscomp$0.labels,size$jscomp$1=size;const _=lookup$jscomp$0(_$jscomp$1,JSCompiler_inline_result$jscomp$0),orient=_$jscomp$1.orient,
scale=_$jscomp$1.scale,sign=getSign(orient,-1,1),flush=deref(_("labelFlush")),flushOffset=deref(_("labelFlushOffset")),labelAlign=_("labelAlign"),labelBaseline=_("labelBaseline");let flushOn=0===flush||!!flush,update;const tickSize=encoder(size$jscomp$1);tickSize.mult=sign;tickSize.offset=encoder(_("labelPadding")||0);tickSize.offset.mult=sign;const tickPos={scale,field:"value",band:.5,offset:extendOffset(JSCompiler_object_inline_offset_2840,_("labelOffset"))};var JSCompiler_temp_const$jscomp$4=flushOn?
flushExpr(scale,flush,'"left"','"right"','"center"'):{value:"center"},orient$jscomp$1=orient;var JSCompiler_inline_result$jscomp$4=isSignal(orient$jscomp$1)?ifExpr(`${orient$jscomp$1.signal} === '${"right"}'`,"left","right"):"right"===orient$jscomp$1?{value:"left"}:{value:"right"};const align=ifX(orient,JSCompiler_temp_const$jscomp$4,JSCompiler_inline_result$jscomp$4),baseline=ifX(orient,ifTop(orient,"bottom","top"),flushOn?flushExpr(scale,flush,'"top"','"bottom"','"middle"'):{value:"middle"}),offsetExpr=
flushExpr(scale,flush,`-(${flushOffset})`,flushOffset,0);flushOn=flushOn&&flushOffset;const enter={opacity:zero$jscomp$0,x:ifX(orient,tickPos,tickSize),y:ifY(orient,tickPos,tickSize)},encode={enter,update:update={opacity:one,text:{field:"label"},x:enter.x,y:enter.y,align,baseline},exit:{opacity:zero$jscomp$0,x:enter.x,y:enter.y}};addEncoders(encode,{dx:!labelAlign&&flushOn?ifX(orient,offsetExpr):null,dy:!labelBaseline&&flushOn?ifY(orient,offsetExpr):null});addEncoders(encode,{angle:_("labelAngle"),
fill:_("labelColor"),fillOpacity:_("labelOpacity"),font:_("labelFont"),fontSize:_("labelFontSize"),fontWeight:_("labelFontWeight"),fontStyle:_("labelFontStyle"),limit:_("labelLimit"),lineHeight:_("labelLineHeight")},{align:labelAlign,baseline:labelBaseline});const bound=_("labelBound");let overlap=_("labelOverlap");overlap=overlap||bound?{separation:_("labelSeparation"),method:overlap,order:"datum.index",bound:bound?{scale,orient,tolerance:bound}:null}:void 0;update.align!==align&&(update.align=patch(update.align,
align));update.baseline!==baseline&&(update.baseline=patch(update.baseline,baseline));var JSCompiler_inline_result$jscomp$5=guideMark({type:"text",role:"axis-label",style:"guide-label",key:"value",from:ticksRef,encode,overlap},userEncode$jscomp$1);JSCompiler_temp_const$jscomp$3.call(children,JSCompiler_inline_result$jscomp$5)}if(datum.domain){var JSCompiler_temp_const$jscomp$5=children.push,userEncode$jscomp$2=encode$jscomp$0.domain;const _=lookup$jscomp$0(_$jscomp$1,JSCompiler_inline_result$jscomp$0),
orient=_$jscomp$1.orient;let enter,update;const encode={enter:enter={opacity:zero$jscomp$0},update:update={opacity:one},exit:{opacity:zero$jscomp$0}};addEncoders(encode,{stroke:_("domainColor"),strokeCap:_("domainCap"),strokeDash:_("domainDash"),strokeDashOffset:_("domainDashOffset"),strokeWidth:_("domainWidth"),strokeOpacity:_("domainOpacity")});const pos0={scale:_$jscomp$1.scale,range:0},pos1={scale:_$jscomp$1.scale,range:1};enter.x=update.x=ifX(orient,pos0,zero$jscomp$0);enter.x2=update.x2=ifX(orient,
pos1);enter.y=update.y=ifY(orient,pos0,zero$jscomp$0);enter.y2=update.y2=ifY(orient,pos1);var JSCompiler_inline_result$jscomp$6=guideMark({type:"rule",role:"axis-domain",from:dataRef,encode},userEncode$jscomp$2);JSCompiler_temp_const$jscomp$5.call(children,JSCompiler_inline_result$jscomp$6)}if(datum.title){var JSCompiler_temp_const$jscomp$6=children.push,userEncode$jscomp$3=encode$jscomp$0.title;const _=lookup$jscomp$0(_$jscomp$1,JSCompiler_inline_result$jscomp$0),orient=_$jscomp$1.orient,sign=getSign(orient,
-1,1);let enter,update;const encode={enter:enter={opacity:zero$jscomp$0,anchor:encoder(_("titleAnchor",null)),align:{signal:alignExpr$1}},update:update=vegaUtil.extend({},enter,{opacity:one,text:encoder(_$jscomp$1.title)}),exit:{opacity:zero$jscomp$0}},titlePos={signal:`lerp(range("${_$jscomp$1.scale}"), ${anchorExpr(0,1,.5)})`};update.x=ifX(orient,titlePos);update.y=ifY(orient,titlePos);var JSCompiler_temp_const$jscomp$7=enter,sign$jscomp$1=sign;var JSCompiler_inline_result$jscomp$7=isSignal(sign$jscomp$1)?
{signal:`(${sign$jscomp$1.signal}) * ${90}`}:{value:90*sign$jscomp$1};JSCompiler_temp_const$jscomp$7.angle=ifX(orient,zero$jscomp$0,JSCompiler_inline_result$jscomp$7);enter.baseline=ifX(orient,ifTop(orient,"bottom","top"),{value:"bottom"});update.angle=enter.angle;update.baseline=enter.baseline;addEncoders(encode,{fill:_("titleColor"),fillOpacity:_("titleOpacity"),font:_("titleFont"),fontSize:_("titleFontSize"),fontStyle:_("titleFontStyle"),fontWeight:_("titleFontWeight"),limit:_("titleLimit"),lineHeight:_("titleLineHeight")},
{align:_("titleAlign"),angle:_("titleAngle"),baseline:_("titleBaseline")});autoLayout(_,orient,encode,userEncode$jscomp$3);encode.update.align=patch(encode.update.align,enter.align);encode.update.angle=patch(encode.update.angle,enter.angle);encode.update.baseline=patch(encode.update.baseline,enter.baseline);var JSCompiler_inline_result$jscomp$8=guideMark({type:"text",role:"axis-title",style:"guide-title",from:dataRef,encode},userEncode$jscomp$3);JSCompiler_temp_const$jscomp$6.call(children,JSCompiler_inline_result$jscomp$8)}const encode$jscomp$1=
{enter:{},update:{}};addEncoders(encode$jscomp$1,{orient:_$jscomp$0("orient"),offset:_$jscomp$0("offset")||0,position:value$jscomp$0(_$jscomp$1.position,0),titlePadding:_$jscomp$0("titlePadding"),minExtent:_$jscomp$0("minExtent"),maxExtent:_$jscomp$0("maxExtent"),range:{signal:`abs(span(range("${_$jscomp$1.scale}")))`},translate:_$jscomp$0("translate"),format:_$jscomp$1.format,formatType:_$jscomp$1.formatType});return parseMark(guideGroup({role:"axis",from:dataRef,encode:extendEncode(encode$jscomp$1,
axisEncode,Skip),marks:children,aria:_$jscomp$0("aria"),description:_$jscomp$0("description"),zindex:_$jscomp$0("zindex"),name,interactive,style:style$jscomp$0}),scope)});vegaUtil.array(spec.marks).forEach(_=>parseMark(_,scope));vegaUtil.array(spec.legends).forEach(_=>parseLegend(_,scope));spec.title&&parseTitle(spec.title,scope);scope.parseLambdas();return scope}function parseView(spec,scope){var config=scope.config;const root=ref$jscomp$0(scope.root=scope.add(new Entry("operator",void 0,void 0,
void 0))),signals=collectSignals(spec,config);signals.forEach(_=>parseSignal(_,scope));scope.description=spec.description||config.description;scope.eventConfig=config.events;scope.legends=scope.objectProperty(config.legend&&config.legend.layout);scope.locale=config.locale;config=scope.add(Collect());const encode=scope.add(Encode(parseEncode(extendEncode({enter:{x:{value:0},y:{value:0}},update:{width:{signal:"width"},height:{signal:"height"}}},spec.encode),"group","frame",spec.style,scope,{pulse:ref$jscomp$0(config)}))),
parent=scope.add(ViewLayout({layout:scope.objectProperty(spec.layout),legends:scope.legends,autosize:scope.signalRef("autosize"),mark:root,pulse:ref$jscomp$0(encode)}));scope.operators.pop();scope.pushState(ref$jscomp$0(encode),ref$jscomp$0(parent),null);parseScope(spec,scope,signals);scope.operators.push(parent);spec=scope.add(Bound({mark:root,pulse:ref$jscomp$0(parent)}));spec=scope.add(Render({pulse:ref$jscomp$0(spec)}));spec=scope.add(Sieve({pulse:ref$jscomp$0(spec)}));scope.addData("root",new DataScope(scope,
config,config,spec));return scope}function signalObject(name,value){return value&&value.signal?{name,update:value.signal}:{name,value}}function collectSignals(spec,config){const _=name=>value$jscomp$0(spec[name],config[name]),signals=[signalObject("background",_("background")),signalObject("autosize",parseAutosize(_("autosize"))),signalObject("padding",parsePadding(_("padding"))),signalObject("width",_("width")||0),signalObject("height",_("height")||0)],pre=signals.reduce((p,s)=>(p[s.name]=s,p),{}),
map={};vegaUtil.array(spec.signals).forEach(s=>{vegaUtil.hasOwnProperty(pre,s.name)?s=vegaUtil.extend(pre[s.name],s):signals.push(s);map[s.name]=s});vegaUtil.array(config.signals).forEach(s=>{vegaUtil.hasOwnProperty(map,s.name)||vegaUtil.hasOwnProperty(pre,s.name)||signals.push(s)});return signals}function Scope(config,options){this.config=config||{};this.options=options||{};this.bindings=[];this.field={};this.signals={};this.lambdas={};this.scales={};this.events={};this.data={};this.streams=[];this.updates=
[];this.operators=[];this.locale=this.eventConfig=null;this._subid=this._id=0;this._nextsub=[0];this._parent=[];this._encode=[];this._lookup=[];this._markpath=[]}function Subscope(scope){this.config=scope.config;this.options=scope.options;this.legends=scope.legends;this.field=Object.create(scope.field);this.signals=Object.create(scope.signals);this.lambdas=Object.create(scope.lambdas);this.scales=Object.create(scope.scales);this.events=Object.create(scope.events);this.data=Object.create(scope.data);
this.streams=[];this.updates=[];this.operators=[];this._id=0;this._subid=++scope._nextsub[0];this._nextsub=scope._nextsub;this._parent=scope._parent.slice();this._encode=scope._encode.slice();this._lookup=scope._lookup.slice();this._markpath=scope._markpath}function propertyLambda(spec){return(vegaUtil.isArray(spec)?arrayLambda:objectLambda)(spec)}function arrayLambda(array){const n=array.length;let code="[";for(let i=0;i<n;++i){const value=array[i];code+=(0<i?",":"")+(vegaUtil.isObject(value)?value.signal||
propertyLambda(value):vegaUtil.stringValue(value))}return code+"]"}function objectLambda(obj){let code="{",i=0,key,value;for(key in obj)value=obj[key],code+=(1<++i?",":"")+vegaUtil.stringValue(key)+":"+(vegaUtil.isObject(value)?value.signal||propertyLambda(value):vegaUtil.stringValue(value));return code+"}"}function defaults(){return{description:"Vega visualization",padding:0,autosize:"pad",background:null,events:{defaults:{allow:["wheel"]}},group:null,mark:null,arc:{fill:"#4c78a8"},area:{fill:"#4c78a8"},
image:null,line:{stroke:"#4c78a8",strokeWidth:2},path:{stroke:"#4c78a8"},rect:{fill:"#4c78a8"},rule:{stroke:"#000"},shape:{stroke:"#4c78a8"},symbol:{fill:"#4c78a8",size:64},text:{fill:"#000",font:"sans-serif",fontSize:11},trail:{fill:"#4c78a8",size:2},style:{"guide-label":{fill:"#000",font:"sans-serif",fontSize:10},"guide-title":{fill:"#000",font:"sans-serif",fontSize:11,fontWeight:"bold"},"group-title":{fill:"#000",font:"sans-serif",fontSize:13,fontWeight:"bold"},"group-subtitle":{fill:"#000",font:"sans-serif",
fontSize:12},point:{size:30,strokeWidth:2,shape:"circle"},circle:{size:30,strokeWidth:2},square:{size:30,strokeWidth:2,shape:"square"},cell:{fill:"transparent",stroke:"#ddd"}},title:{orient:"top",anchor:"middle",offset:4,subtitlePadding:3},axis:{minExtent:0,maxExtent:200,bandPosition:.5,domain:!0,domainWidth:1,domainColor:"#888",grid:!1,gridWidth:1,gridColor:"#ddd",labels:!0,labelAngle:0,labelLimit:180,labelOffset:0,labelPadding:2,ticks:!0,tickColor:"#888",tickOffset:0,tickRound:!0,tickSize:5,tickWidth:1,
titlePadding:4},axisBand:{tickOffset:-.5},projection:{type:"mercator"},legend:{orient:"right",padding:0,gridAlign:"each",columnPadding:10,rowPadding:2,symbolDirection:"vertical",gradientDirection:"vertical",gradientLength:200,gradientThickness:16,gradientStrokeColor:"#ddd",gradientStrokeWidth:0,gradientLabelOffset:2,labelAlign:"left",labelBaseline:"middle",labelLimit:160,labelOffset:4,labelOverlap:!0,symbolLimit:30,symbolType:"circle",symbolSize:100,symbolOffset:0,symbolStrokeWidth:1.5,symbolBaseFillColor:"transparent",
symbolBaseStrokeColor:"#888",titleLimit:180,titleOrient:"top",titlePadding:5,layout:{offset:18,direction:"horizontal",left:{direction:"vertical"},right:{direction:"vertical"}}},range:{category:{scheme:"tableau10"},ordinal:{scheme:"blues"},heatmap:{scheme:"yellowgreenblue"},ramp:{scheme:"blues"},diverging:{scheme:"blueorange",extent:[1,0]},symbol:"circle square triangle-up cross diamond triangle-right triangle-down triangle-left".split(" ")}}}const encoder=_=>vegaUtil.isObject(_)&&!vegaUtil.isArray(_)?
vegaUtil.extend({},_):{value:_},scaleRef=scale=>vegaUtil.isString(scale)?vegaUtil.stringValue(scale):scale.signal?`(${scale.signal})`:field$jscomp$0(scale),_color=(type,x,y,z)=>`(${type}(${[x,y,z].map(entry$1).join(",")})+'')`,OUTER_INVALID=["value","update","init","react","bind"],keyFieldRef=fieldRef$1("key"),OP_VALUE_EXPR={code:"_.$value",ast:{type:"Identifier",value:"value"}},transform$jscomp$0=name=>(params,value,parent)=>new Entry(name,value,params||void 0,parent),Aggregate=transform$jscomp$0("aggregate"),
AxisTicks=transform$jscomp$0("axisticks"),Bound=transform$jscomp$0("bound"),Collect=transform$jscomp$0("collect"),Compare=transform$jscomp$0("compare"),DataJoin=transform$jscomp$0("datajoin"),Encode=transform$jscomp$0("encode"),Expression=transform$jscomp$0("expression"),Facet=transform$jscomp$0("facet"),Field=transform$jscomp$0("field"),Key=transform$jscomp$0("key"),LegendEntries=transform$jscomp$0("legendentries"),Load=transform$jscomp$0("load"),Mark=transform$jscomp$0("mark"),MultiExtent=transform$jscomp$0("multiextent"),
MultiValues=transform$jscomp$0("multivalues"),Overlap=transform$jscomp$0("overlap"),Params=transform$jscomp$0("params"),PreFacet=transform$jscomp$0("prefacet"),Projection=transform$jscomp$0("projection"),Proxy=transform$jscomp$0("proxy"),Relay=transform$jscomp$0("relay"),Render=transform$jscomp$0("render"),Scale=transform$jscomp$0("scale"),Sieve=transform$jscomp$0("sieve"),SortItems=transform$jscomp$0("sortitems"),ViewLayout=transform$jscomp$0("viewlayout"),Values=transform$jscomp$0("values");let FIELD_REF_ID=
0;const MULTIDOMAIN_SORT_OPS={min:"min",max:"max",count:"sum"},LegendScales="size shape fill stroke strokeWidth strokeDash opacity".split(" "),Skip={name:1,style:1,interactive:1},zero$jscomp$0={value:0},one={value:1},alignExpr$1=anchorExpr(vegaUtil.stringValue("left"),vegaUtil.stringValue("right"),vegaUtil.stringValue("center")),baseline$jscomp$0=anchorExpr('"top"','"bottom"','"middle"'),exprAlign=`datum.vgrad && ${'item.orient \x3d\x3d\x3d "right"'} ? (${anchorExpr('"right"','"left"','"center"')}) : (${'(item.orient \x3d\x3d\x3d "left" || item.orient \x3d\x3d\x3d "right")'} && !(datum.vgrad && ${'item.orient \x3d\x3d\x3d "left"'})) ? "left" : ${alignExpr$1}`,
exprBaseline=`${'(item.orient \x3d\x3d\x3d "left" || item.orient \x3d\x3d\x3d "right")'} ? (datum.vgrad ? (${'item.orient \x3d\x3d\x3d "right"'} ? "bottom" : "top") : ${baseline$jscomp$0}) : "top"`;DataScope.fromEntries=function(scope,entries){const n=entries.length,values=entries[n-1],output=entries[n-2];let input=entries[0],aggr=null,i=1;input&&"load"===input.type&&(input=entries[1]);for(scope.add(entries[0]);i<n;++i)entries[i].params.pulse=ref$jscomp$0(entries[i-1]),scope.add(entries[i]),"aggregate"===
entries[i].type&&(aggr=entries[i]);return new DataScope(scope,input,output,values,aggr)};DataScope.prototype={countsRef(scope,field,sort){const cache=this.counts||(this.counts={}),k=fieldKey(field);if(null!=k){scope=this.scope;var v=cache[k]}v?sort&&sort.field&&addSortField(scope,v.agg.params,sort):(v={groupby:scope.fieldRef(field,"key"),pulse:ref$jscomp$0(this.output)},sort&&sort.field&&addSortField(scope,v,sort),sort=scope.add(Aggregate(v)),v=scope.add(Collect({pulse:ref$jscomp$0(sort)})),v={agg:sort,
ref:ref$jscomp$0(v)},null!=k&&(cache[k]=v));return v.ref},tuplesRef(){return ref$jscomp$0(this.values)},extentRef(scope,field){return cache$jscomp$0(scope,this,"extent","extent",field,!1)},domainRef(scope,field){return cache$jscomp$0(scope,this,"domain","values",field,!1)},valuesRef(scope,field,sort){return cache$jscomp$0(scope,this,"vals","values",field,sort||!0)},lookupRef(scope,field){return cache$jscomp$0(scope,this,"lookup","tupleindex",field,!1)},indataRef(scope,field){return cache$jscomp$0(scope,
this,"indata","tupleindex",field,!0,!0)}};const getSign=(orient,a,b)=>{isSignal(orient)?(orient=orient.signal,a=ifExpr(`${orient} === '${"left"}' || ${orient} === '${"top"}'`,a,b)):a="left"===orient||"top"===orient?a:b;return a},ifX=(orient,a,b)=>{isSignal(orient)?(orient=orient.signal,a=ifEnc(`${orient} === '${"top"}' || ${orient} === '${"bottom"}'`,a,b)):a="bottom"===orient||"top"===orient?a:b;return a},ifY=(orient,a,b)=>{isSignal(orient)?(orient=orient.signal,a=ifEnc(`${orient} !== '${"top"}' && ${orient} !== '${"bottom"}'`,
a,b)):a="bottom"===orient||"top"===orient?b:a;return a},ifTop=(orient,a,b)=>isSignal(orient)?ifExpr(`${orient.signal} === '${"top"}'`,a,b):"top"===orient?{value:a}:{value:b},ifEnc=(test,a,b)=>{a=null!=a?encoder(a):a;b=null!=b?encoder(b):b;if(null!=a&&1!==Object.keys(a).length||null!=b&&1!==Object.keys(b).length)return[vegaUtil.extend({test},a)].concat(b||[]);a=a?a.signal||vegaUtil.stringValue(a.value):null;b=b?b.signal||vegaUtil.stringValue(b.value):null;return{signal:`${test} ? (${a}) : (${b})`}},
ifExpr=(test,a,b)=>({signal:`${test} ? (${toExpr(a)}) : (${toExpr(b)})`}),toExpr=v=>isSignal(v)?v.signal:null==v?null:vegaUtil.stringValue(v),patch=(value,base)=>{const s=value.signal;return s&&s.endsWith("(null)")?{signal:s.slice(0,-6)+base.signal}:value};Scope.prototype=Subscope.prototype={parse(spec){return parseScope(spec,this)},fork(){return new Subscope(this)},isSubscope(){return 0<this._subid},toRuntime(){this.finish();return{description:this.description,operators:this.operators,streams:this.streams,
updates:this.updates,bindings:this.bindings,eventConfig:this.eventConfig,locale:this.locale}},id(){return(this._subid?this._subid+":":0)+this._id++},add(op){this.operators.push(op);op.id=this.id();op.refs&&(op.refs.forEach(ref=>{ref.$ref=op.id}),op.refs=null);return op},proxy(op){op=op instanceof Entry?ref$jscomp$0(op):op;return this.add(Proxy({value:op}))},addStream(stream){this.streams.push(stream);stream.id=this.id();return stream},addUpdate(update){this.updates.push(update);return update},finish(){function annotate(op,
name,type){op&&(op=op.data||(op.data={}),name=op[name]||(op[name]=[]),name.push(type))}let name$jscomp$0,ds;this.root&&(this.root.root=!0);for(name$jscomp$0 in this.signals)this.signals[name$jscomp$0].signal=name$jscomp$0;for(name$jscomp$0 in this.scales)this.scales[name$jscomp$0].scale=name$jscomp$0;for(name$jscomp$0 in this.data){ds=this.data[name$jscomp$0];annotate(ds.input,name$jscomp$0,"input");annotate(ds.output,name$jscomp$0,"output");annotate(ds.values,name$jscomp$0,"values");for(const field in ds.index)annotate(ds.index[field],
name$jscomp$0,"index:"+field)}return this},pushState(encode,parent,lookup){this._encode.push(ref$jscomp$0(this.add(Sieve({pulse:encode}))));this._parent.push(parent);this._lookup.push(lookup?ref$jscomp$0(this.proxy(lookup)):null);this._markpath.push(-1)},popState(){this._encode.pop();this._parent.pop();this._lookup.pop();this._markpath.pop()},parent(){return vegaUtil.peek(this._parent)},encode(){return vegaUtil.peek(this._encode)},lookup(){return vegaUtil.peek(this._lookup)},markpath(){const p=this._markpath;
return++p[p.length-1]},fieldRef(field,name){if(vegaUtil.isString(field))return fieldRef$1(field,name);field.signal||vegaUtil.error("Unsupported field reference: "+vegaUtil.stringValue(field));field=field.signal;var f=this.field[field];f||(f={name:this.signalRef(field)},name&&(f.as=name),this.field[field]=f=ref$jscomp$0(this.add(Field(f))));return f},compareRef(cmp){let signal=!1;const check=_=>isSignal(_)?(signal=!0,this.signalRef(_.signal)):_&&_.expr?(signal=!0,this.exprRef(_.expr)):_,fields=vegaUtil.array(cmp.field).map(check);
cmp=vegaUtil.array(cmp.order).map(check);return signal?ref$jscomp$0(this.add(Compare({fields,orders:cmp}))):{$compare:fields,$order:cmp}},keyRef(fields,flat){let signal=!1;const sig=this.signals;fields=vegaUtil.array(fields).map(_=>isSignal(_)?(signal=!0,ref$jscomp$0(sig[_.signal])):_);return signal?ref$jscomp$0(this.add(Key({fields,flat}))):keyRef(fields,flat)},sortRef(sort){if(!sort)return sort;const a=aggrField(sort.op,sort.field);sort=sort.order||"ascending";return sort.signal?ref$jscomp$0(this.add(Compare({fields:a,
orders:this.signalRef(sort.signal)}))):{$compare:a,$order:sort}},event(source,type){const key=source+":"+type;if(!this.events[key]){const id=this.id();this.streams.push({id,source,type});this.events[key]=id}return this.events[key]},hasOwnSignal(name){return vegaUtil.hasOwnProperty(this.signals,name)},addSignal(name,value){this.hasOwnSignal(name)&&vegaUtil.error("Duplicate signal name: "+vegaUtil.stringValue(name));value=value instanceof Entry?value:this.add(new Entry("operator",value,void 0,void 0));
return this.signals[name]=value},getSignal(name){this.signals[name]||vegaUtil.error("Unrecognized signal name: "+vegaUtil.stringValue(name));return this.signals[name]},signalRef(s){if(this.signals[s])return ref$jscomp$0(this.signals[s]);vegaUtil.hasOwnProperty(this.lambdas,s)||(this.lambdas[s]=this.add(new Entry("operator",null,void 0,void 0)));return ref$jscomp$0(this.lambdas[s])},parseLambdas(){const code=Object.keys(this.lambdas);for(let i=0,n=code.length;i<n;++i){var s=code[i];const e=vegaFunctions.parseExpression(s,
this);s=this.lambdas[s];s.params=e.$params;s.update=e.$expr}},property(spec){return spec&&spec.signal?this.signalRef(spec.signal):spec},objectProperty(spec){return spec&&vegaUtil.isObject(spec)?this.signalRef(spec.signal||propertyLambda(spec)):spec},exprRef(code,name){code={expr:vegaFunctions.parseExpression(code,this)};name&&(code.expr.$name=name);return ref$jscomp$0(this.add(Expression(code)))},addBinding(name,bind){this.bindings||vegaUtil.error("Nested signals do not support binding: "+vegaUtil.stringValue(name));
this.bindings.push(vegaUtil.extend({signal:name},bind))},addScaleProj(name,transform){vegaUtil.hasOwnProperty(this.scales,name)&&vegaUtil.error("Duplicate scale or projection name: "+vegaUtil.stringValue(name));this.scales[name]=this.add(transform)},addScale(name,params){this.addScaleProj(name,Scale(params))},addProjection(name,params){this.addScaleProj(name,Projection(params))},getScale(name){this.scales[name]||vegaUtil.error("Unrecognized scale name: "+vegaUtil.stringValue(name));return this.scales[name]},
scaleRef(name){return ref$jscomp$0(this.getScale(name))},scaleType(name){return this.getScale(name).params.type},projectionRef(name){return this.scaleRef(name)},projectionType(name){return this.scaleType(name)},addData(name,dataScope){vegaUtil.hasOwnProperty(this.data,name)&&vegaUtil.error("Duplicate data set name: "+vegaUtil.stringValue(name));return this.data[name]=dataScope},getData(name){this.data[name]||vegaUtil.error("Undefined data set name: "+vegaUtil.stringValue(name));return this.data[name]},
addDataPipeline(name,entries){vegaUtil.hasOwnProperty(this.data,name)&&vegaUtil.error("Duplicate data set name: "+vegaUtil.stringValue(name));return this.addData(name,DataScope.fromEntries(this,entries))}};exports.AxisDomainRole="axis-domain";exports.AxisGridRole="axis-grid";exports.AxisLabelRole="axis-label";exports.AxisRole="axis";exports.AxisTickRole="axis-tick";exports.AxisTitleRole="axis-title";exports.DataScope=DataScope;exports.FrameRole="frame";exports.LegendEntryRole="legend-entry";exports.LegendLabelRole=
"legend-label";exports.LegendRole="legend";exports.LegendSymbolRole="legend-symbol";exports.LegendTitleRole="legend-title";exports.MarkRole="mark";exports.Scope=Scope;exports.ScopeRole="scope";exports.config=defaults;exports.parse=function(spec,config,options){vegaUtil.isObject(spec)||vegaUtil.error("Input Vega specification must be an object.");config=vegaUtil.mergeConfig(defaults(),config,spec.config);return parseView(spec,new Scope(config,options)).toRuntime()};exports.signal=parseSignal;exports.signalUpdates=
parseSignalUpdates;exports.stream=parseStream;Object.defineProperty(exports,"__esModule",{value:!0})})}
//# sourceMappingURL=module$node_modules$vega_parser$build$vega_parser.js.map
