{
"version":3,
"file":"module$node_modules$csv_stringify$lib$index.js",
"lineCount":27,
"mappings":"AAAAA,cAAA,CAAA,2CAAA,CAAgE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CACxG,IAAIC,OAASH,OAAA,CAAQ,kCAAR,CAAkBG,CAAAA,MAC/B,aAEAC,OAAOC,CAAAA,cAAP,CAAsBH,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CI,MAAO,CAAA,CADoC,CAA7C,CAGAJ,QAAQK,CAAAA,WAAR,CAAsBL,OAAQM,CAAAA,QAA9B,CAAyCN,OAAQO,CAAAA,SAAjD,CAA6D,IAAK,EAE9DC,OAAAA,CAAUV,OAAA,CAAQ,6CAAR,CAQd,OAAMW,SAAWR,MAAOS,CAAAA,IAAP,CAAY,CAAC,GAAD,CAAM,GAAN,CAAW,GAAX,CAAZ,CAEjB,MAAMJ,SAAN,QAAuBK,MAAvB,CACEC,WAAW,CAACC,IAAD,CAAOC,OAAP,CAAgB,GAAGC,QAAnB,CAA6B,CAClCC,KAAMC,CAAAA,OAAN,CAAcH,OAAd,CAAJ,GAA4BA,OAA5B,CAAsCA,OAAQI,CAAAA,IAAR,CAAa,GAAb,CAAtC,CACA;KAAA,CAAMJ,OAAN,CAEgCK,KAAAA,EAAhC,GAAIR,KAAMS,CAAAA,iBAAV,EACET,KAAMS,CAAAA,iBAAN,CAAwB,IAAxB,CAA8Bd,QAA9B,CAGF,KAAKO,CAAAA,IAAL,CAAYA,IAEZ,KAAK,MAAMQ,OAAX,GAAsBN,SAAtB,CACE,IAAK,MAAMO,GAAX,GAAkBD,QAAlB,CACQjB,IACN,CADciB,OAAA,CAAQC,GAAR,CACd,CAAA,IAAA,CAAKA,GAAL,CAAA,CAAYrB,MAAOsB,CAAAA,QAAP,CAAgBnB,IAAhB,CAAA,CAAyBA,IAAMoB,CAAAA,QAAN,EAAzB,CAAqD,IAAT,EAAApB,IAAA,CAAgBA,IAAhB,CAAwBqB,IAAKC,CAAAA,KAAL,CAAWD,IAAKlB,CAAAA,SAAL,CAAeH,IAAf,CAAX,CAb9C,CAD1C,CAqBAJ,OAAQM,CAAAA,QAAR,CAAmBA,QAEnB,OAAMqB,SAAWA,QAAS,CAACC,GAAD,CAAM,CAC9B,MAAsB,QAAtB,GAAO,MAAOA,IAAd,EAA0C,IAA1C,GAAkCA,GAAlC,EAAkD,CAACZ,KAAMC,CAAAA,OAAN,CAAcW,GAAd,CADrB,CAAhC,CAIMC,WAAaA,QAAS,CAACC,GAAD,CAAM,CAChC,MAAOA,IAAIC,CAAAA,OAAJ,CAAY,UAAZ,CAAwB,QAAS,CAACC,CAAD,CAAIC,KAAJ,CAAW,CACjD,MAAO,GAAP,CAAaA,KAAMC,CAAAA,WAAN,EADoC,CAA5C,CADyB,CAJlC,CAYMC;AAAe,UAZrB,CAaMC,WAAaC,MAAA,CACnB,gHADmB,CAKmB,GALnB,CAbnB,CAmBMC,aAAe,kDAnBrB,CAoBMC,cAAgB,OApBtB,CA2BMC,SAAWA,QAAS,CAACpC,KAAD,CAAQ,CAChC,IAAMqC,KAAO,MAAOrC,MAApB,CACO,eAAA,IAAA,EAAA,eAAA,CAAA,QAAA,GAAA,IAAA,CAAA,CAAA,CAAqB,GAAA,IAAA,CAAA,QAAA,GAAA,IAAA,EAAA,KAAA,CAAAA,KAAA,GANNe,IAAAA,EAAV,GAMgBf,KANhB,CAAsB,oBAAtB,CAA6C,eAM7B,EAAA,IAAA,CAAA,iBAAA,GALrBF,MAAOwC,CAAAA,SAAUlB,CAAAA,QAASmB,CAAAA,IAA1B,CAKqBvC,KALrB,CAKqB,gBAAA;AAAA,IAArB,CAAP,MAAO,gBAFyB,CA3BlC,CA8CMwC,aAAeA,QAAS,CAACC,MAAD,CAAS,CACrC,MAAMC,OAAS,EApCKC,GAsCpB,GAAIF,MAAOG,CAAAA,UAAP,CAAkB,CAAlB,CAAJ,EACEF,MAAOG,CAAAA,IAAP,CAAY,EAAZ,CAGFJ,OAAOd,CAAAA,OAAP,CAAeK,UAAf,CAA2B,QAAS,CAACH,KAAD,CAAQiB,UAAR,CAAoBC,KAApB,CAA2BC,SAA3B,CAAsC,CAGpED,KAAJ,CACE7B,KADF,CACQ8B,SAAUrB,CAAAA,OAAV,CAAkBI,YAAlB,CAAgC,IAAhC,CADR,CAEWe,UAFX,GAGE5B,KAHF,CAGQ4B,UAAWG,CAAAA,IAAX,EAHR,CAMAP,OAAOG,CAAAA,IAAP,CAAY3B,KAAZ,CATwE,CAA1E,CAWA,OAAOwB,OAlB8B,CA9CvC,CAkFMQ,IAAMA,QAAS,CAACC,eAAD,CAASC,IAAT,CAAe,CACZD,IAAAA,OAAAA,eAftB,IAAI,CAAAvC,KAAMC,CAAAA,OAAN,CAAcb,IAAd,CAAJ,CAAA,CAnCA,GAAIY,KAAMC,CAAAA,OAAN,CAsCKb,IAtCL,CAAJ,CACE,MAAA,CAAO,CAAA,CADT,KAAA,CAIA,IAAMqC,KAAO,MAkCJrC,KAhCT,OAAA,CAAa,QAAb,GAAIqC,IAAJ,EAAkC,QAAlC,GAAyBA,IAAzB,EAAuD,SAAvD;AAA8CA,IAA9C,EAAoE,CAgC3DrC,IAhCT,EAA8EoC,QAAA,CAgCrEpC,IAhCqE,CAA9E,CACS,CAAA,CADT,CAIOmC,aAAckB,CAAAA,IAAd,CA4BErD,IA5BF,CAJP,EAIoC,CAACkC,YAAamB,CAAAA,IAAb,CA4B5BrD,IA5B4B,CAJrC,EAI2E,IAJ3E,EAgCSmD,MAhCT,EAgCSnD,IAhCT,GAI4FF,OAAA,CA4BnFqD,MA5BmF,CAV5F,CAsCS,IAAA,CAAA,MAAA,CAAA,CAAA,IAAA,CAAA,CAAA,YAAA,CAAA,IAAA,CAHT,CAgBIG,MAAAA,CAAQ,CAGZ,KAFMC,IAEN,CAFeH,IAAKG,CAAAA,MAEpB,CAAiB,IAAjB,EAAOJ,eAAP,EAAyBG,MAAzB,CAAiCC,IAAjC,CAAA,CAAyC,CAZZ,CAAA,CAAA,CAaL,IAAA,yBAAAH,IAAA,CAAKE,MAAA,EAAL,CAZxB,IAAqB,QAArB,GAAI,MAAOtD,yBAAX,EAAiCoC,QAAA,CAASpC,wBAAT,CAAjC,CAAkD,MAAA,CAClD,OAAM0C,OAAS,GAAG1C,wBAAH,EAEf,yBAAA,CAAiB,GAAV,EAAA0C,MAAA,EAAiB,CAAjB,CAAqB1C,wBAArB,EAA8B,CAACwD,QAA/B,CAA0C,IAA1C,CAAiDd,MAJ3B,CAa3BS,eAAA;AAASA,eAAA,CAAO,wBAAP,CAD8B,CAIzC,MAAOG,OAAA,EAASA,MAAT,GAAmBC,IAAnB,CAA4BJ,eAA5B,CAAqCpC,IAAAA,EATV,CAYpC,MAAMd,YAAN,QAA0BG,OAAQqD,CAAAA,SAAlC,CACEjD,WAAW,CAACkD,IAAD,CAAY,CAAXA,IAAA,CAAA,IAAA,EAAA,GAAAA,IAAA,CAAO,EAAP,CAAAA,IACV,MAAA,CAAM,MAAA,CAAA,MAAA,CAAA,EAAA,CAAK,CACPC,mBAAoB,CAAA,CADb,CAAL,CAGDD,IAHC,CAAN,CAKA,OAAME,QAAU,EAGhB,KAAK,MAAMC,GAAX,GAAkBH,KAAlB,CACEE,OAAA,CAAQnC,UAAA,CAAWoC,GAAX,CAAR,CAAA,CAA2BH,IAAA,CAAKG,GAAL,CAG7B,IAAwC9C,IAAAA,EAAxC,IAAK+C,IAAL,CAAW,IAAKC,CAAAA,SAAL,CAAeH,OAAf,CAAX,EAAmD,KAAME,KAAN,CAEnD,OAAQF,OAAQI,CAAAA,gBAAhB,EACE,KAAK,MAAL,CACEJ,OAAQI,CAAAA,gBAAR,CAA2B,IAC3B,MAEF,MAAK,MAAL,CACEJ,OAAQI,CAAAA,gBAAR,CAA2B,IAC3B,MAEF,MAAK,KAAL,CACEJ,OAAQI,CAAAA,gBAAR;AAA2B,IAC3B,MAEF,MAAK,SAAL,CACEJ,OAAQI,CAAAA,gBAAR,CAA2B,MAC3B,MAEF,MAAK,OAAL,CACEJ,OAAQI,CAAAA,gBAAR,CAA2B,GAC3B,MAEF,MAAK,SAAL,CACEJ,OAAQI,CAAAA,gBAAR,CAA2B,QAtB/B,CA2BA,IAAKJ,CAAAA,OAAL,CAAeA,OAEf,KAAKK,CAAAA,KAAL,CAAa,CACXC,KAAM,CAAA,CADK,CAIb,KAAKC,CAAAA,IAAL,CAAY,CACVC,QAAS,CADC,CAhDS,CAqDvBL,SAAS,CAACH,OAAD,CAAU,CAEjB,GAAoB7C,IAAAA,EAApB,GAAI6C,OAAQS,CAAAA,GAAZ,EAAiD,IAAjD,GAAiCT,OAAQS,CAAAA,GAAzC,EAAyE,CAAA,CAAzE,GAAyDT,OAAQS,CAAAA,GAAjE,CACET,OAAQS,CAAAA,GAAR,CAAc,CAAA,CADhB,KAEO,IAAoB,CAAA,CAApB,GAAIT,OAAQS,CAAAA,GAAZ,CACL,MAAO,KAAInE,QAAJ,CAAa,iCAAb,CAAgD,CAAC,uDAAD,CAA0D,OAAOmB,IAAKlB,CAAAA,SAAL,CAAeyD,OAAQS,CAAAA,GAAvB,CAAP,EAA1D,CAAhD,CAIT,IAA0BtD,IAAAA,EAA1B;AAAI6C,OAAQU,CAAAA,SAAZ,EAA6D,IAA7D,GAAuCV,OAAQU,CAAAA,SAA/C,CACEV,OAAQU,CAAAA,SAAR,CAAoB,GADtB,KAEO,IAAIzE,MAAOsB,CAAAA,QAAP,CAAgByC,OAAQU,CAAAA,SAAxB,CAAJ,CACLV,OAAQU,CAAAA,SAAR,CAAoBV,OAAQU,CAAAA,SAAUlD,CAAAA,QAAlB,EADf,KAEA,IAAiC,QAAjC,GAAI,MAAOwC,QAAQU,CAAAA,SAAnB,CACL,MAAO,KAAIpE,QAAJ,CAAa,mCAAb,CAAkD,CAAC,kDAAD,CAAqD,OAAOmB,IAAKlB,CAAAA,SAAL,CAAeyD,OAAQU,CAAAA,SAAvB,CAAP,EAArD,CAAlD,CAIT,IAAsBvD,IAAAA,EAAtB,GAAI6C,OAAQb,CAAAA,KAAZ,EAAqD,IAArD,GAAmCa,OAAQb,CAAAA,KAA3C,CACEa,OAAQb,CAAAA,KAAR,CAAgB,GADlB,KAEO,IAAsB,CAAA,CAAtB,GAAIa,OAAQb,CAAAA,KAAZ,CACLa,OAAQb,CAAAA,KAAR,CAAgB,GADX,KAEA,IAAsB,CAAA,CAAtB,GAAIa,OAAQb,CAAAA,KAAZ,CACLa,OAAQb,CAAAA,KAAR;AAAgB,EADX,KAEA,IAAIlD,MAAOsB,CAAAA,QAAP,CAAgByC,OAAQb,CAAAA,KAAxB,CAAJ,CACLa,OAAQb,CAAAA,KAAR,CAAgBa,OAAQb,CAAAA,KAAM3B,CAAAA,QAAd,EADX,KAEA,IAA6B,QAA7B,GAAI,MAAOwC,QAAQb,CAAAA,KAAnB,CACL,MAAO,KAAI7C,QAAJ,CAAa,+BAAb,CAA8C,CAAC,yDAAD,CAA4D,OAAOmB,IAAKlB,CAAAA,SAAL,CAAeyD,OAAQb,CAAAA,KAAvB,CAAP,EAA5D,CAA9C,CAIT,IAAuBhC,IAAAA,EAAvB,GAAI6C,OAAQW,CAAAA,MAAZ,EAAuD,IAAvD,GAAoCX,OAAQW,CAAAA,MAA5C,CACEX,OAAQW,CAAAA,MAAR,CAAiB,CAAA,CAKnB,IAA6BxD,IAAAA,EAA7B,GAAI6C,OAAQY,CAAAA,YAAZ,EAAmE,IAAnE,GAA0CZ,OAAQY,CAAAA,YAAlD,CACEZ,OAAQY,CAAAA,YAAR,CAAuBzD,IAAAA,EAKIA,KAAAA,EAA7B,GAAI6C,OAAQa,CAAAA,YAAZ,EAAmE,IAAnE,GAA0Cb,OAAQa,CAAAA,YAAlD,EAAoG,CAAA,CAApG,GAA2Eb,OAAQa,CAAAA,YAAnF;AACEb,OAAQa,CAAAA,YADV,CACyB,IADzB,CAEY7D,KAAMC,CAAAA,OAAN,CAAc+C,OAAQa,CAAAA,YAAtB,CAFZ,GAGEb,OAAQa,CAAAA,YAHV,CAGyB,CAACb,OAAQa,CAAAA,YAAT,CAHzB,CAMA,IAAIb,OAAQa,CAAAA,YAAZ,CACE,IAAK,MAAMA,YAAX,GAA2Bb,QAAQa,CAAAA,YAAnC,CAAiD,CAE/C,MAAMC,SAAWD,YAAXC,WAAmCzC,OAEzC,IAHyC,QAGzC,GAHiB,MAAOwC,aAGxB,EAAiB,CAACC,QAAlB,CACE,MAAOnE,MAAA,CAAM,iEAAiEc,IAAKlB,CAAAA,SAAL,CAAesE,YAAf,CAAjE,EAAN,CALsC,CAWnD,GAA8B1D,IAAAA,EAA9B,GAAI6C,OAAQe,CAAAA,aAAZ,EAAqE,IAArE,GAA2Cf,OAAQe,CAAAA,aAAnD,CACEf,OAAQe,CAAAA,aAAR,CAAwB,CAAA,CAK1B,IAAoB5D,IAAAA,EAApB,GAAI6C,OAAQgB,CAAAA,GAAZ,EAAiD,IAAjD;AAAiChB,OAAQgB,CAAAA,GAAzC,CACEhB,OAAQgB,CAAAA,GAAR,CAAc,CAAA,CAKhB,IAAuB7D,IAAAA,EAAvB,GAAI6C,OAAQiB,CAAAA,MAAZ,EAAuD,IAAvD,GAAoCjB,OAAQiB,CAAAA,MAA5C,CACEjB,OAAQiB,CAAAA,MAAR,CAAiB,GADnB,KAEO,IAAIhF,MAAOsB,CAAAA,QAAP,CAAgByC,OAAQiB,CAAAA,MAAxB,CAAJ,CACLjB,OAAQiB,CAAAA,MAAR,CAAiBjB,OAAQiB,CAAAA,MAAOzD,CAAAA,QAAf,EADZ,KAEA,IAA8B,QAA9B,GAAI,MAAOwC,QAAQiB,CAAAA,MAAnB,CACL,MAAOtE,MAAA,CAAM,4DAA4Dc,IAAKlB,CAAAA,SAAL,CAAeyD,OAAQiB,CAAAA,MAAvB,CAA5D,EAAN,CAGT,IAA4B,CAA5B,CAAIjB,OAAQiB,CAAAA,MAAOtB,CAAAA,MAAnB,CACE,MAAOhD,MAAA,CAAM,qDAAqDqD,OAAQiB,CAAAA,MAAOtB,CAAAA,MAApE,aAAN,CAIT,IAAuBxC,IAAAA,EAAvB,GAAI6C,OAAQkB,CAAAA,MAAZ,EAAuD,IAAvD,GAAoClB,OAAQkB,CAAAA,MAA5C,CACElB,OAAQkB,CAAAA,MAAR;AAAiB,CAAA,CAKnB,OAAM,CAAChB,GAAD,CAAMiB,OAAN,CAAA,CAAiB,IAAKC,CAAAA,iBAAL,CAAuBpB,OAAQmB,CAAAA,OAA/B,CACvB,IAAIjB,GAAJ,CAAS,MAAOA,IAChBF,QAAQmB,CAAAA,OAAR,CAAkBA,OAElB,IAAuBhE,IAAAA,EAAvB,GAAI6C,OAAQW,CAAAA,MAAZ,EAAuD,IAAvD,GAAoCX,OAAQW,CAAAA,MAA5C,CACEX,OAAQW,CAAAA,MAAR,CAAiB,CAAA,CAKnB,IAAqBxD,IAAAA,EAArB,GAAI6C,OAAQqB,CAAAA,IAAZ,EAAmD,IAAnD,GAAkCrB,OAAQqB,CAAAA,IAA1C,CACErB,OAAQqB,CAAAA,IAAR,CAAe,EAKjB,IAA4BlE,IAAAA,EAA5B,GAAI6C,OAAQqB,CAAAA,IAAKC,CAAAA,MAAjB,EAAiE,IAAjE,GAAyCtB,OAAQqB,CAAAA,IAAKC,CAAAA,MAAtD,CAEEtB,OAAQqB,CAAAA,IAAKC,CAAAA,MAAb,CAAsBlF,KAAAmF,EAAS,EAATA,CAAcnF,KAItC,IAA6Be,IAAAA,EAA7B,GAAI6C,OAAQqB,CAAAA,IAAKG,CAAAA,OAAjB,EAAmE,IAAnE,GAA0CxB,OAAQqB,CAAAA,IAAKG,CAAAA,OAAvD,CAEExB,OAAQqB,CAAAA,IAAKG,CAAAA,OAAb,CAAuBpF,KAAAqF,EAASrF,KAAA,CAAQ,GAAR,CAAc,EAIhD,IAA0Be,IAAAA,EAA1B,GAAI6C,OAAQqB,CAAAA,IAAKK,CAAAA,IAAjB,EAA6D,IAA7D,GAAuC1B,OAAQqB,CAAAA,IAAKK,CAAAA,IAApD,CAEE1B,OAAQqB,CAAAA,IAAKK,CAAAA,IAAb;AAAoBtF,KAAAuF,EAAS,EAATA,CAAcvF,KAAMwF,CAAAA,OAAN,EAIpC,IAA4BzE,IAAAA,EAA5B,GAAI6C,OAAQqB,CAAAA,IAAKQ,CAAAA,MAAjB,EAAiE,IAAjE,GAAyC7B,OAAQqB,CAAAA,IAAKQ,CAAAA,MAAtD,CAEE7B,OAAQqB,CAAAA,IAAKQ,CAAAA,MAAb,CAAsBzF,KAAA0F,EAAS,EAATA,CAAc1F,KAItC,IAA4Be,IAAAA,EAA5B,GAAI6C,OAAQqB,CAAAA,IAAK9B,CAAAA,MAAjB,EAAiE,IAAjE,GAAyCS,OAAQqB,CAAAA,IAAK9B,CAAAA,MAAtD,CAEES,OAAQqB,CAAAA,IAAK9B,CAAAA,MAAb,CAAsBnD,KAAA2F,EAAStE,IAAKlB,CAAAA,SAAL,CAAeH,KAAf,CAIjC,IAA4Be,IAAAA,EAA5B,GAAI6C,OAAQqB,CAAAA,IAAKxC,CAAAA,MAAjB,EAAiE,IAAjE,GAAyCmB,OAAQqB,CAAAA,IAAKxC,CAAAA,MAAtD,CAEEmB,OAAQqB,CAAAA,IAAKxC,CAAAA,MAAb,CAAsBmD,QAAS,CAAC5F,KAAD,CAAQ,CACrC,MAAOA,MAD8B,CAMzC,IAAiCe,IAAAA,EAAjC,GAAI6C,OAAQI,CAAAA,gBAAZ,EAA2E,IAA3E,GAA8CJ,OAAQI,CAAAA,gBAAtD,CACEJ,OAAQI,CAAAA,gBAAR,CAA2B,IAD7B,KAEO,IAAInE,MAAOsB,CAAAA,QAAP,CAAgByC,OAAQI,CAAAA,gBAAxB,CAAJ,CACLJ,OAAQI,CAAAA,gBAAR;AAA2BJ,OAAQI,CAAAA,gBAAiB5C,CAAAA,QAAzB,EADtB,KAEA,IAAwC,QAAxC,GAAI,MAAOwC,QAAQI,CAAAA,gBAAnB,CACL,MAAOzD,MAAA,CAAM,sEAAsEc,IAAKlB,CAAAA,SAAL,CAAeyD,OAAQI,CAAAA,gBAAvB,CAAtE,EAAN,CAvJQ,CA2JnB6B,UAAU,CAACC,KAAD,CAAQC,QAAR,CAAkBC,QAAlB,CAA4B,CACZ,CAAA,CAAxB,GAAI,IAAK/B,CAAAA,KAAMC,CAAAA,IAAf,GAIMJ,KAMN,CANY,IAAKmC,CAAAA,WAAL,CAAiBH,KAAjB,CAMZ,CAJY/E,IAAAA,EAIZ,GAJI+C,KAIJ,GAHE,IAAKG,CAAAA,KAAMC,CAAAA,IAGb,CAHoB,CAAA,CAGpB,EAAA8B,QAAA,CAASlC,KAAT,CAVA,CADoC,CActCoC,MAAM,CAACF,QAAD,CAAW,CACf,GAAwB,CAAA,CAAxB,GAAI,IAAK/B,CAAAA,KAAMC,CAAAA,IAAf,CAAA,CAMA,GAA0B,CAA1B,GAAI,IAAKC,CAAAA,IAAKC,CAAAA,OAAd,CAA6B,CAC3B,IAAKC,CAAAA,GAAL,EACA,OAAMP,IAAM,IAAKqC,CAAAA,OAAL,EACRrC,IAAJ,EAASkC,QAAA,CAASlC,GAAT,CAHkB,CAM7BkC,QAAA,EAZA,CADe,CAgBjBC,WAAW,CAACH,KAAD,CAAQ,CAEjB,GAAI,CAAClF,KAAMC,CAAAA,OAAN,CAAciF,KAAd,CAAL;AAA8C,QAA9C,GAA6B,MAAOA,MAApC,CACE,MAAOvF,MAAA,CAAM,qDAAqDc,IAAKlB,CAAAA,SAAL,CAAe2F,KAAf,CAArD,EAAN,CAIT,IAA0B,CAA1B,GAAI,IAAK3B,CAAAA,IAAKC,CAAAA,OAAd,CACE,GAAIxD,KAAMC,CAAAA,OAAN,CAAciF,KAAd,CAAJ,CACE,IAA4B,CAAA,CAA5B,GAAI,IAAKlC,CAAAA,OAAQkB,CAAAA,MAAjB,EAA6D/D,IAAAA,EAA7D,GAAoC,IAAK6C,CAAAA,OAAQmB,CAAAA,OAAjD,CACE,MAAOxE,MAAA,CAAM,gFAAN,CADT,CADF,IAIO,IAA6BQ,IAAAA,EAA7B,GAAI,IAAK6C,CAAAA,OAAQmB,CAAAA,OAAjB,CAAwC,CAC7C,MAAM,CAACjB,GAAD,CAAMiB,OAAN,CAAA,CAAiB,IAAKC,CAAAA,iBAAL,CAAuBlF,MAAOsG,CAAAA,IAAP,CAAYN,KAAZ,CAAvB,CACvB,IAAIhC,GAAJ,CAAS,MACT,KAAKF,CAAAA,OAAQmB,CAAAA,OAAb,CAAuBA,OAHsB,CAQjD,GAA0B,CAA1B,GAAI,IAAKZ,CAAAA,IAAKC,CAAAA,OAAd,CAA6B,CAC3B,IAAKC,CAAAA,GAAL,EACA;IAAMP,aAAM,IAAKqC,CAAAA,OAAL,EACZ,IAAIrC,YAAJ,CAAS,MAAOA,aAHW,CAO7B,GAAI,CACF,IAAKuC,CAAAA,IAAL,CAAU,QAAV,CAAoBP,KAApB,CAA2B,IAAK3B,CAAAA,IAAKC,CAAAA,OAArC,CADE,CAEF,MAAON,GAAP,CAAY,CACZ,MAAOA,IADK,CAOd,GAAI,IAAKF,CAAAA,OAAQgB,CAAAA,GAAjB,CAAsB,CACpB,CAACd,KAAD,CAAMwC,YAAN,CAAA,CAAsB,IAAKnG,CAAAA,SAAL,CAAe2F,KAAf,CACtB,IAAIhC,KAAJ,CAAS,MAAOA,MAEhB,IAAqB/C,IAAAA,EAArB,GAAIuF,YAAJ,CACE,MAEeA,aAAf,EAA8B,IAAK1C,CAAAA,OAAQI,CAAAA,gBAPzB,CAAtB,IASO,CACL,CAACF,KAAD,CAAMwC,YAAN,CAAA,CAAsB,IAAKnG,CAAAA,SAAL,CAAe2F,KAAf,CACtB,IAAIhC,KAAJ,CAAS,MAAOA,MAEhB,IAAqB/C,IAAAA,EAArB,GAAIuF,YAAJ,CACE,MAEA,IAAI,IAAK1C,CAAAA,OAAQkB,CAAAA,MAAjB,EAA2B,IAAKX,CAAAA,IAAKC,CAAAA,OAArC,CACEkC,YAAA,CAAe,IAAK1C,CAAAA,OAAQI,CAAAA,gBAA5B,CAA+CsC,YAR9C,CAcP,IAAKnC,CAAAA,IAAKC,CAAAA,OAAV,EACA;IAAKvB,CAAAA,IAAL,CAAUyD,YAAV,CA5DiB,CA+DnBnG,SAAS,CAAC2F,KAAD,CAAQS,aAAR,CAA+B,CAAvBA,aAAA,CAAA,IAAA,EAAA,GAAAA,aAAA,CAAgB,CAAA,CAAhB,CAAAA,aACf,IAAqB,QAArB,GAAI,MAAOT,MAAX,CACE,MAAO,CAAC/E,IAAAA,EAAD,CAAY+E,KAAZ,CAGT,KAAM,CACJf,OADI,CAAA,CAEF,IAAKnB,CAAAA,OACT,OAAM4C,OAAS,EAEf,IAAI5F,KAAMC,CAAAA,OAAN,CAAciF,KAAd,CAAJ,CAQE,IALIf,OAKK0B,EAJPX,KAAMY,CAAAA,MAAN,CAAa3B,OAAQxB,CAAAA,MAArB,CAIOkD,CAAAA,OAAAA,CAAI,CAAb,CAAgBA,OAAhB,CAAoBX,KAAMvC,CAAAA,MAA1B,CAAkCkD,OAAA,EAAlC,CAAuC,CACrC,IAAME,MAAQb,KAAA,CAAMW,OAAN,CAEd,OAAM,CAAC3C,GAAD,CAAM9D,KAAN,CAAA,CAAe,IAAK4G,CAAAA,MAAL,CAAYD,KAAZ,CAAmB,CACtCrD,MAAOmD,OAD+B,CAEtCI,OAAQJ,OAF8B,CAGtCrC,QAAS,IAAKD,CAAAA,IAAKC,CAAAA,OAHmB,CAItCU,OAAQyB,aAJ8B,CAAnB,CAOrB,IAAIzC,GAAJ,CAAS,MAAO,CAACA,GAAD,CAChB0C,OAAA,CAAOC,OAAP,CAAA,CAAY,CAACzG,KAAD,CAAQ2G,KAAR,CAXyB,CARzC,IAwBE,KAASF,KAAT;AAAa,CAAb,CAAgBA,KAAhB,CAAoB1B,OAAQxB,CAAAA,MAA5B,CAAoCkD,KAAA,EAApC,CAAyC,CACvC,IAAME,eAAQzD,GAAA,CAAI4C,KAAJ,CAAWf,OAAA,CAAQ0B,KAAR,CAAWvF,CAAAA,GAAtB,CAEd,OAAM,CAAC4C,GAAD,CAAM9D,KAAN,CAAA,CAAe,IAAK4G,CAAAA,MAAL,CAAYD,cAAZ,CAAmB,CACtCrD,MAAOmD,KAD+B,CAEtCI,OAAQ9B,OAAA,CAAQ0B,KAAR,CAAWvF,CAAAA,GAFmB,CAGtCkD,QAAS,IAAKD,CAAAA,IAAKC,CAAAA,OAHmB,CAItCU,OAAQyB,aAJ8B,CAAnB,CAOrB,IAAIzC,GAAJ,CAAS,MAAO,CAACA,GAAD,CAChB0C,OAAA,CAAOC,KAAP,CAAA,CAAY,CAACzG,KAAD,CAAQ2G,cAAR,CAX2B,CAevCG,KAAAA,CAAY,EAEhB,KAASL,aAAT,CAAa,CAAb,CAAgBA,aAAhB,CAAoBD,MAAOjD,CAAAA,MAA3B,CAAmCkD,aAAA,EAAnC,CAAwC,CACtC,IAAa3C,GAAb,CAEI,CAAC9D,KAAD,CAAQ2G,cAAR,CAAA,CAAiBH,MAAA,CAAOC,aAAP,CAErB,IAAqB,QAArB,GAAI,MAAOzG,MAAX,CACE4D,OAAA,CAAU,IAAKA,CAAAA,OADjB,KAEO,IAAIrC,QAAA,CAASvB,KAAT,CAAJ,CAAqB,CAC1B4D,OAAA,CAAU5D,KACVA,MAAA,CAAQ4D,OAAQ5D,CAAAA,KAChB;OAAO4D,OAAQ5D,CAAAA,KAEf,IAAqB,QAArB,GAAI,MAAOA,MAAX,EAA2Ce,IAAAA,EAA3C,GAAiCf,KAAjC,EAAkE,IAAlE,GAAwDA,KAAxD,EACM8D,GADN,CACW,MAAO,CAACvD,KAAA,CAAM,sFAAsFc,IAAKlB,CAAAA,SAAL,CAAeH,KAAf,CAAtF,EAAN,CAAD,CAGlB4D,QAAA,CAAU,MAAA,CAAA,MAAA,CAAA,EAAA,CAAK,IAAKA,CAAAA,OAAV,CACLA,OADK,CAIV,IAAwC7C,IAAAA,EAAxC,IAAK+C,GAAL,CAAW,IAAKC,CAAAA,SAAL,CAAeH,OAAf,CAAX,EACE,MAAO,CAACE,GAAD,CAdiB,CAArB,IAgBA,IAAc/C,IAAAA,EAAd,GAAIf,KAAJ,EAAqC,IAArC,GAA2BA,KAA3B,CACL4D,OAAA,CAAU,IAAKA,CAAAA,OADV,KAGL,OAAO,CAACrD,KAAA,CAAM,iGAAiGc,IAAKlB,CAAAA,SAAL,CAAeH,KAAf,CAAjG,EAAN,CAAD,CAGT;MAAM,CACJsE,SADI,CAEJO,MAFI,CAGJ9B,KAHI,CAIJwB,MAJI,CAKJC,YALI,CAMJG,aANI,CAOJ,aAAAF,qBAPI,CAQJT,gBARI,CAAA,CASFJ,OAEJ,IAAI5D,KAAJ,CAAW,CACT,GAAqB,QAArB,GAAI,MAAOA,MAAX,CACE,MAAO,CAACO,KAAA,CAAM,0DAA0Dc,IAAKlB,CAAAA,SAAL,CAAeH,KAAf,CAA1D,EAAN,CAAD,CAGH+G,eAAAA,CAAoBzC,SAAUf,CAAAA,MAA9BwD,EAAoE,CAApEA,EAAwC/G,KAAMgH,CAAAA,OAAN,CAAc1C,SAAd,CACxC2C,QAAAA,CAA0B,EAA1BA,GAAgBlE,KAAhBkE,EAAwD,CAAxDA,EAAgCjH,KAAMgH,CAAAA,OAAN,CAAcjE,KAAd,CAChCmE,MAAAA,CAA0C,CAA1CA,EAAiBlH,KAAMgH,CAAAA,OAAN,CAAcnC,MAAd,CAAjBqC,EAA+CrC,MAA/CqC,GAA0DnE,KAChE,OAAMoE,wBAA6D,CAA7DA,EAA0BnH,KAAMgH,CAAAA,OAAN,CAAchD,gBAAd,CAAhC,CACMoD,aAAezC,aAAfyC;AAAiD,QAAjDA,GAAgC,MAAOT,eAC7C,KAAIU,YAAc5C,qBAAd4C,EAA8B5C,qBAAa6C,CAAAA,MAAb,CAAoB7C,YAAA,EACxB,QAA5B,GAAI,MAAOA,aAAX,CACyC,CAAC,CAD1C,GACSzE,KAAMgH,CAAAA,OAAN,CAAcvC,YAAd,CADT,CAGSA,YAAapB,CAAAA,IAAb,CAAkBrD,KAAlB,CAJuB,CAOlCqH,YAAA,CAAcA,WAAd,EAAkD,CAAlD,CAA6BA,WAAY9D,CAAAA,MACnCgE,eAAAA,CAAgC,CAAA,CAAhCA,GAAcN,OAAdM,EAAwCR,cAAxCQ,EAA6DJ,uBAA7DI,EAAwFhD,MAAxFgD,EAAkGH,YAAlGG,EAAkHF,WAEpG,EAAA,CAApB,GAAIE,cAAJ,EAA+C,CAAA,CAA/C,GAA4BL,KAA5B,GAEElH,KAFF,CAEUA,KAAM2B,CAAAA,OAAN,CADkB,IAAX6F,GAAA3C,MAAA2C,CAAkB,IAAIvF,MAAJ,CAAW4C,MAAX,CAAoBA,MAApB,CAA4B,GAA5B,CAAlB2C,CAAqD,IAAIvF,MAAJ,CAAW4C,MAAX,CAAmB,GAAnB,CAC5D,CAAsBA,MAAtB,CAA+BA,MAA/B,CAFV,CAKsB,EAAA,CAAtB,GAAIoC,OAAJ;CAEEjH,KAFF,CAEUA,KAAM2B,CAAAA,OAAN,CADO6F,IAAIvF,MAAJuF,CAAWzE,KAAXyE,CAAkB,GAAlBA,CACP,CAAsB3C,MAAtB,CAA+B9B,KAA/B,CAFV,CAKoB,EAAA,CAApB,GAAIwE,cAAJ,GACEvH,KADF,CACU+C,KADV,CACkB/C,KADlB,CAC0B+C,KAD1B,CAIA+D,MAAA,EAAa9G,KAlCJ,CAAX,IAmCO,IAAqB,CAAA,CAArB,GAAIwE,YAAJ,EAAuC,EAAvC,GAA6BmC,cAA7B,EAA+D,CAAA,CAA/D,GAA6ChC,aAA7C,EAAwF,CAAA,CAAxF,GAAuEH,YAAvE,CACLsC,KAAA,EAAa/D,KAAb,CAAqBA,KAGnB0D,cAAJ,GAAUD,MAAOjD,CAAAA,MAAjB,CAA0B,CAA1B,GACEuD,KADF,EACexC,SADf,CA/EsC,CAoFxC,MAAO,CAACvD,IAAAA,EAAD,CAAY+F,KAAZ,CAvI+B,CA0IxCzC,GAAG,EAAG,CACqB,CAAA,CAAzB,GAAI,IAAKT,CAAAA,OAAQS,CAAAA,GAAjB,EAIA,IAAKxB,CAAAA,IAAL,CAAUxC,QAAV,CALI,CAQN8F,OAAO,EAAG,CACR,GAA4B,CAAA,CAA5B,GAAI,IAAKvC,CAAAA,OAAQkB,CAAAA,MAAjB,EAI6B/D,IAAAA,EAJ7B,GAII,IAAK6C,CAAAA,OAAQmB,CAAAA,OAJjB,CAIA,CAIA,IAAIjB,GAAJ,CACIqC,QAAU,IAAKvC,CAAAA,OAAQmB,CAAAA,OAAQ0C,CAAAA,GAArB,CAAyBZ,MAAA,EAAUA,MAAO/B,CAAAA,MAA1C,CAEV,KAAKlB,CAAAA,OAAQgB,CAAAA,GAAjB,EACE,CAACd,GAAD;AAAMqC,OAAN,CACA,CADiB,IAAKhG,CAAAA,SAAL,CAAegG,OAAf,CAAwB,CAAA,CAAxB,CACjB,CAAAA,OAAA,EAAW,IAAKvC,CAAAA,OAAQI,CAAAA,gBAF1B,EAIE,CAACF,GAAD,CAAMqC,OAAN,CAJF,CAImB,IAAKhG,CAAAA,SAAL,CAAegG,OAAf,CAGnB,IAAIrC,GAAJ,CAAS,MAAOA,IAChB,KAAKjB,CAAAA,IAAL,CAAUsD,OAAV,CAfA,CALQ,CAuBVS,MAAM,CAAC5G,KAAD,CAAQiB,OAAR,CAAiB,CACrB,MAAMoB,KAAO,MAAOrC,MAEpB,IAAI,CACF,MAAa,QAAb,GAAIqC,IAAJ,CAES,CAACtB,IAAAA,EAAD,CAAY,IAAK6C,CAAAA,OAAQqB,CAAAA,IAAKxC,CAAAA,MAAlB,CAAyBzC,KAAzB,CAAgCiB,OAAhC,CAAZ,CAFT,CAGoB,QAAb,GAAIoB,IAAJ,CACE,CAACtB,IAAAA,EAAD,CAAY,IAAK6C,CAAAA,OAAQqB,CAAAA,IAAKC,CAAAA,MAAlB,CAAyBlF,KAAzB,CAAgCiB,OAAhC,CAAZ,CADF,CAEa,QAAb,GAAIoB,IAAJ,CACE,CAACtB,IAAAA,EAAD,CAAY,IAAK6C,CAAAA,OAAQqB,CAAAA,IAAKQ,CAAAA,MAAlB,CAAyBzF,KAAzB,CAAgCiB,OAAhC,CAAZ,CADF,CAEa,SAAb,GAAIoB,IAAJ,CACE,CAACtB,IAAAA,EAAD,CAAY,IAAK6C,CAAAA,OAAQqB,CAAAA,IAAKG,CAAAA,OAAlB,CAA0BpF,KAA1B,CAAiCiB,OAAjC,CAAZ,CADF,CAEIjB,KAAJ,WAAqB0H,KAArB,CACE,CAAC3G,IAAAA,EAAD,CAAY,IAAK6C,CAAAA,OAAQqB,CAAAA,IAAKK,CAAAA,IAAlB,CAAuBtF,KAAvB;AAA8BiB,OAA9B,CAAZ,CADF,CAEa,QAAb,GAAIoB,IAAJ,EAAmC,IAAnC,GAAyBrC,KAAzB,CACE,CAACe,IAAAA,EAAD,CAAY,IAAK6C,CAAAA,OAAQqB,CAAAA,IAAK9B,CAAAA,MAAlB,CAAyBnD,KAAzB,CAAgCiB,OAAhC,CAAZ,CADF,CAGE,CAACF,IAAAA,EAAD,CAAYf,KAAZ,CAAmBA,KAAnB,CAfP,CAiBF,MAAO8D,GAAP,CAAY,CACZ,MAAO,CAACA,GAAD,CADK,CApBO,CAyBvBkB,iBAAiB,CAACD,OAAD,CAAU,CACzB,GAAgBhE,IAAAA,EAAhB,GAAIgE,OAAJ,EAAyC,IAAzC,GAA6BA,OAA7B,CACE,MAAO,EAGT,IAAuB,QAAvB,GAAI,MAAOA,QAAX,CACE,MAAO,CAACxE,KAAA,CAAM,wDAAN,CAAD,CAGT,IAAKK,KAAMC,CAAAA,OAAN,CAAckE,OAAd,CAAL,CAWO,CACL,IAAM4C,WAAa,EAEnB,KAAK,IAAMd,MAAX,GAAqB9B,QAArB,CACE,GAAsB,QAAtB,GAAI,MAAO8B,OAAX,CACEc,UAAW9E,CAAAA,IAAX,CAAgB,CACd3B,IAAK2F,MADS,CAEd/B,OAAQ+B,MAFM,CAAhB,CADF,KAKO,CAAA,GAAsB,QAAtB,GAAI,MAAOA,OAAX,EAA6C9F,IAAAA,EAA7C,GAAkC8F,MAAlC;AAA2DjG,KAAMC,CAAAA,OAAN,CAAcgG,MAAd,CAA3D,CAWL,MAAO,CAACtG,KAAA,CAAM,yDAAN,CAAD,CAVP,IAAI,CAACsG,MAAO3F,CAAAA,GAAZ,CACE,MAAO,CAACX,KAAA,CAAM,uDAAN,CAAD,CAGaQ,KAAAA,EAAtB,GAAI8F,MAAO/B,CAAAA,MAAX,GACE+B,MAAO/B,CAAAA,MADT,CACkB+B,MAAO3F,CAAAA,GADzB,CAIAyG,WAAW9E,CAAAA,IAAX,CAAgBgE,MAAhB,CATK,CAeT9B,OAAA,CAAU4C,UAxBL,CAXP,IAA6B,CACrBA,MAAAA,CAAa,EAEnB,KAAWC,UAAX,GAAgB7C,QAAhB,CACE4C,MAAW9E,CAAAA,IAAX,CAAgB,CACd3B,IAAK0G,UADS,CAEd9C,OAAQC,OAAA,CAAQ6C,UAAR,CAFM,CAAhB,CAMF7C,QAAA,CAAU4C,MAViB,CAsC7B,MAAO,CAAC5G,IAAAA,EAAD,CAAYgE,OAAZ,CA/CkB,CAhf7B,CAoiBAnF,OAAQK,CAAAA,WAAR,CAAsBA,WA4DtBL,QAAQO,CAAAA,SAAR,CA1DkBA,QAAS,EAAG,CAAA,IACxB0H,IAAJ,KAAmB7B,QAEnB,KAAK,MAAMS,CAAX,GAAgBqB,UAAhB,CAA2B,CACzB,MAAMC;AAAWD,SAAA,CAAUrB,CAAV,CAAjB,CACMpE,KAAO,MAAO0F,SAEpB,IAAahH,IAAAA,EAAb,GAAI8G,IAAJ,EAA0BjH,KAAMC,CAAAA,OAAN,CAAckH,QAAd,CAA1B,CACEF,IAAA,CAAOE,QADT,KAEO,IAAgBhH,IAAAA,EAAhB,GAAI6C,OAAJ,EAA6BrC,QAAA,CAASwG,QAAT,CAA7B,CACL,IAAAnE,QAAUmE,QADL,KAEA,IAAiBhH,IAAAA,EAAjB,GAAIiF,QAAJ,EAAuC,UAAvC,GAA8B3D,IAA9B,CACL2D,QAAA,CAAW+B,QADN,KAGL,MAAM,KAAI7H,QAAJ,CAAa,sBAAb,CAAqC,CAAC,mBAAD,CAAsB,OAAOmB,IAAKlB,CAAAA,SAAL,CAAe4H,QAAf,CAAP,aAA4CtB,CAA5C,EAAtB,CAArC,CAAN,CAXuB,CAe3B,MAAMuB,YAAc,IAAI/H,WAAJ,CAAgB2D,OAAhB,CAEpB,IAAIoC,QAAJ,CAAc,CACZ,MAAMiC,OAAS,EACfD,YAAYE,CAAAA,EAAZ,CAAe,UAAf,CAA2B,QAAS,EAAG,CACrC,IAAIpC,KAEJ,KAAA,CAAiC,IAAjC,IAAQA,KAAR,CAAgB,IAAKqC,CAAAA,IAAL,EAAhB,EAAA,CACEF,MAAOpF,CAAAA,IAAP,CAAYiD,KAAZ,CAJmC,CAAvC,CAOAkC;WAAYE,CAAAA,EAAZ,CAAe,OAAf,CAAwB,QAAS,CAACpE,GAAD,CAAM,CACrCkC,QAAA,CAASlC,GAAT,CADqC,CAAvC,CAGAkE,YAAYE,CAAAA,EAAZ,CAAe,KAAf,CAAsB,QAAS,EAAG,CAChClC,QAAA,CAASjF,IAAAA,EAAT,CAAoBkH,MAAOnH,CAAAA,IAAP,CAAY,EAAZ,CAApB,CADgC,CAAlC,CAZY,CAiBDC,IAAAA,EAAb,GAAI8G,IAAJ,GACQO,OASN,CATeA,QAAS,EAAG,CACzB,IAAK,MAAM5B,MAAX,GAAqBqB,KAArB,CACEG,WAAYK,CAAAA,KAAZ,CAAkB7B,MAAlB,CAGFwB,YAAYM,CAAAA,GAAZ,EALyB,CAS3B,CAA4B,UAA5B,GAAI,MAAOC,aAAX,CACEA,YAAA,CAAaH,OAAb,CADF,CAGEI,UAAA,CAAWJ,OAAX,CAAmB,CAAnB,CAbJ,CAiBA,OAAOJ,YAtDqB,CA9qB0E;",
"sources":["node_modules/csv-stringify/lib/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$csv_stringify$lib$index\"] = function(global,require,module,exports) {\nvar Buffer = require('buffer').Buffer;\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Stringifier = exports.CsvError = exports.stringify = void 0;\n\nvar _stream = require(\"stream\");\n\n/*\nCSV Stringify\n\nPlease look at the [project documentation](https://csv.js.org/stringify/) for\nadditional information.\n*/\nconst bom_utf8 = Buffer.from([239, 187, 191]);\n\nclass CsvError extends Error {\n  constructor(code, message, ...contexts) {\n    if (Array.isArray(message)) message = message.join(' ');\n    super(message);\n\n    if (Error.captureStackTrace !== undefined) {\n      Error.captureStackTrace(this, CsvError);\n    }\n\n    this.code = code;\n\n    for (const context of contexts) {\n      for (const key in context) {\n        const value = context[key];\n        this[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value));\n      }\n    }\n  }\n\n}\n\nexports.CsvError = CsvError;\n\nconst isObject = function (obj) {\n  return typeof obj === 'object' && obj !== null && !Array.isArray(obj);\n};\n\nconst underscore = function (str) {\n  return str.replace(/([A-Z])/g, function (_, match) {\n    return '_' + match.toLowerCase();\n  });\n}; // Lodash implementation of `get`\n\n\nconst charCodeOfDot = '.'.charCodeAt(0);\nconst reEscapeChar = /\\\\(\\\\)?/g;\nconst rePropName = RegExp( // Match anything that isn't a dot or bracket.\n'[^.[\\\\]]+' + '|' + // Or match property names within brackets.\n'\\\\[(?:' + // Match a non-string expression.\n'([^\"\\'][^[]*)' + '|' + // Or match strings (supports escaping characters).\n'([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' + ')\\\\]' + '|' + // Or match \"\" as the space between consecutive dots or empty brackets.\n'(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))', 'g');\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nconst reIsPlainProp = /^\\w*$/;\n\nconst getTag = function (value) {\n  if (!value) value === undefined ? '[object Undefined]' : '[object Null]';\n  return Object.prototype.toString.call(value);\n};\n\nconst isSymbol = function (value) {\n  const type = typeof value;\n  return type === 'symbol' || type === 'object' && value && getTag(value) === '[object Symbol]';\n};\n\nconst isKey = function (value, object) {\n  if (Array.isArray(value)) {\n    return false;\n  }\n\n  const type = typeof value;\n\n  if (type === 'number' || type === 'symbol' || type === 'boolean' || !value || isSymbol(value)) {\n    return true;\n  }\n\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n};\n\nconst stringToPath = function (string) {\n  const result = [];\n\n  if (string.charCodeAt(0) === charCodeOfDot) {\n    result.push('');\n  }\n\n  string.replace(rePropName, function (match, expression, quote, subString) {\n    let key = match;\n\n    if (quote) {\n      key = subString.replace(reEscapeChar, '$1');\n    } else if (expression) {\n      key = expression.trim();\n    }\n\n    result.push(key);\n  });\n  return result;\n};\n\nconst castPath = function (value, object) {\n  if (Array.isArray(value)) {\n    return value;\n  } else {\n    return isKey(value, object) ? [value] : stringToPath(value);\n  }\n};\n\nconst toKey = function (value) {\n  if (typeof value === 'string' || isSymbol(value)) return value;\n  const result = `${value}`; // eslint-disable-next-line\n\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n};\n\nconst get = function (object, path) {\n  path = castPath(path, object);\n  let index = 0;\n  const length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n\n  return index && index === length ? object : undefined;\n};\n\nclass Stringifier extends _stream.Transform {\n  constructor(opts = {}) {\n    super({ ...{\n        writableObjectMode: true\n      },\n      ...opts\n    });\n    const options = {};\n    let err; // Merge with user options\n\n    for (const opt in opts) {\n      options[underscore(opt)] = opts[opt];\n    }\n\n    if ((err = this.normalize(options)) !== undefined) throw err;\n\n    switch (options.record_delimiter) {\n      case 'auto':\n        options.record_delimiter = null;\n        break;\n\n      case 'unix':\n        options.record_delimiter = \"\\n\";\n        break;\n\n      case 'mac':\n        options.record_delimiter = \"\\r\";\n        break;\n\n      case 'windows':\n        options.record_delimiter = \"\\r\\n\";\n        break;\n\n      case 'ascii':\n        options.record_delimiter = \"\\u001e\";\n        break;\n\n      case 'unicode':\n        options.record_delimiter = \"\\u2028\";\n        break;\n    } // Expose options\n\n\n    this.options = options; // Internal state\n\n    this.state = {\n      stop: false\n    }; // Information\n\n    this.info = {\n      records: 0\n    };\n  }\n\n  normalize(options) {\n    // Normalize option `bom`\n    if (options.bom === undefined || options.bom === null || options.bom === false) {\n      options.bom = false;\n    } else if (options.bom !== true) {\n      return new CsvError('CSV_OPTION_BOOLEAN_INVALID_TYPE', ['option `bom` is optional and must be a boolean value,', `got ${JSON.stringify(options.bom)}`]);\n    } // Normalize option `delimiter`\n\n\n    if (options.delimiter === undefined || options.delimiter === null) {\n      options.delimiter = ',';\n    } else if (Buffer.isBuffer(options.delimiter)) {\n      options.delimiter = options.delimiter.toString();\n    } else if (typeof options.delimiter !== 'string') {\n      return new CsvError('CSV_OPTION_DELIMITER_INVALID_TYPE', ['option `delimiter` must be a buffer or a string,', `got ${JSON.stringify(options.delimiter)}`]);\n    } // Normalize option `quote`\n\n\n    if (options.quote === undefined || options.quote === null) {\n      options.quote = '\"';\n    } else if (options.quote === true) {\n      options.quote = '\"';\n    } else if (options.quote === false) {\n      options.quote = '';\n    } else if (Buffer.isBuffer(options.quote)) {\n      options.quote = options.quote.toString();\n    } else if (typeof options.quote !== 'string') {\n      return new CsvError('CSV_OPTION_QUOTE_INVALID_TYPE', ['option `quote` must be a boolean, a buffer or a string,', `got ${JSON.stringify(options.quote)}`]);\n    } // Normalize option `quoted`\n\n\n    if (options.quoted === undefined || options.quoted === null) {\n      options.quoted = false;\n    } else {// todo\n    } // Normalize option `quoted_empty`\n\n\n    if (options.quoted_empty === undefined || options.quoted_empty === null) {\n      options.quoted_empty = undefined;\n    } else {// todo\n    } // Normalize option `quoted_match`\n\n\n    if (options.quoted_match === undefined || options.quoted_match === null || options.quoted_match === false) {\n      options.quoted_match = null;\n    } else if (!Array.isArray(options.quoted_match)) {\n      options.quoted_match = [options.quoted_match];\n    }\n\n    if (options.quoted_match) {\n      for (const quoted_match of options.quoted_match) {\n        const isString = typeof quoted_match === 'string';\n        const isRegExp = quoted_match instanceof RegExp;\n\n        if (!isString && !isRegExp) {\n          return Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`);\n        }\n      }\n    } // Normalize option `quoted_string`\n\n\n    if (options.quoted_string === undefined || options.quoted_string === null) {\n      options.quoted_string = false;\n    } else {// todo\n    } // Normalize option `eof`\n\n\n    if (options.eof === undefined || options.eof === null) {\n      options.eof = true;\n    } else {// todo\n    } // Normalize option `escape`\n\n\n    if (options.escape === undefined || options.escape === null) {\n      options.escape = '\"';\n    } else if (Buffer.isBuffer(options.escape)) {\n      options.escape = options.escape.toString();\n    } else if (typeof options.escape !== 'string') {\n      return Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`);\n    }\n\n    if (options.escape.length > 1) {\n      return Error(`Invalid Option: escape must be one character, got ${options.escape.length} characters`);\n    } // Normalize option `header`\n\n\n    if (options.header === undefined || options.header === null) {\n      options.header = false;\n    } else {// todo\n    } // Normalize option `columns`\n\n\n    const [err, columns] = this.normalize_columns(options.columns);\n    if (err) return err;\n    options.columns = columns; // Normalize option `quoted`\n\n    if (options.quoted === undefined || options.quoted === null) {\n      options.quoted = false;\n    } else {// todo\n    } // Normalize option `cast`\n\n\n    if (options.cast === undefined || options.cast === null) {\n      options.cast = {};\n    } else {// todo\n    } // Normalize option cast.bigint\n\n\n    if (options.cast.bigint === undefined || options.cast.bigint === null) {\n      // Cast boolean to string by default\n      options.cast.bigint = value => '' + value;\n    } // Normalize option cast.boolean\n\n\n    if (options.cast.boolean === undefined || options.cast.boolean === null) {\n      // Cast boolean to string by default\n      options.cast.boolean = value => value ? '1' : '';\n    } // Normalize option cast.date\n\n\n    if (options.cast.date === undefined || options.cast.date === null) {\n      // Cast date to timestamp string by default\n      options.cast.date = value => '' + value.getTime();\n    } // Normalize option cast.number\n\n\n    if (options.cast.number === undefined || options.cast.number === null) {\n      // Cast number to string using native casting by default\n      options.cast.number = value => '' + value;\n    } // Normalize option cast.object\n\n\n    if (options.cast.object === undefined || options.cast.object === null) {\n      // Stringify object as JSON by default\n      options.cast.object = value => JSON.stringify(value);\n    } // Normalize option cast.string\n\n\n    if (options.cast.string === undefined || options.cast.string === null) {\n      // Leave string untouched\n      options.cast.string = function (value) {\n        return value;\n      };\n    } // Normalize option `record_delimiter`\n\n\n    if (options.record_delimiter === undefined || options.record_delimiter === null) {\n      options.record_delimiter = '\\n';\n    } else if (Buffer.isBuffer(options.record_delimiter)) {\n      options.record_delimiter = options.record_delimiter.toString();\n    } else if (typeof options.record_delimiter !== 'string') {\n      return Error(`Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`);\n    }\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (this.state.stop === true) {\n      return;\n    }\n\n    const err = this.__transform(chunk);\n\n    if (err !== undefined) {\n      this.state.stop = true;\n    }\n\n    callback(err);\n  }\n\n  _flush(callback) {\n    if (this.state.stop === true) {\n      // Note, Node.js 12 call flush even after an error, we must prevent\n      // `callback` from being called in flush without any error.\n      return;\n    }\n\n    if (this.info.records === 0) {\n      this.bom();\n      const err = this.headers();\n      if (err) callback(err);\n    }\n\n    callback();\n  }\n\n  __transform(chunk) {\n    // Chunk validation\n    if (!Array.isArray(chunk) && typeof chunk !== 'object') {\n      return Error(`Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`);\n    } // Detect columns from the first record\n\n\n    if (this.info.records === 0) {\n      if (Array.isArray(chunk)) {\n        if (this.options.header === true && this.options.columns === undefined) {\n          return Error('Undiscoverable Columns: header option requires column option or object records');\n        }\n      } else if (this.options.columns === undefined) {\n        const [err, columns] = this.normalize_columns(Object.keys(chunk));\n        if (err) return;\n        this.options.columns = columns;\n      }\n    } // Emit the header\n\n\n    if (this.info.records === 0) {\n      this.bom();\n      const err = this.headers();\n      if (err) return err;\n    } // Emit and stringify the record if an object or an array\n\n\n    try {\n      this.emit('record', chunk, this.info.records);\n    } catch (err) {\n      return err;\n    } // Convert the record into a string\n\n\n    let err, chunk_string;\n\n    if (this.options.eof) {\n      [err, chunk_string] = this.stringify(chunk);\n      if (err) return err;\n\n      if (chunk_string === undefined) {\n        return;\n      } else {\n        chunk_string = chunk_string + this.options.record_delimiter;\n      }\n    } else {\n      [err, chunk_string] = this.stringify(chunk);\n      if (err) return err;\n\n      if (chunk_string === undefined) {\n        return;\n      } else {\n        if (this.options.header || this.info.records) {\n          chunk_string = this.options.record_delimiter + chunk_string;\n        }\n      }\n    } // Emit the csv\n\n\n    this.info.records++;\n    this.push(chunk_string);\n  }\n\n  stringify(chunk, chunkIsHeader = false) {\n    if (typeof chunk !== 'object') {\n      return [undefined, chunk];\n    }\n\n    const {\n      columns\n    } = this.options;\n    const record = []; // Record is an array\n\n    if (Array.isArray(chunk)) {\n      // We are getting an array but the user has specified output columns. In\n      // this case, we respect the columns indexes\n      if (columns) {\n        chunk.splice(columns.length);\n      } // Cast record elements\n\n\n      for (let i = 0; i < chunk.length; i++) {\n        const field = chunk[i];\n\n        const [err, value] = this.__cast(field, {\n          index: i,\n          column: i,\n          records: this.info.records,\n          header: chunkIsHeader\n        });\n\n        if (err) return [err];\n        record[i] = [value, field];\n      } // Record is a literal object\n      // `columns` is always defined: it is either provided or discovered.\n\n    } else {\n      for (let i = 0; i < columns.length; i++) {\n        const field = get(chunk, columns[i].key);\n\n        const [err, value] = this.__cast(field, {\n          index: i,\n          column: columns[i].key,\n          records: this.info.records,\n          header: chunkIsHeader\n        });\n\n        if (err) return [err];\n        record[i] = [value, field];\n      }\n    }\n\n    let csvrecord = '';\n\n    for (let i = 0; i < record.length; i++) {\n      let options, err; // eslint-disable-next-line\n\n      let [value, field] = record[i];\n\n      if (typeof value === \"string\") {\n        options = this.options;\n      } else if (isObject(value)) {\n        options = value;\n        value = options.value;\n        delete options.value;\n\n        if (typeof value !== \"string\" && value !== undefined && value !== null) {\n          if (err) return [Error(`Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`)];\n        }\n\n        options = { ...this.options,\n          ...options\n        };\n\n        if ((err = this.normalize(options)) !== undefined) {\n          return [err];\n        }\n      } else if (value === undefined || value === null) {\n        options = this.options;\n      } else {\n        return [Error(`Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`)];\n      }\n\n      const {\n        delimiter,\n        escape,\n        quote,\n        quoted,\n        quoted_empty,\n        quoted_string,\n        quoted_match,\n        record_delimiter\n      } = options;\n\n      if (value) {\n        if (typeof value !== 'string') {\n          return [Error(`Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`)];\n        }\n\n        const containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0;\n        const containsQuote = quote !== '' && value.indexOf(quote) >= 0;\n        const containsEscape = value.indexOf(escape) >= 0 && escape !== quote;\n        const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;\n        const quotedString = quoted_string && typeof field === 'string';\n        let quotedMatch = quoted_match && quoted_match.filter(quoted_match => {\n          if (typeof quoted_match === 'string') {\n            return value.indexOf(quoted_match) !== -1;\n          } else {\n            return quoted_match.test(value);\n          }\n        });\n        quotedMatch = quotedMatch && quotedMatch.length > 0;\n        const shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch;\n\n        if (shouldQuote === true && containsEscape === true) {\n          const regexp = escape === '\\\\' ? new RegExp(escape + escape, 'g') : new RegExp(escape, 'g');\n          value = value.replace(regexp, escape + escape);\n        }\n\n        if (containsQuote === true) {\n          const regexp = new RegExp(quote, 'g');\n          value = value.replace(regexp, escape + quote);\n        }\n\n        if (shouldQuote === true) {\n          value = quote + value + quote;\n        }\n\n        csvrecord += value;\n      } else if (quoted_empty === true || field === '' && quoted_string === true && quoted_empty !== false) {\n        csvrecord += quote + quote;\n      }\n\n      if (i !== record.length - 1) {\n        csvrecord += delimiter;\n      }\n    }\n\n    return [undefined, csvrecord];\n  }\n\n  bom() {\n    if (this.options.bom !== true) {\n      return;\n    }\n\n    this.push(bom_utf8);\n  }\n\n  headers() {\n    if (this.options.header === false) {\n      return;\n    }\n\n    if (this.options.columns === undefined) {\n      return;\n    }\n\n    let err;\n    let headers = this.options.columns.map(column => column.header);\n\n    if (this.options.eof) {\n      [err, headers] = this.stringify(headers, true);\n      headers += this.options.record_delimiter;\n    } else {\n      [err, headers] = this.stringify(headers);\n    }\n\n    if (err) return err;\n    this.push(headers);\n  }\n\n  __cast(value, context) {\n    const type = typeof value;\n\n    try {\n      if (type === 'string') {\n        // Fine for 99% of the cases\n        return [undefined, this.options.cast.string(value, context)];\n      } else if (type === 'bigint') {\n        return [undefined, this.options.cast.bigint(value, context)];\n      } else if (type === 'number') {\n        return [undefined, this.options.cast.number(value, context)];\n      } else if (type === 'boolean') {\n        return [undefined, this.options.cast.boolean(value, context)];\n      } else if (value instanceof Date) {\n        return [undefined, this.options.cast.date(value, context)];\n      } else if (type === 'object' && value !== null) {\n        return [undefined, this.options.cast.object(value, context)];\n      } else {\n        return [undefined, value, value];\n      }\n    } catch (err) {\n      return [err];\n    }\n  }\n\n  normalize_columns(columns) {\n    if (columns === undefined || columns === null) {\n      return [];\n    }\n\n    if (typeof columns !== 'object') {\n      return [Error('Invalid option \"columns\": expect an array or an object')];\n    }\n\n    if (!Array.isArray(columns)) {\n      const newcolumns = [];\n\n      for (const k in columns) {\n        newcolumns.push({\n          key: k,\n          header: columns[k]\n        });\n      }\n\n      columns = newcolumns;\n    } else {\n      const newcolumns = [];\n\n      for (const column of columns) {\n        if (typeof column === 'string') {\n          newcolumns.push({\n            key: column,\n            header: column\n          });\n        } else if (typeof column === 'object' && column !== undefined && !Array.isArray(column)) {\n          if (!column.key) {\n            return [Error('Invalid column definition: property \"key\" is required')];\n          }\n\n          if (column.header === undefined) {\n            column.header = column.key;\n          }\n\n          newcolumns.push(column);\n        } else {\n          return [Error('Invalid column definition: expect a string or an object')];\n        }\n      }\n\n      columns = newcolumns;\n    }\n\n    return [undefined, columns];\n  }\n\n}\n\nexports.Stringifier = Stringifier;\n\nconst stringify = function () {\n  let data, options, callback;\n\n  for (const i in arguments) {\n    const argument = arguments[i];\n    const type = typeof argument;\n\n    if (data === undefined && Array.isArray(argument)) {\n      data = argument;\n    } else if (options === undefined && isObject(argument)) {\n      options = argument;\n    } else if (callback === undefined && type === 'function') {\n      callback = argument;\n    } else {\n      throw new CsvError('CSV_INVALID_ARGUMENT', ['Invalid argument:', `got ${JSON.stringify(argument)} at index ${i}`]);\n    }\n  }\n\n  const stringifier = new Stringifier(options);\n\n  if (callback) {\n    const chunks = [];\n    stringifier.on('readable', function () {\n      let chunk;\n\n      while ((chunk = this.read()) !== null) {\n        chunks.push(chunk);\n      }\n    });\n    stringifier.on('error', function (err) {\n      callback(err);\n    });\n    stringifier.on('end', function () {\n      callback(undefined, chunks.join(''));\n    });\n  }\n\n  if (data !== undefined) {\n    const writer = function () {\n      for (const record of data) {\n        stringifier.write(record);\n      }\n\n      stringifier.end();\n    }; // Support Deno, Rollup doesnt provide a shim for setImmediate\n\n\n    if (typeof setImmediate === 'function') {\n      setImmediate(writer);\n    } else {\n      setTimeout(writer, 0);\n    }\n  }\n\n  return stringifier;\n}; // export default stringify\n\n\nexports.stringify = stringify;\n};"],
"names":["shadow$provide","global","require","module","exports","Buffer","Object","defineProperty","value","Stringifier","CsvError","stringify","_stream","bom_utf8","from","Error","constructor","code","message","contexts","Array","isArray","join","undefined","captureStackTrace","context","key","isBuffer","toString","JSON","parse","isObject","obj","underscore","str","replace","_","match","toLowerCase","reEscapeChar","rePropName","RegExp","reIsDeepProp","reIsPlainProp","isSymbol","type","prototype","call","stringToPath","string","result","charCodeOfDot","charCodeAt","push","expression","quote","subString","trim","get","object","path","test","index","length","INFINITY","Transform","opts","writableObjectMode","options","opt","err","normalize","record_delimiter","state","stop","info","records","bom","delimiter","quoted","quoted_empty","quoted_match","isRegExp","quoted_string","eof","escape","header","columns","normalize_columns","cast","bigint","options.cast.bigint","boolean","options.cast.boolean","date","options.cast.date","getTime","number","options.cast.number","options.cast.object","options.cast.string","_transform","chunk","encoding","callback","__transform","_flush","headers","keys","emit","chunk_string","chunkIsHeader","record","i","splice","field","__cast","column","csvrecord","containsdelimiter","indexOf","containsQuote","containsEscape","containsRecordDelimiter","quotedString","quotedMatch","filter","shouldQuote","regexp","map","Date","newcolumns","k","data","arguments","argument","stringifier","chunks","on","read","writer","write","end","setImmediate","setTimeout"]
}
