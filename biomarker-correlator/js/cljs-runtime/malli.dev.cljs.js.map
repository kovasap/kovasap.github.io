{"version":3,"sources":["malli/dev/cljs.cljc"],"mappings":"","names":[],"sourcesContent":["(ns malli.dev.cljs\n  #?(:cljs (:require-macros [malli.dev.cljs]))\n  #?(:cljs (:require [malli.instrument.cljs]\n                     [malli.dev.pretty :as pretty]))\n  #?(:clj (:require [malli.clj-kondo :as clj-kondo]\n                    [malli.dev.pretty :as pretty]\n                    [malli.instrument.cljs :as mi])))\n\n#?(:clj (defmacro stop!\n          \"Stops instrumentation for all functions vars and removes clj-kondo type annotations.\"\n          []\n          `(do\n             ~(mi/-unstrument &env nil)\n             ~(do (clj-kondo/save! {}) nil))))\n\n#?(:clj\n   (defn start!* [env options]\n     `(do\n        ~(mi/-unstrument env nil)\n\n        ;; register all function schemas and instrument them based on the options\n        ~(mi/-collect-all-ns)\n        ~(mi/-instrument env options))))\n\n#?(:clj (defmacro start!\n          \"Collects defn schemas from all loaded namespaces and starts instrumentation for\n           a filtered set of function Vars (e.g. `defn`s). See [[malli.core/-instrument]] for possible options.\n           Differences from Clojure `malli.dev/start!`:\n\n           - Does not emit clj-kondo type annotations. See `malli.clj-kondo/print-cljs!` to print clj-kondo config.\n           - Does not re-instrument functions if the function schemas change - use hot reloading to get a similar effect.\"\n          ([] (start!* &env {:report `(pretty/thrower)}))\n          ([options] (start!* &env options))))\n\n#?(:clj (defmacro collect-all! [] (mi/-collect-all-ns)))\n"]}