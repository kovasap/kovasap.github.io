shadow$provide.module$node_modules$vega_label$build$vega_label=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){"object"===typeof exports$jscomp$0&&"undefined"!==typeof module?factory(exports$jscomp$0,require("module$node_modules$vega_canvas$build$vega_canvas_min"),require("module$node_modules$vega_dataflow$build$vega_dataflow"),require("module$node_modules$vega_scenegraph$build$vega_scenegraph"),require("module$node_modules$vega_util$build$vega_util")):"function"===
typeof define&&define.amd?define(["exports","vega-canvas","vega-dataflow","vega-scenegraph","vega-util"],factory):(global="undefined"!==typeof globalThis?globalThis:global||self,factory((global.vega=global.vega||{},global.vega.transforms={}),global.vega,global.vega,global.vega,global.vega))})(this,function(exports,vegaCanvas,vegaDataflow,vegaScenegraph,vegaUtil){function baseBitmaps($,data){const bitmap=$.bitmap();(data||[]).forEach(d=>bitmap.set($(d.boundary[0]),$(d.boundary[3])));return[bitmap,
void 0]}function markBitmaps($,avoidMarks,labelInside,isGroupArea){const width=$.width,height=$.height,border=labelInside||isGroupArea,context=vegaCanvas.canvas(width,height).getContext("2d");avoidMarks.forEach(items=>draw(context,items,border));avoidMarks=new Uint32Array(context.getImageData(0,0,width,height).data.buffer);labelInside=$.bitmap();const layer2=border&&$.bitmap();let x,y,u,v,alpha;for(y=0;y<height;++y)for(x=0;x<width;++x)if(alpha=avoidMarks[y*width+x]&4278190080)u=$(x),v=$(y),isGroupArea||
labelInside.set(u,v),border&&alpha^268435456&&layer2.set(u,v);return[labelInside,layer2]}function draw(context,items,interior){if(items.length){var type=items[0].mark.marktype;"group"===type?items.forEach(group=>{group.items.forEach(mark=>draw(context,mark.items,interior))}):vegaScenegraph.Marks[type].draw(context,{items:interior?items.map(prepare):items})}}function prepare(source){source=vegaDataflow.rederive(source,{});source.stroke&&(source.strokeOpacity=1);source.fill&&(source.fillOpacity=.0625,
source.stroke="#000",source.strokeOpacity=1,source.strokeWidth=2);return source}function Bitmap(w,h){const array=new Uint32Array(~~((w*h+32)/32));return{array,get:(x,y)=>{x=y*w+x;return array[x>>>5]&1<<(x&31)},set:(x,y)=>{x=y*w+x;array[x>>>5]|=1<<(x&31)},clear:(x,y)=>{x=y*w+x;array[x>>>5]&=~(1<<(x&31))},getRange:(x,y,x2,y2)=>{let end,indexStart,indexEnd;for(;y2>=y;--y2){var start=y2*w+x;end=y2*w+x2;indexStart=start>>>5;indexEnd=end>>>5;if(indexStart===indexEnd){if(array[indexStart]&RIGHT0[start&31]&
RIGHT1[(end&31)+1])return!0}else{if(array[indexStart]&RIGHT0[start&31]||array[indexEnd]&RIGHT1[(end&31)+1])return!0;for(start=indexStart+1;start<indexEnd;++start)if(array[start])return!0}}return!1},setRange:(x,y,x2,y2)=>{let end,indexStart,indexEnd;for(;y<=y2;++y){var start=y*w+x;end=y*w+x2;indexStart=start>>>5;indexEnd=end>>>5;if(indexStart===indexEnd)array[indexStart]|=RIGHT0[start&31]&RIGHT1[(end&31)+1];else for(array[indexStart]|=RIGHT0[start&31],array[indexEnd]|=RIGHT1[(end&31)+1],start=indexStart+
1;start<indexEnd;++start)array[start]|=4294967295}},clearRange:(x,y,x2,y2)=>{let end,indexStart,indexEnd;for(;y<=y2;++y){var start=y*w+x;end=y*w+x2;indexStart=start>>>5;indexEnd=end>>>5;if(indexStart===indexEnd)array[indexStart]&=RIGHT1[start&31]|RIGHT0[(end&31)+1];else for(array[indexStart]&=RIGHT1[start&31],array[indexEnd]&=RIGHT0[(end&31)+1],start=indexStart+1;start<indexEnd;++start)array[start]&=0}},outOfBounds:(x,y,x2,y2)=>0>x||0>y||y2>=h||x2>=w}}function scaler(width,height,padding){const ratio=
Math.max(1,Math.sqrt(width*height/1E6)),w=~~((width+2*padding+ratio)/ratio),h=~~((height+2*padding+ratio)/ratio),scale=_=>~~((_+padding)/ratio);scale.invert=_=>_*ratio-padding;scale.bitmap=()=>Bitmap(w,h);scale.ratio=ratio;scale.padding=padding;scale.width=width;scale.height=height;return scale}function outOfBounds(x,y,textWidth,textHeight,width,height){textWidth/=2;return 0>x-textWidth||x+textWidth>width||0>y-(textWidth=textHeight/2)||y+textWidth>height}function _outOfBounds(){return!1}function collision($,
x,y,textHeight,textWidth,h,bm0,bm1){textWidth=textWidth*h/(2*textHeight);textHeight=$(x-textWidth);x=$(x+textWidth);textWidth=$(y-(h/=2));$=$(y+h);return bm0.outOfBounds(textHeight,textWidth,x,$)||bm0.getRange(textHeight,textWidth,x,$)||bm1&&bm1.getRange(textHeight,textWidth,x,$)}function _collision($,x,y,textHeight,textWidth,h,bm0,bm1){textWidth=textWidth*h/(2*textHeight);textHeight=$(x-textWidth);x=$(x+textWidth);textWidth=$(y-(h/=2));y=$(y+h);textHeight=0<textHeight?textHeight:0;textWidth=0<textWidth?
textWidth:0;x=x<$.width?x:$.width-1;y=y<$.height?y:$.height-1;return bm0.getRange(textHeight,textWidth,x,y)||bm1&&bm1.getRange(textHeight,textWidth,x,y)}function placeMarkLabel($,bitmaps,anchors,offsets,infPadding){const width=$.width,height=$.height,bm0$jscomp$0=bitmaps[0],bm1$jscomp$0=bitmaps[1],n=offsets.length;return function(d){const boundary=d.boundary,textHeight=d.datum.fontSize;if(!infPadding&&(0>boundary[2]||0>boundary[5]||boundary[0]>width||boundary[3]>height))return!1;let textWidth=0,dx,
dy;let insideFactor,x1;let y2;let yc;let _y1,_y2;for(let i=0;i<n;++i){dx=(anchors[i]&3)-1;dy=(anchors[i]>>>2&3)-1;var isInside=0===dx&&0===dy||0>offsets[i];var sizeFactor=dx&&dy?Math.SQRT1_2:1;insideFactor=0>offsets[i]?-1:1;x1=boundary[1+dx]+offsets[i]*dx*sizeFactor;yc=boundary[4+dy]+insideFactor*textHeight*dy/2+offsets[i]*dy*sizeFactor;sizeFactor=yc-textHeight/2;y2=yc+textHeight/2;var _x1=$(x1);_y1=$(sizeFactor);_y2=$(y2);infPadding&&(_x1=0>_x1?0:_x1,_y1=0>_y1?0:_y1,_y2=_y2>=$.height?$.height-1:
_y2);if(!textWidth){var x2=_x1;var xc=_y1;var _x2=_y2;var bm0=bm0$jscomp$0,bm1=bm1$jscomp$0,x1$jscomp$0=x1,x2$jscomp$0=x1,y1=sizeFactor,y2$jscomp$0=y2,boundary$jscomp$0=boundary,isInside$jscomp$0=isInside;if(!bm0.outOfBounds(x2,xc,_x1,_x2)&&(isInside$jscomp$0&&bm1?!bm1.getRange(x2,xc,_x1,_x2)&&boundary$jscomp$0[0]<=x1$jscomp$0&&x2$jscomp$0<=boundary$jscomp$0[2]&&boundary$jscomp$0[3]<=y1&&y2$jscomp$0<=boundary$jscomp$0[5]:!bm0.getRange(x2,xc,_x1,_x2)))textWidth=vegaScenegraph.textMetrics.width(d.datum,
d.datum.text);else continue}xc=x1+insideFactor*textWidth*dx/2;x1=xc-textWidth/2;x2=xc+textWidth/2;_x1=$(x1);_x2=$(x2);infPadding&&(_x1=0>_x1?0:_x1,_x2=_x2>=$.width?$.width-1:_x2);bm0=_x1;bm1=_x2;x1$jscomp$0=_y1;x2$jscomp$0=_y2;y1=bm0$jscomp$0;y2$jscomp$0=bm1$jscomp$0;boundary$jscomp$0=x1;isInside$jscomp$0=x2;var y1$jscomp$0=sizeFactor,y2$jscomp$1=y2,boundary$jscomp$1=boundary;if(!y1.outOfBounds(bm0,x1$jscomp$0,bm1,x2$jscomp$0)&&(isInside&&y2$jscomp$0?!y2$jscomp$0.getRange(bm0,x1$jscomp$0,bm1,x2$jscomp$0)&&
boundary$jscomp$1[0]<=boundary$jscomp$0&&isInside$jscomp$0<=boundary$jscomp$1[2]&&boundary$jscomp$1[3]<=y1$jscomp$0&&y2$jscomp$1<=boundary$jscomp$1[5]:!y1.getRange(bm0,x1$jscomp$0,bm1,x2$jscomp$0)))return d.x=dx?0>dx*insideFactor?x2:x1:xc,d.y=dy?0>dy*insideFactor?y2:sizeFactor:yc,d.align=Aligns[dx*insideFactor+1],d.baseline=Baselines[dy*insideFactor+1],bm0$jscomp$0.setRange(_x1,_y1,_x2,_y2),!0}return!1}}function labelLayout(texts,size,compare,offset,anchor,avoidMarks,avoidBaseMark,lineAnchor,markIndex,
padding,method){if(!texts.length)return texts;var positions=Math.max(offset.length,anchor.length);offset=getOffsets(offset,positions);anchor=getAnchors(anchor,positions);positions=markType(texts[0].datum);var grouptype="group"===positions&&texts[0].datum.items[markIndex].marktype;const isGroupArea="area"===grouptype,boundary=markBoundary(positions,grouptype,lineAnchor,markIndex);lineAnchor=null===padding||Infinity===padding;size=scaler(size[0],size[1],lineAnchor?0:padding);grouptype=isGroupArea&&
"naive"===method;padding=texts.map(d=>({datum:d,opacity:0,x:void 0,y:void 0,align:void 0,baseline:void 0,boundary:boundary(d)}));if(!grouptype){compare&&padding.sort((a,b)=>compare(a.datum,b.datum));var bitmaps=!1;for(grouptype=0;grouptype<anchor.length&&!bitmaps;++grouptype)bitmaps=5===anchor[grouptype]||0>offset[grouptype];positions&&(avoidBaseMark||isGroupArea)&&(avoidMarks=[texts.map(d=>d.datum)].concat(avoidMarks));bitmaps=avoidMarks.length?markBitmaps(size,avoidMarks,bitmaps,isGroupArea):baseBitmaps(size,
avoidBaseMark&&padding)}const place=isGroupArea?placeAreaLabel[method](size,bitmaps,avoidBaseMark,markIndex,lineAnchor):placeMarkLabel(size,bitmaps,anchor,offset,lineAnchor);padding.forEach(d=>d.opacity=+place(d));return padding}function getOffsets(_,count){const offsets=new Float64Array(count),n=_.length;for(let i=0;i<n;++i)offsets[i]=_[i]||0;for(_=n;_<count;++_)offsets[_]=offsets[n-1];return offsets}function getAnchors(_,count){const anchors=new Int8Array(count),n=_.length;for(let i=0;i<n;++i)anchors[i]|=
anchorCode[_[i]];for(_=n;_<count;++_)anchors[_]=anchors[n-1];return anchors}function markType(item){return item&&item.mark&&item.mark.marktype}function markBoundary(marktype,grouptype,lineAnchor,markIndex){const xy=d=>[d.x,d.x,d.x,d.y,d.y,d.y];return marktype?"line"===marktype||"area"===marktype?d=>xy(d.datum):"line"===grouptype?d=>{d=d.datum.items[markIndex].items;return xy(d.length?d["start"===lineAnchor?0:d.length-1]:{x:NaN,y:NaN})}:d=>{d=d.datum.bounds;return[d.x1,(d.x1+d.x2)/2,d.x2,d.y1,(d.y1+
d.y2)/2,d.y2]}:xy}function Label(params){vegaDataflow.Transform.call(this,null,params)}const RIGHT0=new Uint32Array(33),RIGHT1=new Uint32Array(33);RIGHT1[0]=0;RIGHT0[0]=~RIGHT1[0];for(let i=1;32>=i;++i)RIGHT1[i]=RIGHT1[i-1]<<1|1,RIGHT0[i]=~RIGHT1[i];const X_DIR=[-1,-1,1,1],Y_DIR=[-1,1,-1,1],Aligns=["right","center","left"],Baselines=["bottom","middle","top"],anchorCode={"top-left":0,top:1,"top-right":2,left:4,middle:5,right:6,"bottom-left":8,bottom:9,"bottom-right":10},placeAreaLabel={naive:function($,
bitmaps,avoidBaseMark,markIndex){const width=$.width,height=$.height;return function(d){const items=d.datum.datum.items[markIndex].items,n=items.length,textHeight=d.datum.fontSize,textWidth=vegaScenegraph.textMetrics.width(d.datum,d.datum.text);let maxAreaWidth=0;let x2,y1,y2,x,y;for(let i=0;i<n;++i){var x1=items[i].x;y1=items[i].y;x2=void 0===items[i].x2?x1:items[i].x2;y2=void 0===items[i].y2?y1:items[i].y2;x=(x1+x2)/2;y=(y1+y2)/2;x1=Math.abs(x2-x1+y2-y1);x1>=maxAreaWidth&&(maxAreaWidth=x1,d.x=x,
d.y=y)}x=textWidth/2;y=textHeight/2;x1=d.x-x;x2=d.x+x;y1=d.y-y;y2=d.y+y;d.align="center";0>x1&&x2<=width?d.align="left":0<=x1&&width<x2&&(d.align="right");d.baseline="middle";0>y1&&y2<=height?d.baseline="top":0<=y1&&height<y2&&(d.baseline="bottom");return!0}},"reduced-search":function($,bitmaps,avoidBaseMark,markIndex,infPadding){function tryLabel(_x,_y,maxSize,textWidth,textHeight){_x=$.invert(_x);_y=$.invert(_y);let lo=maxSize,hi=height,mid;if(!outOfBounds$jscomp$0(_x,_y,textWidth,textHeight,width,
height)&&!collision$jscomp$0($,_x,_y,textHeight,textWidth,lo,bm0,bm1)&&!collision$jscomp$0($,_x,_y,textHeight,textWidth,textHeight,bm0,null)){for(;1<=hi-lo;)mid=(lo+hi)/2,collision$jscomp$0($,_x,_y,textHeight,textWidth,mid,bm0,bm1)?hi=mid:lo=mid;if(lo>maxSize)return[_x,_y,lo,!0]}}const width=$.width,height=$.height,[collision$jscomp$0,outOfBounds$jscomp$0]=infPadding?[_collision,_outOfBounds]:[collision,outOfBounds],bm0=bitmaps[0],bm1=bitmaps[1];return function(d){const items=d.datum.datum.items[markIndex].items,
n=items.length,textHeight=d.datum.fontSize,textWidth=vegaScenegraph.textMetrics.width(d.datum,d.datum.text);let maxSize=avoidBaseMark?textHeight:0,labelPlaced=!1,labelPlaced2=!1,maxAreaWidth=0;let x2;let y2;let _y,_x1,_xMid,_x2,_y1,_yMid,_y2,result;for(let i=0;i<n;++i){var x1=items[i].x;var y1=items[i].y;x2=void 0===items[i].x2?x1:items[i].x2;y2=void 0===items[i].y2?y1:items[i].y2;if(x1>x2){var _x=x1;x1=x2;x2=_x}y1>y2&&(_x=y1,y1=y2,y2=_x);_x1=$(x1);_x2=$(x2);_xMid=~~((_x1+_x2)/2);_y1=$(y1);_y2=$(y2);
_yMid=~~((_y1+_y2)/2);for(_x=_xMid;_x>=_x1;--_x)for(_y=_yMid;_y>=_y1;--_y)(result=tryLabel(_x,_y,maxSize,textWidth,textHeight))&&([d.x,d.y,maxSize,labelPlaced]=result);for(_x=_xMid;_x<=_x2;++_x)for(_y=_yMid;_y<=_y2;++_y)(result=tryLabel(_x,_y,maxSize,textWidth,textHeight))&&([d.x,d.y,maxSize,labelPlaced]=result);labelPlaced||avoidBaseMark||(_x=Math.abs(x2-x1+y2-y1),x1=(x1+x2)/2,y1=(y1+y2)/2,_x>=maxAreaWidth&&!outOfBounds$jscomp$0(x1,y1,textWidth,textHeight,width,height)&&!collision$jscomp$0($,x1,
y1,textHeight,textWidth,textHeight,bm0,null)&&(maxAreaWidth=_x,d.x=x1,d.y=y1,labelPlaced2=!0))}return labelPlaced||labelPlaced2?(x1=textWidth/2,y1=textHeight/2,bm0.setRange($(d.x-x1),$(d.y-y1),$(d.x+x1),$(d.y+y1)),d.align="center",d.baseline="middle",!0):!1}},floodfill:function($,bitmaps,avoidBaseMark,markIndex,infPadding){const width=$.width,height=$.height,[collision$jscomp$0,outOfBounds$jscomp$0]=infPadding?[_collision,_outOfBounds]:[collision,outOfBounds],bm0=bitmaps[0],bm1=bitmaps[1],bm2=$.bitmap();
return function(d){const items=d.datum.datum.items[markIndex].items,n=items.length,textHeight=d.datum.fontSize,textWidth=vegaScenegraph.textMetrics.width(d.datum,d.datum.text),stack=[];let maxSize=avoidBaseMark?textHeight:0,labelPlaced=!1,labelPlaced2=!1,maxAreaWidth=0,x1,x2,y1,y2,x,y;var mid;for(let i=0;i<n;++i){x1=items[i].x;y1=items[i].y;x2=void 0===items[i].x2?x1:items[i].x2;y2=void 0===items[i].y2?y1:items[i].y2;for(stack.push([$((x1+x2)/2),$((y1+y2)/2)]);stack.length;)if([_x,_y]=stack.pop(),
!(bm0.get(_x,_y)||bm1.get(_x,_y)||bm2.get(_x,_y))){bm2.set(_x,_y);for(mid=0;4>mid;++mid)x=_x+X_DIR[mid],y=_y+Y_DIR[mid],bm2.outOfBounds(x,y,x,y)||stack.push([x,y]);x=$.invert(_x);y=$.invert(_y);var _x=maxSize;var _y=height;if(!outOfBounds$jscomp$0(x,y,textWidth,textHeight,width,height)&&!collision$jscomp$0($,x,y,textHeight,textWidth,_x,bm0,bm1)&&!collision$jscomp$0($,x,y,textHeight,textWidth,textHeight,bm0,null)){for(;1<=_y-_x;)mid=(_x+_y)/2,collision$jscomp$0($,x,y,textHeight,textWidth,mid,bm0,bm1)?
_y=mid:_x=mid;_x>maxSize&&(d.x=x,d.y=y,maxSize=_x,labelPlaced=!0)}}labelPlaced||avoidBaseMark||(_x=Math.abs(x2-x1+y2-y1),x=(x1+x2)/2,y=(y1+y2)/2,_x>=maxAreaWidth&&!outOfBounds$jscomp$0(x,y,textWidth,textHeight,width,height)&&!collision$jscomp$0($,x,y,textHeight,textWidth,textHeight,bm0,null)&&(maxAreaWidth=_x,d.x=x,d.y=y,labelPlaced2=!0))}return labelPlaced||labelPlaced2?(x=textWidth/2,y=textHeight/2,bm0.setRange($(d.x-x),$(d.y-y),$(d.x+x),$(d.y+y)),d.align="center",d.baseline="middle",!0):!1}}},
Output=["x","y","opacity","align","baseline"],Anchors="top-left left bottom-left top bottom top-right right bottom-right".split(" ");Label.Definition={type:"Label",metadata:{modifies:!0},params:[{name:"size",type:"number",array:!0,length:2,required:!0},{name:"sort",type:"compare"},{name:"anchor",type:"string",array:!0,default:Anchors},{name:"offset",type:"number",array:!0,default:[1]},{name:"padding",type:"number",default:0,null:!0},{name:"lineAnchor",type:"string",values:["start","end"],default:"end"},
{name:"markIndex",type:"number",default:0},{name:"avoidBaseMark",type:"boolean",default:!0},{name:"avoidMarks",type:"data",array:!0},{name:"method",type:"string",default:"naive"},{name:"as",type:"string",array:!0,length:Output.length,default:Output}]};vegaUtil.inherits(Label,vegaDataflow.Transform,{transform(_,pulse){function modp(param){param=_[param];return vegaUtil.isFunction(param)&&pulse.modified(param.fields)}const mod=_.modified();if(mod||pulse.changed(pulse.ADD_REM)||modp("sort")){_.size&&
2===_.size.length||vegaUtil.error("Size parameter should be specified as a [width, height] array.");var as=_.as||Output;labelLayout(pulse.materialize(pulse.SOURCE).source||[],_.size,_.sort,vegaUtil.array(null==_.offset?1:_.offset),vegaUtil.array(_.anchor||Anchors),_.avoidMarks||[],!1!==_.avoidBaseMark,_.lineAnchor||"end",_.markIndex||0,void 0===_.padding?0:_.padding,_.method||"naive").forEach(l=>{const t=l.datum;t[as[0]]=l.x;t[as[1]]=l.y;t[as[2]]=l.opacity;t[as[3]]=l.align;t[as[4]]=l.baseline});return pulse.reflow(mod).modifies(as)}}});
exports.label=Label;Object.defineProperty(exports,"__esModule",{value:!0})})}
//# sourceMappingURL=module$node_modules$vega_label$build$vega_label.js.map
