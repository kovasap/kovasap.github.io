{"version":3,"sources":["app/comparison_matrix_table.cljs"],"mappings":"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","names":["app.comparison-matrix-table/-build--key","m","suffix","cljs.core.keyword","clojure.string.join","cljs.core/name","app.comparison-matrix-table/get-flat-biomarker-result-keys","filter-func","cljs.core.conj","cljs.core.into","iter__4652__auto__","s__48210","cljs.core/LazySeq","temp__5753__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__4650__auto__","size__4651__auto__","cljs.core/count","b__48212","cljs.core/chunk-buffer","i__48211","vec__48216","cljs.core/-nth","cljs.core.nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__48209","cljs.core/chunk-rest","vec__48220","cljs.core/first","cljs.core/cons","cljs.core/rest","k","v","app.comparison-matrix-table/make-per-input-row","same-input-results","regression-result-key-filter","cljs.core.reduce","cljs.core/merge","cljs.core.map","cljs.core.partial","app.comparison-matrix-table/add-aggregates","input-significant-correlations","flat-map","cljs.core.merge","fexpr__48236","app.comparison-matrix-table/column-element-ordering","app.comparison-matrix-table/get-column-element-order-key","string","p1__48237#","cljs.core.filter","cljs.core.map_indexed","index","element","clojure.string/includes?","app.comparison-matrix-table/column-name-compare-key","col-keyword","cljs.core._EQ_","vec__48248","col-name","data-type","clojure.string.split","app.comparison-matrix-table/compare-column-names","name1","name2","cljs.core/compare","app.comparison-matrix-table/make-comparison-matrix-data","results","p-values-rounded?","p1__48253#","per-input-rows","cljs.core/vals","cljs.core/group-by","p-value-filter","cljs.core/deref","cljs.core.not_EQ_","row","cljs.core/sorted-map-by","app.comparison-matrix-table/make-datagrid-column","vec__48259","biomarker","stat","clj-row","cljs.core.js__GT_clj","pval-key","app.stats/p-value-cutoff","cljs.core/contains?","clojure.set.union","app.single-var-table/aggregate-names","cljs.core/chunk-first"],"sourcesContent":["(ns app.comparison-matrix-table\n  (:require\n   [app.stats :as stats]\n   [app.single-var-table :refer [aggregate-names OneToManyCorrelation]]\n   [clojure.set :refer [union]]\n   [clojure.string :as st]))\n\n(defn -build--key\n  [m suffix]\n  (keyword (st/join \"--\" [(name (:biomarker m)) suffix])))\n\n(defn get-flat-biomarker-result-keys\n  \"Converts {:input :i :biomarker :b :results {:slope 5.0}} to\n  {:input :i :b--slope 5.0}\n\n  Also adds blank columns like :b--blank that add spacing between each\n  biomarker in the final visualizations.\n  \"\n  {:malli/schema [:=> [:cat\n                       [:=> [:cat :keyword] :boolean]\n                       [:map-of :keyword :any]]\n                  [:map-of :keyword :any]]}\n  [filter-func m]\n  (conj {:input (:input m)\n         (-build--key m \"blank\") \"\"}\n        (into {} (for [[k v] (:regression-results m)\n                       :when (filter-func k)]\n                   [(-build--key m (name k)) v]))))\n\n(defn make-per-input-row\n  [same-input-results regression-result-key-filter]\n  (reduce merge (map (partial get-flat-biomarker-result-keys\n                              regression-result-key-filter)\n                     same-input-results)))\n\n(defn add-aggregates\n  {:malli/schema\n   [:=> [:cat [:map-of :keyword OneToManyCorrelation] [:map-of :keyword :any]]\n    [:map-of :keyword :any]]}\n  [input-significant-correlations flat-map]\n  (merge flat-map (:aggregates\n                    ((:input flat-map) input-significant-correlations))))\n\n(def column-element-ordering\n  \"Column names should be sorted in the order signified by these substrings.\"\n  [\"correlation\" \"p-value\" \"datapoints\"])\n\n(defn get-column-element-order-key\n  [string]\n  (first\n    (filter #(not (nil? %))\n      (map-indexed (fn [index element] (if (st/includes? string element)\n                                         (str index string)\n                                         nil))\n                   column-element-ordering))))\n\n(defn column-name-compare-key\n  [col-keyword]\n  (cond\n    (= :input col-keyword)\n    \"AAAA\"\n    (= :score col-keyword)\n    \"AAAB\"\n    (st/includes? (name col-keyword) \"--\")\n    (let [[col-name data-type] (st/split (name col-keyword) #\"--\")]\n      (str col-name (get-column-element-order-key data-type)))\n    :else\n    (name col-keyword)))\n\n(defn compare-column-names\n  \"Comparison function for two names to be used when making a sorted-map-by.\n  \n  NOTE THAT the sorted-map-by requires UNIQUE comparison keys for distinct\n  items. If one item has the same comparison key as another only one item will\n  appear in the final map (seemly arbitrarily chosen)!\"\n  [name1 name2]\n  (compare (column-name-compare-key name1)\n           (column-name-compare-key name2)))\n\n(defn make-comparison-matrix-data\n  {:malli/schema\n   [:=> [:cat stats/PairwiseCorrelationsLite\n         [:map-of :keyword OneToManyCorrelation]\n         ; This is really an atom containing a boolean.\n         ; TODO encode this in malli.\n         :any]\n    [:sequential :map]]}\n  [results input-significant-correlations p-values-rounded?]\n  (let [per-input-rows (vals (group-by :input results))\n        p-value-filter #(if @p-values-rounded?\n                          (not= % :p-value)\n                          (not= % :rounded-p-value))]\n    (map (fn [row]\n           (into (sorted-map-by compare-column-names)\n                 (add-aggregates input-significant-correlations\n                                 (make-per-input-row row p-value-filter))))\n         per-input-rows)))\n\n(defn make-datagrid-column\n  \"Generates a react-data-grid column \n  https://github.com/adazzle/react-data-grid/blob/929911c506919e96bd12e48ea5de68ec9511ca10/src/types.ts#L7\"\n  [k]\n  (let [[biomarker stat] (st/split (name k) #\"\\-\\-\")]\n    {:cellClass\n     (fn [row]\n       (let [clj-row (js->clj row :keywordize-keys true)\n             pval-key (keyword (st/join \"--\" [biomarker \"p-value\"]))]\n         (cond\n           (nil? (pval-key clj-row))\n           \"\"\n           (< (pval-key clj-row) stats/p-value-cutoff)\n           \"\"\n           :else\n           \"has-text-grey-lighter\")))\n     :frozen\n     ; TODO get all the :aggregates keys from the spec here instead of\n     ; hardcoding\n     (if (contains? (union #{:input} aggregate-names) k)\n       true\n       false)}))\n\n\n"]}