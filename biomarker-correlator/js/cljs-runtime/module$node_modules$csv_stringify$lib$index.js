shadow$provide.module$node_modules$csv_stringify$lib$index=function(global,require,module,exports){var Buffer=require("module$node_modules$buffer$index").Buffer;"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.Stringifier=exports.CsvError=exports.stringify=void 0;global=require("module$node_modules$stream_browserify$index");const bom_utf8=Buffer.from([239,187,191]);class CsvError extends Error{constructor(code,message,...contexts){Array.isArray(message)&&(message=message.join(" "));
super(message);void 0!==Error.captureStackTrace&&Error.captureStackTrace(this,CsvError);this.code=code;for(const context of contexts)for(const key in context)code=context[key],this[key]=Buffer.isBuffer(code)?code.toString():null==code?code:JSON.parse(JSON.stringify(code))}}exports.CsvError=CsvError;const isObject=function(obj){return"object"===typeof obj&&null!==obj&&!Array.isArray(obj)},underscore=function(str){return str.replace(/([A-Z])/g,function(_,match){return"_"+match.toLowerCase()})},reEscapeChar=
/\\(\\)?/g,rePropName=RegExp("[^.[\\]]+|\\[(?:([^\"'][^[]*)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?\x3d(?:\\.|\\[\\])(?:\\.|\\[\\]|$))","g"),reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,isSymbol=function(value){var type=typeof value,JSCompiler_temp;if(!(JSCompiler_temp="symbol"===type)){if(type="object"===type&&value)value||(void 0===value?"[object Undefined]":"[object Null]"),type="[object Symbol]"===Object.prototype.toString.call(value);JSCompiler_temp=
type}return JSCompiler_temp},stringToPath=function(string){const result=[];46===string.charCodeAt(0)&&result.push("");string.replace(rePropName,function(match,expression,quote,subString){quote?match=subString.replace(reEscapeChar,"$1"):expression&&(match=expression.trim());result.push(match)});return result},get=function(object$jscomp$0,path){var object=object$jscomp$0;if(!Array.isArray(path)){if(Array.isArray(path))object=!1;else{var type=typeof path;object="number"===type||"symbol"===type||"boolean"===
type||!path||isSymbol(path)?!0:reIsPlainProp.test(path)||!reIsDeepProp.test(path)||null!=object&&path in Object(object)}path=object?[path]:stringToPath(path)}object=0;for(type=path.length;null!=object$jscomp$0&&object<type;){a:{var JSCompiler_inline_result=path[object++];if("string"===typeof JSCompiler_inline_result||isSymbol(JSCompiler_inline_result))break a;const result=`${JSCompiler_inline_result}`;JSCompiler_inline_result="0"==result&&1/JSCompiler_inline_result==-INFINITY?"-0":result}object$jscomp$0=
object$jscomp$0[JSCompiler_inline_result]}return object&&object===type?object$jscomp$0:void 0};class Stringifier extends global.Transform{constructor(opts){opts=void 0===opts?{}:opts;super(Object.assign({},{writableObjectMode:!0},opts));const options={};for(const opt in opts)options[underscore(opt)]=opts[opt];if(void 0!==(opts=this.normalize(options)))throw opts;switch(options.record_delimiter){case "auto":options.record_delimiter=null;break;case "unix":options.record_delimiter="\n";break;case "mac":options.record_delimiter=
"\r";break;case "windows":options.record_delimiter="\r\n";break;case "ascii":options.record_delimiter="";break;case "unicode":options.record_delimiter="\u2028"}this.options=options;this.state={stop:!1};this.info={records:0}}normalize(options){if(void 0===options.bom||null===options.bom||!1===options.bom)options.bom=!1;else if(!0!==options.bom)return new CsvError("CSV_OPTION_BOOLEAN_INVALID_TYPE",["option `bom` is optional and must be a boolean value,",`got ${JSON.stringify(options.bom)}`]);if(void 0===
options.delimiter||null===options.delimiter)options.delimiter=",";else if(Buffer.isBuffer(options.delimiter))options.delimiter=options.delimiter.toString();else if("string"!==typeof options.delimiter)return new CsvError("CSV_OPTION_DELIMITER_INVALID_TYPE",["option `delimiter` must be a buffer or a string,",`got ${JSON.stringify(options.delimiter)}`]);if(void 0===options.quote||null===options.quote)options.quote='"';else if(!0===options.quote)options.quote='"';else if(!1===options.quote)options.quote=
"";else if(Buffer.isBuffer(options.quote))options.quote=options.quote.toString();else if("string"!==typeof options.quote)return new CsvError("CSV_OPTION_QUOTE_INVALID_TYPE",["option `quote` must be a boolean, a buffer or a string,",`got ${JSON.stringify(options.quote)}`]);if(void 0===options.quoted||null===options.quoted)options.quoted=!1;if(void 0===options.quoted_empty||null===options.quoted_empty)options.quoted_empty=void 0;void 0===options.quoted_match||null===options.quoted_match||!1===options.quoted_match?
options.quoted_match=null:Array.isArray(options.quoted_match)||(options.quoted_match=[options.quoted_match]);if(options.quoted_match)for(const quoted_match of options.quoted_match){const isRegExp=quoted_match instanceof RegExp;if("string"!==typeof quoted_match&&!isRegExp)return Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`)}if(void 0===options.quoted_string||null===options.quoted_string)options.quoted_string=!1;if(void 0===options.eof||null===
options.eof)options.eof=!0;if(void 0===options.escape||null===options.escape)options.escape='"';else if(Buffer.isBuffer(options.escape))options.escape=options.escape.toString();else if("string"!==typeof options.escape)return Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`);if(1<options.escape.length)return Error(`Invalid Option: escape must be one character, got ${options.escape.length} characters`);if(void 0===options.header||null===options.header)options.header=
!1;const [err,columns]=this.normalize_columns(options.columns);if(err)return err;options.columns=columns;if(void 0===options.quoted||null===options.quoted)options.quoted=!1;if(void 0===options.cast||null===options.cast)options.cast={};if(void 0===options.cast.bigint||null===options.cast.bigint)options.cast.bigint=value=>""+value;if(void 0===options.cast.boolean||null===options.cast.boolean)options.cast.boolean=value=>value?"1":"";if(void 0===options.cast.date||null===options.cast.date)options.cast.date=
value=>""+value.getTime();if(void 0===options.cast.number||null===options.cast.number)options.cast.number=value=>""+value;if(void 0===options.cast.object||null===options.cast.object)options.cast.object=value=>JSON.stringify(value);if(void 0===options.cast.string||null===options.cast.string)options.cast.string=function(value){return value};if(void 0===options.record_delimiter||null===options.record_delimiter)options.record_delimiter="\n";else if(Buffer.isBuffer(options.record_delimiter))options.record_delimiter=
options.record_delimiter.toString();else if("string"!==typeof options.record_delimiter)return Error(`Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`)}_transform(chunk,encoding,callback){!0!==this.state.stop&&(chunk=this.__transform(chunk),void 0!==chunk&&(this.state.stop=!0),callback(chunk))}_flush(callback){if(!0!==this.state.stop){if(0===this.info.records){this.bom();const err=this.headers();err&&callback(err)}callback()}}__transform(chunk){if(!Array.isArray(chunk)&&
"object"!==typeof chunk)return Error(`Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`);if(0===this.info.records)if(Array.isArray(chunk)){if(!0===this.options.header&&void 0===this.options.columns)return Error("Undiscoverable Columns: header option requires column option or object records")}else if(void 0===this.options.columns){const [err,columns]=this.normalize_columns(Object.keys(chunk));if(err)return;this.options.columns=columns}if(0===this.info.records){this.bom();
var err$jscomp$0=this.headers();if(err$jscomp$0)return err$jscomp$0}try{this.emit("record",chunk,this.info.records)}catch(err){return err}if(this.options.eof){[chunk,err$jscomp$0]=this.stringify(chunk);if(chunk)return chunk;if(void 0===err$jscomp$0)return;err$jscomp$0+=this.options.record_delimiter}else{[chunk,err$jscomp$0]=this.stringify(chunk);if(chunk)return chunk;if(void 0===err$jscomp$0)return;if(this.options.header||this.info.records)err$jscomp$0=this.options.record_delimiter+err$jscomp$0}this.info.records++;
this.push(err$jscomp$0)}stringify(chunk,chunkIsHeader){chunkIsHeader=void 0===chunkIsHeader?!1:chunkIsHeader;if("object"!==typeof chunk)return[void 0,chunk];var {columns}=this.options;const record=[];if(Array.isArray(chunk))for(columns&&chunk.splice(columns.length),columns=0;columns<chunk.length;columns++){var field=chunk[columns];const [err,value]=this.__cast(field,{index:columns,column:columns,records:this.info.records,header:chunkIsHeader});if(err)return[err];record[columns]=[value,field]}else for(field=
0;field<columns.length;field++){var field$jscomp$2=get(chunk,columns[field].key);const [err,value]=this.__cast(field$jscomp$2,{index:field,column:columns[field].key,records:this.info.records,header:chunkIsHeader});if(err)return[err];record[field]=[value,field$jscomp$2]}chunk="";for(chunkIsHeader=0;chunkIsHeader<record.length;chunkIsHeader++){let err,[value,field$jscomp$0]=record[chunkIsHeader];if("string"===typeof value)columns=this.options;else if(isObject(value)){columns=value;value=columns.value;
delete columns.value;if("string"!==typeof value&&void 0!==value&&null!==value&&err)return[Error(`Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`)];columns=Object.assign({},this.options,columns);if(void 0!==(err=this.normalize(columns)))return[err]}else if(void 0===value||null===value)columns=this.options;else return[Error(`Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`)];
const {delimiter,escape,quote,quoted,quoted_empty,quoted_string,quoted_match:quoted_match$jscomp$0,record_delimiter}=columns;if(value){if("string"!==typeof value)return[Error(`Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`)];field$jscomp$2=delimiter.length&&0<=value.indexOf(delimiter);columns=""!==quote&&0<=value.indexOf(quote);field=0<=value.indexOf(escape)&&escape!==quote;const containsRecordDelimiter=0<=value.indexOf(record_delimiter),quotedString=quoted_string&&
"string"===typeof field$jscomp$0;let quotedMatch=quoted_match$jscomp$0&&quoted_match$jscomp$0.filter(quoted_match=>"string"===typeof quoted_match?-1!==value.indexOf(quoted_match):quoted_match.test(value));quotedMatch=quotedMatch&&0<quotedMatch.length;field$jscomp$2=!0===columns||field$jscomp$2||containsRecordDelimiter||quoted||quotedString||quotedMatch;!0===field$jscomp$2&&!0===field&&(value=value.replace("\\"===escape?new RegExp(escape+escape,"g"):new RegExp(escape,"g"),escape+escape));!0===columns&&
(value=value.replace(new RegExp(quote,"g"),escape+quote));!0===field$jscomp$2&&(value=quote+value+quote);chunk+=value}else if(!0===quoted_empty||""===field$jscomp$0&&!0===quoted_string&&!1!==quoted_empty)chunk+=quote+quote;chunkIsHeader!==record.length-1&&(chunk+=delimiter)}return[void 0,chunk]}bom(){!0===this.options.bom&&this.push(bom_utf8)}headers(){if(!1!==this.options.header&&void 0!==this.options.columns){var err,headers=this.options.columns.map(column=>column.header);this.options.eof?([err,
headers]=this.stringify(headers,!0),headers+=this.options.record_delimiter):[err,headers]=this.stringify(headers);if(err)return err;this.push(headers)}}__cast(value,context){const type=typeof value;try{return"string"===type?[void 0,this.options.cast.string(value,context)]:"bigint"===type?[void 0,this.options.cast.bigint(value,context)]:"number"===type?[void 0,this.options.cast.number(value,context)]:"boolean"===type?[void 0,this.options.cast.boolean(value,context)]:value instanceof Date?[void 0,this.options.cast.date(value,
context)]:"object"===type&&null!==value?[void 0,this.options.cast.object(value,context)]:[void 0,value,value]}catch(err){return[err]}}normalize_columns(columns){if(void 0===columns||null===columns)return[];if("object"!==typeof columns)return[Error('Invalid option "columns": expect an array or an object')];if(Array.isArray(columns)){var newcolumns=[];for(var column of columns)if("string"===typeof column)newcolumns.push({key:column,header:column});else{if("object"!==typeof column||void 0===column||
Array.isArray(column))return[Error("Invalid column definition: expect a string or an object")];if(!column.key)return[Error('Invalid column definition: property "key" is required')];void 0===column.header&&(column.header=column.key);newcolumns.push(column)}columns=newcolumns}else{column=[];for(newcolumns in columns)column.push({key:newcolumns,header:columns[newcolumns]});columns=column}return[void 0,columns]}}exports.Stringifier=Stringifier;exports.stringify=function(){let data;let callback;for(const i in arguments){const argument=
arguments[i],type=typeof argument;if(void 0===data&&Array.isArray(argument))data=argument;else if(void 0===options&&isObject(argument))var options=argument;else if(void 0===callback&&"function"===type)callback=argument;else throw new CsvError("CSV_INVALID_ARGUMENT",["Invalid argument:",`got ${JSON.stringify(argument)} at index ${i}`]);}const stringifier=new Stringifier(options);if(callback){const chunks=[];stringifier.on("readable",function(){let chunk;for(;null!==(chunk=this.read());)chunks.push(chunk)});
stringifier.on("error",function(err){callback(err)});stringifier.on("end",function(){callback(void 0,chunks.join(""))})}void 0!==data&&(options=function(){for(const record of data)stringifier.write(record);stringifier.end()},"function"===typeof setImmediate?setImmediate(options):setTimeout(options,0));return stringifier}}
//# sourceMappingURL=module$node_modules$csv_stringify$lib$index.js.map
