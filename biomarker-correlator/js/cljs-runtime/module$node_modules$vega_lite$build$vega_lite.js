shadow$provide.module$node_modules$vega_lite$build$vega_lite=function(global$jscomp$0,require,module$jscomp$0,exports$jscomp$0){var Buffer=require("module$node_modules$buffer$index").Buffer;(function(global,factory){"object"===typeof exports$jscomp$0&&"undefined"!==typeof module$jscomp$0?factory(exports$jscomp$0,require("module$node_modules$vega$build$vega_node")):"function"===typeof define&&define.amd?define(["exports","vega"],factory):(global="undefined"!==typeof globalThis?globalThis:global||self,
factory(global.vegaLite={},global.vega))})(this,function(exports,vega){function forEachLeaf(op,fn){if(op.not)forEachLeaf(op.not,fn);else if(op.and)for(const subop of op.and)forEachLeaf(subop,fn);else if(op.or)for(const subop of op.or)forEachLeaf(subop,fn);else fn(op)}function normalizeLogicalComposition(op,normalizer){return op.not?{not:normalizeLogicalComposition(op.not,normalizer)}:op.and?{and:op.and.map(o=>normalizeLogicalComposition(o,normalizer))}:op.or?{or:op.or.map(o=>normalizeLogicalComposition(o,
normalizer))}:normalizer(op)}function never(message){throw Error(message);}function pick(obj,props){const copy={};for(const prop of props)vega.hasOwnProperty(obj,prop)&&(copy[prop]=obj[prop]);return copy}function omit(obj,props){obj=Object.assign({},obj);for(const prop of props)delete obj[prop];return obj}function hash(a){if(vega.isNumber(a))return a;a=vega.isString(a)?a:fastJsonStableStringify(a);if(250>a.length)return a;let h=0;for(let i=0;i<a.length;i++){const char=a.charCodeAt(i);h=(h<<5)-h+char;
h&=h}return h}function isNullOrFalse(x){return!1===x||null===x}function contains(array,item){return array.includes(item)}function some(arr,f){let i=0;for(const $jscomp$destructuring$var0 of arr.entries()){const [k,a]=$jscomp$destructuring$var0;if(f(a,k,i++))return!0}return!1}function every(arr,f){let i=0;for(const $jscomp$destructuring$var1 of arr.entries()){const [k,a]=$jscomp$destructuring$var1;if(!f(a,k,i++))return!1}return!0}function mergeDeep(dest){for(var _len=arguments.length,src=Array(1<_len?
_len-1:0),_key=1;_key<_len;_key++)src[_key-1]=arguments[_key];for(const s of src){_len=dest;src=null!==s&&void 0!==s?s:{};for(const property of keys$jscomp$0(src))vega.writeConfig(_len,property,src[property],!0)}return dest}function unique(values,f){const results=[],u={};for(const val of values)values=f(val),values in u||(u[values]=1,results.push(val));return results}function setEqual(a,b){if(a.size!==b.size)return!1;for(const e of a)if(!b.has(e))return!1;return!0}function hasIntersection(a,b){for(const key of a)if(b.has(key))return!0;
return!1}function prefixGenerator(a){const prefixes=new Set;for(const x of a){const wrappedWithAccessors=vega.splitAccessPath(x).map((y,i)=>0===i?y:"[".concat(y,"]"));a=wrappedWithAccessors.map((_,i)=>wrappedWithAccessors.slice(0,i+1).join(""));for(const y of a)prefixes.add(y)}return prefixes}function fieldIntersection(a,b){return void 0===a||void 0===b?!0:hasIntersection(prefixGenerator(a),prefixGenerator(b))}function isEmpty(obj){return 0===keys$jscomp$0(obj).length}function isBoolean(b){return!0===
b||!1===b}function varName(s){const alphanumericS=s.replace(/\W/g,"_");return(s.match(/^\d+/)?"_":"")+alphanumericS}function logicalExpr(op,cb){return op.not?"!(".concat(logicalExpr(op.not,cb),")"):op.and?"(".concat(op.and.map(and=>logicalExpr(and,cb)).join(") \x26\x26 ("),")"):op.or?"(".concat(op.or.map(or=>logicalExpr(or,cb)).join(") || ("),")"):cb(op)}function deleteNestedProperty(obj,orderedProps){if(0===orderedProps.length)return!0;const prop=orderedProps.shift();prop in obj&&deleteNestedProperty(obj[prop],
orderedProps)&&delete obj[prop];return isEmpty(obj)}function titleCase(s){return s.charAt(0).toUpperCase()+s.substr(1)}function accessPathWithDatum(path){let datum=1<arguments.length&&void 0!==arguments[1]?arguments[1]:"datum";const pieces=vega.splitAccessPath(path),prefixes=[];for(let i=1;i<=pieces.length;i++){const prefix="[".concat(pieces.slice(0,i).map(vega.stringValue).join("]["),"]");prefixes.push("".concat(datum).concat(prefix))}return prefixes.join(" \x26\x26 ")}function flatAccessWithDatum(path){return"".concat(1<
arguments.length&&void 0!==arguments[1]?arguments[1]:"datum","[").concat(vega.stringValue(vega.splitAccessPath(path).join(".")),"]")}function escapePathAccess(string){return string.replace(/(\[|\]|\.|'|")/g,"\\$1")}function replacePathInField(path){return"".concat(vega.splitAccessPath(path).map(escapePathAccess).join("\\."))}function replaceAll(string,find,replacement){return string.replace(new RegExp(find.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$\x26"),"g"),replacement)}function removePathFromField(path){return"".concat(vega.splitAccessPath(path).join("."))}
function accessPathDepth(path){return path?vega.splitAccessPath(path).length:0}function getFirstDefined(){for(var _len2=arguments.length,args=Array(_len2),_key2=0;_key2<_len2;_key2++)args[_key2]=arguments[_key2];for(const arg of args)if(void 0!==arg)return arg}function uniqueId(prefix){const id=++idCounter;return prefix?String(prefix)+id:id}function internalField(name){return isInternalField(name)?name:"__".concat(name)}function isInternalField(name){return name.startsWith("__")}function normalizeAngle(angle){if(void 0!==
angle)return(angle%360+360)%360}function isNumeric(value){return vega.isNumber(value)?!0:!isNaN(value)&&!isNaN(parseFloat(value))}function getPositionChannelFromLatLong(channel){switch(channel){case "latitude":return"y";case "latitude2":return"y2";case "longitude":return"x";case "longitude2":return"x2"}}function isColorChannel(channel){return"color"===channel||"fill"===channel||"stroke"===channel}function isSecondaryRangeChannel(c){return getMainRangeChannel(c)!==c}function getMainRangeChannel(channel){switch(channel){case "x2":return"x";
case "y2":return"y";case "latitude2":return"latitude";case "longitude2":return"longitude";case "theta2":return"theta";case "radius2":return"radius"}return channel}function getVgPositionChannel(channel){if(channel in POLAR_POSITION_CHANNEL_INDEX)switch(channel){case "theta":return"startAngle";case "theta2":return"endAngle";case "radius":return"outerRadius";case "radius2":return"innerRadius"}return channel}function getSecondaryRangeChannel(channel){switch(channel){case "x":return"x2";case "y":return"y2";
case "latitude":return"latitude2";case "longitude":return"longitude2";case "theta":return"theta2";case "radius":return"radius2"}}function getSizeChannel(channel){switch(channel){case "x":case "x2":return"width";case "y":case "y2":return"height"}}function getOffsetChannel(channel){switch(channel){case "x":return"xOffset";case "y":return"yOffset";case "x2":return"x2Offset";case "y2":return"y2Offset";case "theta":return"thetaOffset";case "radius":return"radiusOffset";case "theta2":return"theta2Offset";
case "radius2":return"radius2Offset"}}function getOffsetScaleChannel(channel){switch(channel){case "x":return"xOffset";case "y":return"yOffset"}}function getMainChannelFromOffsetChannel(channel){switch(channel){case "xOffset":return"x";case "yOffset":return"y"}}function isXorY(channel){return channel in POSITION_SCALE_CHANNEL_INDEX}function getPositionScaleChannel(sizeType){return"width"===sizeType?"x":"y"}function getSupportedMark(channel){switch(channel){case "color":case "fill":case "stroke":case "description":case "detail":case "key":case "tooltip":case "href":case "order":case "opacity":case "fillOpacity":case "strokeOpacity":case "strokeWidth":case "facet":case "row":case "column":return ALL_MARKS;
case "x":case "y":case "xOffset":case "yOffset":case "latitude":case "longitude":return ALL_MARKS_EXCEPT_GEOSHAPE;case "x2":case "y2":case "latitude2":case "longitude2":return{area:"always",bar:"always",image:"always",rect:"always",rule:"always",circle:"binned",point:"binned",square:"binned",tick:"binned",line:"binned",trail:"binned"};case "size":return{point:"always",tick:"always",rule:"always",circle:"always",square:"always",bar:"always",text:"always",line:"always",trail:"always"};case "strokeDash":return{line:"always",
point:"always",tick:"always",rule:"always",circle:"always",square:"always",bar:"always",geoshape:"always"};case "shape":return{point:"always",geoshape:"always"};case "text":return{text:"always"};case "angle":return{point:"always",square:"always",text:"always"};case "url":return{image:"always"};case "theta":return{text:"always",arc:"always"};case "radius":return{text:"always",arc:"always"};case "theta2":case "radius2":return{arc:"always"}}}function rangeType(channel){switch(channel){case "facet":case "row":case "column":case "shape":case "strokeDash":case "text":case "tooltip":case "href":case "url":case "description":return"discrete";
case "color":case "fill":case "stroke":return"flexible"}}function isArgminDef(a){return!!a&&!!a.argmin}function isArgmaxDef(a){return!!a&&!!a.argmax}function isAggregateOp(a){return vega.isString(a)&&!!AGGREGATE_OP_INDEX[a]}function isCountingAggregateOp(aggregate){return vega.isString(aggregate)&&COUNTING_OPS.has(aggregate)}function binToString(bin){vega.isBoolean(bin)&&(bin=normalizeBin(bin,void 0));return"bin"+keys$jscomp$0(bin).map(p=>isParameterExtent(bin[p])?varName("_".concat(p,"_").concat(entries$1(bin[p]))):
varName("_".concat(p,"_").concat(bin[p]))).join("")}function isBinning(bin){return!0===bin||vega.isObject(bin)&&!bin.binned}function isBinned(bin){return"binned"===bin||vega.isObject(bin)&&!0===bin.binned}function isParameterExtent(extent){return null===extent||void 0===extent?void 0:extent.param}function autoMaxBins(channel){switch(channel){case "row":case "column":case "size":case "color":case "fill":case "stroke":case "strokeWidth":case "opacity":case "fillOpacity":case "strokeOpacity":case "shape":return 6;
case "strokeDash":return 4;default:return 10}}function isExprRef(o){return o&&!!o.expr}function replaceExprRef(index){const props=keys$jscomp$0(index||{}),newIndex={};for(const prop of props)newIndex[prop]=signalRefOrValue(index[prop]);return newIndex}function extractTitleConfig(titleConfig){var $jscomp$destructuring$var13=Object.assign({},titleConfig),anchor=titleConfig.anchor;const frame=titleConfig.frame,offset=titleConfig.offset,orient=titleConfig.orient,angle=titleConfig.angle,limit=titleConfig.limit;
var color=titleConfig.color,subtitleColor=titleConfig.subtitleColor;const subtitleFont=titleConfig.subtitleFont,subtitleFontSize=titleConfig.subtitleFontSize,subtitleFontStyle=titleConfig.subtitleFontStyle,subtitleFontWeight=titleConfig.subtitleFontWeight,subtitleLineHeight=titleConfig.subtitleLineHeight,subtitlePadding=titleConfig.subtitlePadding;$jscomp$destructuring$var13=(delete $jscomp$destructuring$var13.anchor,delete $jscomp$destructuring$var13.frame,delete $jscomp$destructuring$var13.offset,
delete $jscomp$destructuring$var13.orient,delete $jscomp$destructuring$var13.angle,delete $jscomp$destructuring$var13.limit,delete $jscomp$destructuring$var13.color,delete $jscomp$destructuring$var13.subtitleColor,delete $jscomp$destructuring$var13.subtitleFont,delete $jscomp$destructuring$var13.subtitleFontSize,delete $jscomp$destructuring$var13.subtitleFontStyle,delete $jscomp$destructuring$var13.subtitleFontWeight,delete $jscomp$destructuring$var13.subtitleLineHeight,delete $jscomp$destructuring$var13.subtitlePadding,
$jscomp$destructuring$var13);color=Object.assign({},$jscomp$destructuring$var13,color?{fill:color}:{});anchor=Object.assign({},anchor?{anchor}:{},frame?{frame}:{},offset?{offset}:{},orient?{orient}:{},void 0!==angle?{angle}:{},void 0!==limit?{limit}:{});subtitleColor=Object.assign({},subtitleColor?{subtitleColor}:{},subtitleFont?{subtitleFont}:{},subtitleFontSize?{subtitleFontSize}:{},subtitleFontStyle?{subtitleFontStyle}:{},subtitleFontWeight?{subtitleFontWeight}:{},subtitleLineHeight?{subtitleLineHeight}:
{},subtitlePadding?{subtitlePadding}:{});titleConfig=pick(titleConfig,["align","baseline","dx","dy","limit"]);return{titleMarkConfig:color,subtitleMarkConfig:titleConfig,nonMarkTitleProperties:anchor,subtitle:subtitleColor}}function isText(v){return vega.isString(v)||vega.isArray(v)&&vega.isString(v[0])}function isSignalRef(o){return o&&!!o.signal}function isVgRangeStep(range){return!!range.step}function isDataRefDomain(domain){return vega.isArray(domain)?!1:"field"in domain&&"data"in domain}function signalOrValueRefWithCondition(val){const condition=
vega.isArray(val.condition)?val.condition.map(conditionalSignalRefOrValue):conditionalSignalRefOrValue(val.condition);return Object.assign({},signalRefOrValue(val),{condition})}function signalRefOrValue(value){if(isExprRef(value)){var $jscomp$destructuring$var15=Object.assign({},value);value=value.expr;$jscomp$destructuring$var15=(delete $jscomp$destructuring$var15.expr,$jscomp$destructuring$var15);return Object.assign({},{signal:value},$jscomp$destructuring$var15)}return value}function conditionalSignalRefOrValue(value){if(isExprRef(value)){var $jscomp$destructuring$var17=
Object.assign({},value);value=value.expr;$jscomp$destructuring$var17=(delete $jscomp$destructuring$var17.expr,$jscomp$destructuring$var17);return Object.assign({},{signal:value},$jscomp$destructuring$var17)}return value}function signalOrValueRef(value){if(isExprRef(value)){var $jscomp$destructuring$var19=Object.assign({},value);value=value.expr;$jscomp$destructuring$var19=(delete $jscomp$destructuring$var19.expr,$jscomp$destructuring$var19);return Object.assign({},{signal:value},$jscomp$destructuring$var19)}return isSignalRef(value)?
value:void 0!==value?{value}:void 0}function exprFromValueRefOrSignalRef(ref){return isSignalRef(ref)?ref.signal:vega.stringValue(ref.value)}function signalOrStringValue(v){return isSignalRef(v)?v.signal:null==v?null:vega.stringValue(v)}function getStyles(mark){var _mark$style;return[].concat(mark.type,null!==(_mark$style=mark.style)&&void 0!==_mark$style?_mark$style:[])}function getMarkPropOrConfig(channel,mark,config){let opt=3<arguments.length&&void 0!==arguments[3]?arguments[3]:{};const {vgChannel,
ignoreVgConfig}=opt;if(vgChannel&&void 0!==mark[vgChannel])return mark[vgChannel];if(void 0!==mark[channel])return mark[channel];if(!ignoreVgConfig||vgChannel&&vgChannel!==channel)return getMarkConfig(channel,mark,config,opt)}function getMarkConfig(channel,mark,config){let {vgChannel}=3<arguments.length&&void 0!==arguments[3]?arguments[3]:{};return getFirstDefined(vgChannel?getMarkStyleConfig(channel,mark,config.style):void 0,getMarkStyleConfig(channel,mark,config.style),vgChannel?config[mark.type][vgChannel]:
void 0,config[mark.type][channel],vgChannel?config.mark[vgChannel]:config.mark[channel])}function getMarkStyleConfig(prop,mark,styleConfigIndex){return getStyleConfig(prop,getStyles(mark),styleConfigIndex)}function getStyleConfig(p,styles,styleConfigIndex){styles=vega.array(styles);let value;for(const style of styles)(styles=styleConfigIndex[style])&&void 0!==styles[p]&&(value=styles[p]);return value}function sortParams(orderDef,fieldRefOption){return vega.array(orderDef).reduce((s,orderChannelDef)=>
{var _orderChannelDef$sort;s.field.push(vgField(orderChannelDef,fieldRefOption));s.order.push(null!==(_orderChannelDef$sort=orderChannelDef.sort)&&void 0!==_orderChannelDef$sort?_orderChannelDef$sort:"ascending");return s},{field:[],order:[]})}function mergeTitleFieldDefs(f1,f2){const merged=[...f1];f2.forEach(fdToMerge=>{for(const fieldDef1 of merged)if(deepEqual(fieldDef1,fdToMerge))return;merged.push(fdToMerge)});return merged}function mergeTitle(title1,title2){return deepEqual(title1,title2)||
!title2?title1:title1?[...vega.array(title1),...vega.array(title2)].join(", "):title2}function mergeTitleComponent(v1,v2){const v1Val=v1.value;v2=v2.value;if(null==v1Val||null===v2)return{explicit:v1.explicit,value:null};if((isText(v1Val)||isSignalRef(v1Val))&&(isText(v2)||isSignalRef(v2)))return{explicit:v1.explicit,value:mergeTitle(v1Val,v2)};if(isText(v1Val)||isSignalRef(v1Val))return{explicit:v1.explicit,value:v1Val};if(isText(v2)||isSignalRef(v2))return{explicit:v1.explicit,value:v2};if(!(isText(v1Val)||
isSignalRef(v1Val)||isText(v2)||isSignalRef(v2)))return{explicit:v1.explicit,value:mergeTitleFieldDefs(v1Val,v2)};throw Error("It should never reach here");}function _defineProperty(obj,key,value){key in obj?Object.defineProperty(obj,key,{value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value;return obj}function _classPrivateFieldSet(receiver,privateMap,value){privateMap=_classExtractFieldDescriptor(receiver,privateMap,"set");if(privateMap.set)privateMap.set.call(receiver,value);else{if(!privateMap.writable)throw new TypeError("attempted to set read only private field");
privateMap.value=value}return value}function _classExtractFieldDescriptor(receiver,privateMap,action){if(!privateMap.has(receiver))throw new TypeError("attempted to "+action+" private field on non-instance");return privateMap.get(receiver)}function invalidSpec(spec){return"Invalid specification ".concat(stringify(spec),'. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".')}function containerSizeNonSingle(name){return"".concat("width"==
name?"Width":"Height",' "container" only works for single views and layered views.')}function containerSizeNotCompatibleWithAutosize(name){const fitDirection="width"==name?"x":"y";return"".concat("width"==name?"Width":"Height",' "container" only works well with autosize "fit" or "fit-').concat(fitDirection,'".')}function droppingFit(channel){return channel?'Dropping "fit-'.concat(channel,'" because spec has discrete ').concat(getSizeChannel(channel),"."):'Dropping "fit" because spec has discrete size.'}
function unknownField(channel){return"Unknown field for ".concat(channel,". Cannot calculate view size.")}function cannotProjectOnChannelWithoutField(channel){return'Cannot project a selection on encoding channel "'.concat(channel,'", which has no field.')}function cannotProjectAggregate(channel,aggregate){return'Cannot project a selection on encoding channel "'.concat(channel,'" as it uses an aggregate function ("').concat(aggregate,'").')}function selectionNotSupported(mark){return"Selection not supported for ".concat(mark,
" yet.")}function columnsNotSupportByRowCol(type){return'The "columns" property cannot be used when "'.concat(type,'" has nested row/column.')}function differentParse(field,local,ancestor){return'An ancestor parsed field "'.concat(field,'" as ').concat(ancestor," but a child wants to parse the field as ").concat(local,".")}function customFormatTypeNotAllowed(channel){return"Config.customFormatTypes is not true, thus custom format type and format for channel ".concat(channel," are dropped.")}function offsetNestedInsideContinuousPositionScaleDropped(mainChannel){return"".concat(mainChannel,
"Offset dropped because ").concat(mainChannel," is continuous")}function replaceOffsetWithMainChannel(mainChannel){return"There is no ".concat(mainChannel," encoding. Replacing ").concat(mainChannel,"Offset encoding as ").concat(mainChannel,".")}function droppingColor(type,opt){const {fill,stroke}=opt;return"Dropping color ".concat(type," as the plot also has ").concat(fill&&stroke?"fill and stroke":fill?"fill":"stroke",".")}function emptyFieldDef(fieldDef,channel){return"Dropping ".concat(stringify(fieldDef),
' from channel "').concat(channel,'" since it does not contain any data field, datum, value, or signal.')}function incompatibleChannel(channel,markOrFacet,when){return"".concat(channel,' dropped as it is incompatible with "').concat(markOrFacet,'"').concat(when?" when ".concat(when):"",".")}function invalidEncodingChannel(channel){return"".concat(channel,"-encoding is dropped as ").concat(channel," is not a valid encoding channel.")}function discreteChannelCannotEncode(channel,type){return'Using discrete channel "'.concat(channel,
'" to encode "').concat(type,'" field can be misleading as it does not encode ').concat("ordinal"===type?"order":"magnitude",".")}function scalePropertyNotWorkWithScaleType(scaleType,propName,channel){return"".concat(channel,"-scale's \"").concat(propName,'" is dropped as it does not work with ').concat(scaleType," scale.")}function stepDropped(channel){return'The step for "'.concat(channel,'" is dropped because the ').concat("width"===channel?"x":"y"," is continuous.")}function cannotStackRangedMark(channel){return'Cannot stack "'.concat(channel,
'" if there is already "').concat(channel,'2".')}function invalidTimeUnit(unitName,value){return"Invalid ".concat(unitName,": ").concat(stringify(value),".")}function errorBand1DNotSupport(property){return"1D error band does not support ".concat(property,".")}function channelRequiredForBinned(channel){return"Channel ".concat(channel,' is required for "binned" bin.')}function warn(){current.warn(...arguments)}function debug(){current.debug(...arguments)}function isDateTime(o){if(o&&vega.isObject(o))for(const part of TIMEUNIT_PARTS)if(part in
o)return!0;return!1}function normalizeMonth(m){isNumeric(m)&&(m=+m);if(vega.isNumber(m))return m-1;var lowerM=m.toLowerCase();const monthIndex=MONTHS.indexOf(lowerM);if(-1!==monthIndex)return monthIndex;lowerM=lowerM.substr(0,3);lowerM=SHORT_MONTHS.indexOf(lowerM);if(-1!==lowerM)return lowerM;throw Error(invalidTimeUnit("month",m));}function normalizeDay(d){isNumeric(d)&&(d=+d);if(vega.isNumber(d))return d%7;var lowerD=d.toLowerCase();const dayIndex=DAYS.indexOf(lowerD);if(-1!==dayIndex)return dayIndex;
lowerD=lowerD.substr(0,3);lowerD=SHORT_DAYS.indexOf(lowerD);if(-1!==lowerD)return lowerD;throw Error(invalidTimeUnit("day",d));}function dateTimeParts(d,normalize){const parts=[];normalize&&void 0!==d.day&&1<keys$jscomp$0(d).length&&(warn("Dropping day from datetime ".concat(stringify(d)," as day cannot be combined with other units.")),d=duplicate(d),delete d.day);void 0!==d.year?parts.push(d.year):parts.push(2012);if(void 0!==d.month){var month=normalize?normalizeMonth(d.month):d.month;parts.push(month)}else if(void 0!==
d.quarter){if(normalize)if(month=d.quarter,isNumeric(month)&&(month=+month),vega.isNumber(month))4<month&&warn(invalidTimeUnit("quarter",month)),--month;else throw Error(invalidTimeUnit("quarter",month));else month=d.quarter;parts.push(vega.isNumber(month)?3*month:"".concat(month,"*3"))}else parts.push(0);void 0!==d.date?parts.push(d.date):void 0!==d.day?(normalize=normalize?normalizeDay(d.day):d.day,parts.push(vega.isNumber(normalize)?normalize+1:"".concat(normalize,"+1"))):parts.push(1);for(const timeUnit of["hours",
"minutes","seconds","milliseconds"])normalize=d[timeUnit],parts.push("undefined"===typeof normalize?0:normalize);return parts}function dateTimeToExpr(d){const string=dateTimeParts(d,!0).join(", ");return d.utc?"utc(".concat(string,")"):"datetime(".concat(string,")")}function dateTimeToTimestamp(d){const parts=dateTimeParts(d,!0);return d.utc?+new Date(Date.UTC(...parts)):+new Date(...parts)}function getTimeUnitParts(timeUnit){return TIMEUNIT_PARTS.filter(part=>containsTimeUnit(timeUnit,part))}function containsTimeUnit(fullTimeUnit,
timeUnit){const index=fullTimeUnit.indexOf(timeUnit);return 0>index||0<index&&"seconds"===timeUnit&&"i"===fullTimeUnit.charAt(index-1)||fullTimeUnit.length>index+3&&"day"===timeUnit&&"o"===fullTimeUnit.charAt(index+3)||0<index&&"year"===timeUnit&&"f"===fullTimeUnit.charAt(index-1)?!1:!0}function fieldExpr(fullTimeUnit,field){var {end}=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{end:!1};const fieldRef=accessPathWithDatum(field),utc=fullTimeUnit.startsWith("utc")?"utc":"";const dateExpr=
{};for(const part of TIMEUNIT_PARTS)if(containsTimeUnit(fullTimeUnit,part)){var lastTimeUnit=part;lastTimeUnit="quarter"===lastTimeUnit?"(".concat(utc,"quarter(").concat(fieldRef,")-1)"):"".concat(utc).concat(lastTimeUnit,"(").concat(fieldRef,")");dateExpr[part]=lastTimeUnit;lastTimeUnit=part}end&&(dateExpr[lastTimeUnit]+="+1");end=dateTimeParts(dateExpr,!1).join(", ");return dateExpr.utc?"utc(".concat(end,")"):"datetime(".concat(end,")")}function timeUnitSpecifierExpression(timeUnit){if(timeUnit)return timeUnit=
getTimeUnitParts(timeUnit),"timeUnitSpecifier(".concat(stringify(timeUnit),", ").concat(stringify(VEGALITE_TIMEFORMAT),")")}function normalizeTimeUnit(timeUnit){if(timeUnit){var params;vega.isString(timeUnit)?params={unit:timeUnit}:vega.isObject(timeUnit)&&(params=Object.assign({},timeUnit,timeUnit.unit?{unit:timeUnit.unit}:{}));params.unit.startsWith("utc")&&(params.utc=!0,params.unit=params.unit.substr(3));return params}}function timeUnitToString(tu){var $jscomp$destructuring$var20=normalizeTimeUnit(tu);
tu=Object.assign({},$jscomp$destructuring$var20);$jscomp$destructuring$var20=$jscomp$destructuring$var20.utc;const rest=(delete tu.utc,tu);return rest.unit?($jscomp$destructuring$var20?"utc":"")+keys$jscomp$0(rest).map(p=>varName("".concat("unit"===p?"":"_".concat(p,"_")).concat(rest[p]))).join(""):($jscomp$destructuring$var20?"utc":"")+"timeunit"+keys$jscomp$0(rest).map(p=>varName("_".concat(p,"_").concat(rest[p]))).join("")}function isFieldEqualPredicate(predicate){return predicate&&!!predicate.field&&
void 0!==predicate.equal}function isFieldLTPredicate(predicate){return predicate&&!!predicate.field&&void 0!==predicate.lt}function isFieldLTEPredicate(predicate){return predicate&&!!predicate.field&&void 0!==predicate.lte}function isFieldGTPredicate(predicate){return predicate&&!!predicate.field&&void 0!==predicate.gt}function isFieldGTEPredicate(predicate){return predicate&&!!predicate.field&&void 0!==predicate.gte}function isFieldRangePredicate(predicate){return null!==predicate&&void 0!==predicate&&
predicate.field&&(vega.isArray(predicate.range)&&2===predicate.range.length||isSignalRef(predicate.range))?!0:!1}function isFieldOneOfPredicate(predicate){return predicate&&!!predicate.field&&(vega.isArray(predicate.oneOf)||vega.isArray(predicate.in))}function isFieldPredicate(predicate){return isFieldOneOfPredicate(predicate)||isFieldEqualPredicate(predicate)||isFieldRangePredicate(predicate)||isFieldLTPredicate(predicate)||isFieldGTPredicate(predicate)||isFieldLTEPredicate(predicate)||isFieldGTEPredicate(predicate)}
function predicateValueExpr(v,timeUnit){return valueExpr(v,{timeUnit,wrapTime:!0})}function predicateValuesExpr(vals,timeUnit){return vals.map(v=>predicateValueExpr(v,timeUnit))}function fieldFilterExpression(predicate){var _normalizeTimeUnit,useInRange=1<arguments.length&&void 0!==arguments[1]?arguments[1]:!0,{field}=predicate;const timeUnit=null===(_normalizeTimeUnit=normalizeTimeUnit(predicate.timeUnit))||void 0===_normalizeTimeUnit?void 0:_normalizeTimeUnit.unit;_normalizeTimeUnit=timeUnit?"time(".concat(fieldExpr(timeUnit,
field),")"):vgField(predicate,{expr:"datum"});if(isFieldEqualPredicate(predicate))return"".concat(_normalizeTimeUnit,"\x3d\x3d\x3d").concat(predicateValueExpr(predicate.equal,timeUnit));if(isFieldLTPredicate(predicate))return useInRange=predicate.lt,"".concat(_normalizeTimeUnit,"\x3c").concat(predicateValueExpr(useInRange,timeUnit));if(isFieldGTPredicate(predicate))return useInRange=predicate.gt,"".concat(_normalizeTimeUnit,"\x3e").concat(predicateValueExpr(useInRange,timeUnit));if(isFieldLTEPredicate(predicate))return useInRange=
predicate.lte,"".concat(_normalizeTimeUnit,"\x3c\x3d").concat(predicateValueExpr(useInRange,timeUnit));if(isFieldGTEPredicate(predicate))return useInRange=predicate.gte,"".concat(_normalizeTimeUnit,"\x3e\x3d").concat(predicateValueExpr(useInRange,timeUnit));if(isFieldOneOfPredicate(predicate))return"indexof([".concat(predicateValuesExpr(predicate.oneOf,timeUnit).join(","),"], ").concat(_normalizeTimeUnit,") !\x3d\x3d -1");if(predicate&&predicate.field&&void 0!==predicate.valid)return fieldValidPredicate(_normalizeTimeUnit,
predicate.valid);if(isFieldRangePredicate(predicate)){var {range}=predicate;field=isSignalRef(range)?{signal:"".concat(range.signal,"[0]")}:range[0];range=isSignalRef(range)?{signal:"".concat(range.signal,"[1]")}:range[1];if(null!==field&&null!==range&&useInRange)return"inrange("+_normalizeTimeUnit+", ["+predicateValueExpr(field,timeUnit)+", "+predicateValueExpr(range,timeUnit)+"])";useInRange=[];null!==field&&useInRange.push("".concat(_normalizeTimeUnit," \x3e\x3d ").concat(predicateValueExpr(field,
timeUnit)));null!==range&&useInRange.push("".concat(_normalizeTimeUnit," \x3c\x3d ").concat(predicateValueExpr(range,timeUnit)));return 0<useInRange.length?useInRange.join(" \x26\x26 "):"true"}throw Error("Invalid field predicate: ".concat(stringify(predicate)));}function fieldValidPredicate(fieldExpr){return(1<arguments.length&&void 0!==arguments[1]?arguments[1]:1)?"isValid(".concat(fieldExpr,") \x26\x26 isFinite(+").concat(fieldExpr,")"):"!isValid(".concat(fieldExpr,") || !isFinite(+").concat(fieldExpr,
")")}function normalizePredicate$1(f){if(isFieldPredicate(f)&&f.timeUnit){var _normalizeTimeUnit2;return Object.assign({},f,{timeUnit:null===(_normalizeTimeUnit2=normalizeTimeUnit(f.timeUnit))||void 0===_normalizeTimeUnit2?void 0:_normalizeTimeUnit2.unit})}return f}function isContinuous(type){return"quantitative"===type||"temporal"===type}function isDiscrete$1(type){return"ordinal"===type||"nominal"===type}function getFullName(type){if(type)switch(type=type.toLowerCase(),type){case "q":case "quantitative":return"quantitative";
case "t":case "temporal":return"temporal";case "o":case "ordinal":return"ordinal";case "n":case "nominal":return"nominal";case "geojson":return"geojson"}}function hasDiscreteDomain(type){return DISCRETE_DOMAIN_SCALES.has(type)}function hasContinuousDomain(type){return CONTINUOUS_DOMAIN_SCALES.has(type)}function isParameterDomain(domain){return null===domain||void 0===domain?void 0:domain.param}function scaleTypeSupportProperty(scaleType,propName){switch(propName){case "type":case "domain":case "reverse":case "range":return!0;
case "scheme":case "interpolate":return!["point","band","identity"].includes(scaleType);case "bins":return!["point","band","identity","ordinal"].includes(scaleType);case "round":return CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)||"band"===scaleType||"point"===scaleType;case "padding":case "rangeMin":case "rangeMax":return CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)||["point","band"].includes(scaleType);case "paddingOuter":case "align":return["point","band"].includes(scaleType);case "paddingInner":return"band"===
scaleType;case "domainMax":case "domainMid":case "domainMin":case "clamp":return CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType);case "nice":return CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)||"quantize"===scaleType||"threshold"===scaleType;case "exponent":return"pow"===scaleType;case "base":return"log"===scaleType;case "constant":return"symlog"===scaleType;case "zero":return hasContinuousDomain(scaleType)&&!contains(["log","time","utc","threshold","quantile"],scaleType)}}function channelScalePropertyIncompatability(channel,
propName){switch(propName){case "interpolate":case "scheme":case "domainMid":if(!isColorChannel(channel))return'Cannot use the scale property "'.concat(channel,'" with non-color channel.')}}function channelSupportScaleType(channel,scaleType){let hasNestedOffsetScale=2<arguments.length&&void 0!==arguments[2]?arguments[2]:!1;if(!SCALE_CHANNEL_INDEX[channel])return!1;switch(channel){case "x":case "y":case "xOffset":case "yOffset":case "theta":case "radius":return CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)||
"band"===scaleType?!0:"point"===scaleType?!hasNestedOffsetScale:!1;case "size":case "strokeWidth":case "opacity":case "fillOpacity":case "strokeOpacity":case "angle":return CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)||CONTINUOUS_TO_DISCRETE_SCALES.has(scaleType)||contains(["band","point","ordinal"],scaleType);case "color":case "fill":case "stroke":return"band"!==scaleType;case "strokeDash":case "shape":return"ordinal"===scaleType||CONTINUOUS_TO_DISCRETE_SCALES.has(scaleType)}}function isPathMark(m){return["line",
"area","trail"].includes(m)}function isMarkDef(mark){return mark.type}function isRelativeBandSize(o){return o&&void 0!=o.band}function midPointRefWithPositionInvalidTest(params){const {channel:channel$jscomp$0,channelDef,markDef,scale,config:config$jscomp$0}=params;params=midPoint(params);if(isFieldDef(channelDef)&&!isCountingAggregateOp(channelDef.aggregate)&&scale&&CONTINUOUS_TO_CONTINUOUS_SCALES.has(scale.get("type"))){{let {fieldDef,channel,markDef:markDef$jscomp$0,ref,config}={fieldDef:channelDef,
channel:channel$jscomp$0,markDef,ref:params,config:config$jscomp$0};if(isPathMark(markDef$jscomp$0.type))params=ref;else if(null===getMarkPropOrConfig("invalid",markDef$jscomp$0,config)){var channel$jscomp$1=channel;params=fieldInvalidPredicate(fieldDef,!0);channel$jscomp$1="y"===getMainRangeChannel(channel$jscomp$1)?{field:{group:"height"}}:{value:0};params=[Object.assign({},{test:params},channel$jscomp$1),ref]}else params=ref}return params}return params}function fieldInvalidPredicate(field){let invalid=
1<arguments.length&&void 0!==arguments[1]?arguments[1]:!0;return fieldValidPredicate(vega.isString(field)?field:vgField(field,{expr:"datum"}),!invalid)}function valueRefForFieldOrDatumDef(fieldDef,scaleName,opt,encode){const ref={};scaleName&&(ref.scale=scaleName);isDatumDef(fieldDef)?({datum:fieldDef}=fieldDef,isDateTime(fieldDef)?ref.signal=dateTimeToExpr(fieldDef):isSignalRef(fieldDef)?ref.signal=fieldDef.signal:isExprRef(fieldDef)?ref.signal=fieldDef.expr:ref.value=fieldDef):ref.field=vgField(fieldDef,
opt);if(encode){const {offset,band}=encode;offset&&(ref.offset=offset);band&&(ref.band=band)}return ref}function interpolatedSignalRef(_ref2){let {scaleName,fieldOrDatumDef,fieldOrDatumDef2,offset,startSuffix,bandPosition=.5}=_ref2;var expr=0<bandPosition&&1>bandPosition?"datum":void 0;_ref2=vgField(fieldOrDatumDef,{expr,suffix:startSuffix});const end=void 0!==fieldOrDatumDef2?vgField(fieldOrDatumDef2,{expr}):vgField(fieldOrDatumDef,{suffix:"end",expr});expr={};0===bandPosition||1===bandPosition?
(expr.scale=scaleName,expr.field=0===bandPosition?_ref2:end):(_ref2=isSignalRef(bandPosition)?"".concat(bandPosition.signal," * ").concat(_ref2," + (1-").concat(bandPosition.signal,") * ").concat(end):"".concat(bandPosition," * ").concat(_ref2," + ").concat(1-bandPosition," * ").concat(end),expr.signal='scale("'.concat(scaleName,'", ').concat(_ref2,")"));offset&&(expr.offset=offset);return expr}function midPoint(_ref3){let {channel,channelDef,channel2Def,markDef,config,scaleName,scale,stack,offset,
defaultRef,bandPosition}=_ref3;if(channelDef){if(isFieldOrDatumDef(channelDef)){var _ref4,_bandPosition2;_ref3=null===scale||void 0===scale?void 0:scale.get("type");if(isTypedFieldDef(channelDef)){var _bandPosition;null!==(_bandPosition=bandPosition)&&void 0!==_bandPosition?_bandPosition:bandPosition=getBandPosition({fieldDef:channelDef,fieldDef2:channel2Def,markDef,config});const {bin,timeUnit,type}=channelDef;if(isBinning(bin)||bandPosition&&timeUnit&&"temporal"===type)return null!==stack&&void 0!==
stack&&stack.impute?valueRefForFieldOrDatumDef(channelDef,scaleName,{binSuffix:"mid"},{offset}):bandPosition&&!hasDiscreteDomain(_ref3)?interpolatedSignalRef({scaleName,fieldOrDatumDef:channelDef,bandPosition,offset}):valueRefForFieldOrDatumDef(channelDef,scaleName,binRequiresRange(channelDef,channel)?{binSuffix:"range"}:{},{offset});if(isBinned(bin)){if(isFieldDef(channel2Def))return interpolatedSignalRef({scaleName,fieldOrDatumDef:channelDef,fieldOrDatumDef2:channel2Def,bandPosition,offset});warn(channelRequiredForBinned("x"===
channel?"x2":"y2"))}}return valueRefForFieldOrDatumDef(channelDef,scaleName,hasDiscreteDomain(_ref3)?{binSuffix:"range"}:{},{offset,band:"band"===_ref3?null!==(_ref4=null!==(_bandPosition2=bandPosition)&&void 0!==_bandPosition2?_bandPosition2:channelDef.bandPosition)&&void 0!==_ref4?_ref4:.5:void 0})}if(isValueDef(channelDef))return _ref4=offset?{offset}:{},Object.assign({},widthHeightValueOrSignalRef(channel,channelDef.value),_ref4)}vega.isFunction(defaultRef)&&(defaultRef=defaultRef());return defaultRef?
Object.assign({},defaultRef,offset?{offset}:{}):defaultRef}function widthHeightValueOrSignalRef(channel,value){return contains(["x","x2"],channel)&&"width"===value?{field:{group:"width"}}:contains(["y","y2"],channel)&&"height"===value?{field:{group:"height"}}:signalOrValueRef(value)}function isCustomFormatType(formatType){return formatType&&"number"!==formatType&&"time"!==formatType}function customFormatExpr(formatType,field,format){return"".concat(formatType,"(").concat(field).concat(format?", ".concat(stringify(format)):
"",")")}function formatSignalRef(_ref){let {fieldOrDatumDef,format,formatType,expr,normalizeStack,config}=_ref;if(isCustomFormatType(formatType))return formatCustomType({fieldOrDatumDef,format,formatType,expr,config});_ref=fieldToFormat(fieldOrDatumDef,expr,normalizeStack);if(isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)){var _normalizeTimeUnit,_fieldOrDatumDef$scal;var timeUnit=isFieldDef(fieldOrDatumDef)?null===(_normalizeTimeUnit=normalizeTimeUnit(fieldOrDatumDef.timeUnit))||void 0===_normalizeTimeUnit?
void 0:_normalizeTimeUnit.unit:void 0,format$jscomp$0=format,rawTimeFormat=config.timeFormat;_normalizeTimeUnit=isScaleFieldDef(fieldOrDatumDef)&&(null===(_fieldOrDatumDef$scal=fieldOrDatumDef.scale)||void 0===_fieldOrDatumDef$scal?void 0:_fieldOrDatumDef$scal.type)===ScaleType.UTC;!timeUnit||format$jscomp$0?(format$jscomp$0=vega.isString(format$jscomp$0)?format$jscomp$0:rawTimeFormat,_ref="".concat(_normalizeTimeUnit?"utc":"time","Format(").concat(_ref,", '").concat(format$jscomp$0,"')")):timeUnit?
(_fieldOrDatumDef$scal=timeUnitSpecifierExpression(timeUnit),timeUnit=_normalizeTimeUnit||timeUnit.startsWith("utc"),_ref="".concat(timeUnit?"utc":"time","Format(").concat(_ref,", ").concat(_fieldOrDatumDef$scal,")")):_ref=void 0;return _ref?{signal:_ref}:void 0}format=numberFormat(fieldOrDatumDef&&fieldOrDatumDef.type,format,config);return isFieldDef(fieldOrDatumDef)&&isBinning(fieldOrDatumDef.bin)?(_fieldOrDatumDef$scal=vgField(fieldOrDatumDef,{expr,binSuffix:"end"}),{signal:binFormatExpression(_ref,
_fieldOrDatumDef$scal,format,formatType,config)}):format||"quantitative"===(fieldOrDatumDef&&fieldOrDatumDef.type)?{signal:"".concat(formatExpr(_ref,format))}:{signal:"isValid(".concat(_ref,") ? ").concat(_ref,' : ""+').concat(_ref)}}function fieldToFormat(fieldOrDatumDef,expr,normalizeStack){if(isFieldDef(fieldOrDatumDef))return normalizeStack?"".concat(vgField(fieldOrDatumDef,{expr,suffix:"end"}),"-").concat(vgField(fieldOrDatumDef,{expr,suffix:"start"})):vgField(fieldOrDatumDef,{expr});({datum:fieldOrDatumDef}=
fieldOrDatumDef);fieldOrDatumDef=isDateTime(fieldOrDatumDef)?dateTimeToExpr(fieldOrDatumDef):"".concat(stringify(fieldOrDatumDef));return fieldOrDatumDef}function formatCustomType(_ref2){var _field;let {fieldOrDatumDef,format,formatType,expr,normalizeStack,config,field}=_ref2;null!==(_field=field)&&void 0!==_field?_field:field=fieldToFormat(fieldOrDatumDef,expr,normalizeStack);return isFieldDef(fieldOrDatumDef)&&isBinning(fieldOrDatumDef.bin)?(_ref2=vgField(fieldOrDatumDef,{expr,binSuffix:"end"}),
{signal:binFormatExpression(field,_ref2,format,formatType,config)}):{signal:customFormatExpr(formatType,field,format)}}function guideFormat(fieldOrDatumDef,type,format,formatType,config,omitTimeFormatConfig){if(!isCustomFormatType(formatType)){if(isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)){var _normalizeTimeUnit2;fieldOrDatumDef=isFieldDef(fieldOrDatumDef)?null===(_normalizeTimeUnit2=normalizeTimeUnit(fieldOrDatumDef.timeUnit))||void 0===_normalizeTimeUnit2?void 0:_normalizeTimeUnit2.unit:void 0;
format=format?format:fieldOrDatumDef?{signal:timeUnitSpecifierExpression(fieldOrDatumDef)}:omitTimeFormatConfig?void 0:config.timeFormat;return format}return numberFormat(type,format,config)}}function guideFormatType(formatType,fieldOrDatumDef,scaleType){if(formatType&&(isSignalRef(formatType)||"number"===formatType||"time"===formatType))return formatType;if(isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)&&"time"!==scaleType&&"utc"!==scaleType)return"time"}function numberFormat(type,specifiedFormat,
config){if(vega.isString(specifiedFormat))return specifiedFormat;if("quantitative"===type)return config.numberFormat}function formatExpr(field,format){return"format(".concat(field,', "').concat(format||"",'")')}function binNumberFormatExpr(field,format,formatType,config){var _ref3;return isCustomFormatType(formatType)?customFormatExpr(formatType,field,format):formatExpr(field,null!==(_ref3=vega.isString(format)?format:void 0)&&void 0!==_ref3?_ref3:config.numberFormat)}function binFormatExpression(startField,
endField,format,formatType,config){const start=binNumberFormatExpr(startField,format,formatType,config);endField=binNumberFormatExpr(endField,format,formatType,config);return"".concat(fieldValidPredicate(startField,!1),' ? "null" : ').concat(start,' + "').concat(" – ",'" + ').concat(endField)}function isSortField(sort){return!!sort&&("count"===sort.op||!!sort.field)}function isSortArray(sort){return!!sort&&vega.isArray(sort)}function isFacetMapping(f){return"row"in f||"column"in f}function toFieldDefBase(fieldDef){const {field,
timeUnit,bin,aggregate}=fieldDef;return Object.assign({},timeUnit?{timeUnit}:{},bin?{bin}:{},aggregate?{aggregate}:{},{field})}function getBandPosition(_ref){let {fieldDef,fieldDef2,markDef:mark,config}=_ref;if(isFieldOrDatumDef(fieldDef)&&void 0!==fieldDef.bandPosition)return fieldDef.bandPosition;if(isFieldDef(fieldDef)){const {timeUnit,bin}=fieldDef;if(timeUnit&&!fieldDef2)return["rect","bar","image","arc"].includes(mark.type)?0:getMarkConfig("timeUnitBandPosition",mark,config);if(isBinning(bin))return.5}}
function getBandSize(_ref2){let {channel,fieldDef,fieldDef2,markDef:mark,config,scaleType,useVlSizeChannel}=_ref2;_ref2=getSizeChannel(channel);_ref2=getMarkPropOrConfig(useVlSizeChannel?"size":_ref2,mark,config,{vgChannel:_ref2});if(void 0!==_ref2)return _ref2;if(isFieldDef(fieldDef)){const {timeUnit,bin}=fieldDef;if(timeUnit&&!fieldDef2)return{band:getMarkConfig("timeUnitBandSize",mark,config)};if(isBinning(bin)&&!hasDiscreteDomain(scaleType))return{band:1}}if(["rect","bar","image","arc"].includes(mark.type)){var _config$mark$type3;
if(scaleType){if(hasDiscreteDomain(scaleType)){var _config$mark$type;return(null===(_config$mark$type=config[mark.type])||void 0===_config$mark$type?void 0:_config$mark$type.discreteBandSize)||{band:1}}var _config$mark$type2;return null===(_config$mark$type2=config[mark.type])||void 0===_config$mark$type2?void 0:_config$mark$type2.continuousBandSize}return null===(_config$mark$type3=config[mark.type])||void 0===_config$mark$type3?void 0:_config$mark$type3.discreteBandSize}}function hasBandEnd(fieldDef,
fieldDef2,markDef,config){return isBinning(fieldDef.bin)||fieldDef.timeUnit&&isTypedFieldDef(fieldDef)&&"temporal"===fieldDef.type?void 0!==getBandPosition({fieldDef,fieldDef2,markDef,config}):!1}function isConditionalDef(channelDef){return channelDef&&"condition"in channelDef}function hasConditionalFieldDef(channelDef){channelDef=channelDef&&channelDef.condition;return!!channelDef&&!vega.isArray(channelDef)&&isFieldDef(channelDef)}function hasConditionalFieldOrDatumDef(channelDef){channelDef=channelDef&&
channelDef.condition;return!!channelDef&&!vega.isArray(channelDef)&&isFieldOrDatumDef(channelDef)}function isFieldDef(channelDef){return channelDef&&(!!channelDef.field||"count"===channelDef.aggregate)}function isDatumDef(channelDef){return channelDef&&"datum"in channelDef}function isContinuousFieldOrDatumDef(cd){return isTypedFieldDef(cd)&&!isDiscrete(cd)||isNumericDataDef(cd)}function isNumericDataDef(cd){return isDatumDef(cd)&&vega.isNumber(cd.datum)}function isFieldOrDatumDef(channelDef){return isFieldDef(channelDef)||
isDatumDef(channelDef)}function isTypedFieldDef(channelDef){return channelDef&&("field"in channelDef||"count"===channelDef.aggregate)&&"type"in channelDef}function isValueDef(channelDef){return channelDef&&"value"in channelDef&&"value"in channelDef}function isScaleFieldDef(channelDef){return channelDef&&("scale"in channelDef||"sort"in channelDef)}function isPositionFieldOrDatumDef(channelDef){return channelDef&&("axis"in channelDef||"stack"in channelDef||"impute"in channelDef)}function isStringFieldOrDatumDef(channelDef){return channelDef&&
("format"in channelDef||"formatType"in channelDef)}function toStringFieldDef(fieldDef){return omit(fieldDef,["legend","axis","header","scale"])}function vgField(fieldDef){let opt=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},field=fieldDef.field;const prefix=opt.prefix;let suffix=opt.suffix,argAccessor="";if("count"===fieldDef.aggregate)field=internalField("count");else{let fn;if(!opt.nofn)if("op"in fieldDef)fn=fieldDef.op;else{const {bin,aggregate,timeUnit}=fieldDef;if(isBinning(bin)){var _opt$binSuffix,
_opt$suffix;fn=binToString(bin);suffix=(null!==(_opt$binSuffix=opt.binSuffix)&&void 0!==_opt$binSuffix?_opt$binSuffix:"")+(null!==(_opt$suffix=opt.suffix)&&void 0!==_opt$suffix?_opt$suffix:"")}else if(aggregate)isArgmaxDef(aggregate)?(argAccessor='["'.concat(field,'"]'),field="argmax_".concat(aggregate.argmax)):isArgminDef(aggregate)?(argAccessor='["'.concat(field,'"]'),field="argmin_".concat(aggregate.argmin)):fn=String(aggregate);else if(timeUnit){var _opt$suffix2;fn=timeUnitToString(timeUnit);
suffix=(!["range","mid"].includes(opt.binSuffix)&&opt.binSuffix||"")+(null!==(_opt$suffix2=opt.suffix)&&void 0!==_opt$suffix2?_opt$suffix2:"")}}fn&&(field=field?"".concat(fn,"_").concat(field):fn)}suffix&&(field="".concat(field,"_").concat(suffix));prefix&&(field="".concat(prefix,"_").concat(field));return opt.forAs?removePathFromField(field):opt.expr?flatAccessWithDatum(field,opt.expr)+argAccessor:replacePathInField(field)+argAccessor}function isDiscrete(def){switch(def.type){case "nominal":case "ordinal":case "geojson":return!0;
case "quantitative":return isFieldDef(def)&&!!def.bin;case "temporal":return!1}throw Error('Invalid field type "'.concat(def.type,'".'));}function verbalTitleFormatter(fieldDef,config){const {field,bin,timeUnit,aggregate}=fieldDef;if("count"===aggregate)return config.countTitle;if(isBinning(bin))return"".concat(field," (binned)");if(timeUnit){var _normalizeTimeUnit;if(fieldDef=null===(_normalizeTimeUnit=normalizeTimeUnit(timeUnit))||void 0===_normalizeTimeUnit?void 0:_normalizeTimeUnit.unit)return"".concat(field,
" (").concat(getTimeUnitParts(fieldDef).join("-"),")")}else if(aggregate)return isArgmaxDef(aggregate)?"".concat(field," for max ").concat(aggregate.argmax):isArgminDef(aggregate)?"".concat(field," for min ").concat(aggregate.argmin):"".concat(titleCase(aggregate)," of ").concat(field);return field}function title$jscomp$0(fieldOrDatumDef,config,_ref3){var _getGuide;let {allowDisabling,includeDefault=!0}=_ref3;_ref3=null===(_getGuide=getGuide(fieldOrDatumDef))||void 0===_getGuide?void 0:_getGuide.title;
if(!isFieldDef(fieldOrDatumDef))return null!==_ref3&&void 0!==_ref3?_ref3:fieldOrDatumDef.title;config=includeDefault?titleFormatter(fieldOrDatumDef,config):void 0;if(allowDisabling)return getFirstDefined(_ref3,fieldOrDatumDef.title,config);var _ref4;return null!==(_ref4=null!==_ref3&&void 0!==_ref3?_ref3:fieldOrDatumDef.title)&&void 0!==_ref4?_ref4:config}function getGuide(fieldDef){if(isPositionFieldOrDatumDef(fieldDef)&&fieldDef.axis)return fieldDef.axis;if(fieldDef&&"legend"in fieldDef&&fieldDef.legend)return fieldDef.legend;
if(fieldDef&&"header"in fieldDef&&fieldDef.header)return fieldDef.header}function getFormatMixins(fieldDef){if(isStringFieldOrDatumDef(fieldDef)){const {format,formatType}=fieldDef;return{format,formatType}}var _getGuide2;fieldDef=null!==(_getGuide2=getGuide(fieldDef))&&void 0!==_getGuide2?_getGuide2:{};const {format:format$jscomp$0,formatType:formatType$jscomp$0}=fieldDef;return{format:format$jscomp$0,formatType:formatType$jscomp$0}}function defaultType$2(fieldDef,channel){var _fieldDef$scale;switch(channel){case "latitude":case "longitude":return"quantitative";
case "row":case "column":case "facet":case "shape":case "strokeDash":return"nominal";case "order":return"ordinal"}if("sort"in fieldDef&&vega.isArray(fieldDef.sort))return"ordinal";const {aggregate,bin,timeUnit}=fieldDef;if(timeUnit)return"temporal";if(bin||aggregate&&!isArgmaxDef(aggregate)&&!isArgminDef(aggregate))return"quantitative";if(isScaleFieldDef(fieldDef)&&null!==(_fieldDef$scale=fieldDef.scale)&&void 0!==_fieldDef$scale&&_fieldDef$scale.type)switch(SCALE_CATEGORY_INDEX[fieldDef.scale.type]){case "numeric":case "discretizing":return"quantitative";
case "time":return"temporal"}return"nominal"}function getFieldDef(channelDef){if(isFieldDef(channelDef))return channelDef;if(hasConditionalFieldDef(channelDef))return channelDef.condition}function getFieldOrDatumDef(channelDef){if(isFieldOrDatumDef(channelDef))return channelDef;if(hasConditionalFieldOrDatumDef(channelDef))return channelDef.condition}function initChannelDef(channelDef,channel,config){var opt=3<arguments.length&&void 0!==arguments[3]?arguments[3]:{};return vega.isString(channelDef)||
vega.isNumber(channelDef)||vega.isBoolean(channelDef)?(opt=vega.isString(channelDef)?"string":vega.isNumber(channelDef)?"number":"boolean",opt="Channel ".concat(channel," is a ").concat(opt,". Converted to {value: ").concat(stringify(channelDef),"}."),warn(opt),{value:channelDef}):isFieldOrDatumDef(channelDef)?initFieldOrDatumDef(channelDef,channel,config,opt):hasConditionalFieldOrDatumDef(channelDef)?Object.assign({},channelDef,{condition:initFieldOrDatumDef(channelDef.condition,channel,config,opt)}):
channelDef}function initFieldOrDatumDef(fd,channel,config,opt){if(isStringFieldOrDatumDef(fd)){var $jscomp$destructuring$var25=Object.assign({},fd),formatType=fd.formatType;$jscomp$destructuring$var25=(delete $jscomp$destructuring$var25.format,delete $jscomp$destructuring$var25.formatType,$jscomp$destructuring$var25);if(isCustomFormatType(formatType)&&!config.customFormatTypes)return warn(customFormatTypeNotAllowed(channel)),initFieldOrDatumDef($jscomp$destructuring$var25,channel,config,opt)}else if((formatType=
isPositionFieldOrDatumDef(fd)?"axis":fd&&"legend"in fd?"legend":fd&&"header"in fd?"header":null)&&fd[formatType]){var $jscomp$destructuring$var26=fd[formatType];$jscomp$destructuring$var25=Object.assign({},$jscomp$destructuring$var26);$jscomp$destructuring$var26=$jscomp$destructuring$var26.formatType;$jscomp$destructuring$var25=(delete $jscomp$destructuring$var25.format,delete $jscomp$destructuring$var25.formatType,$jscomp$destructuring$var25);if(isCustomFormatType($jscomp$destructuring$var26)&&!config.customFormatTypes)return warn(customFormatTypeNotAllowed(channel)),
initFieldOrDatumDef(Object.assign({},fd,{[formatType]:$jscomp$destructuring$var25}),channel,config,opt)}if(isFieldDef(fd))return initFieldDef(fd,channel,opt);channel=fd.type;channel||({datum:channel}=fd,channel=vega.isNumber(channel)?"quantitative":vega.isString(channel)?"nominal":isDateTime(channel)?"temporal":void 0,fd=Object.assign({},fd,{type:channel}));return fd}function initFieldDef(fd,channel){var {compositeMark=!1}=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};const {aggregate,
timeUnit,bin,field}=fd,fieldDef=Object.assign({},fd);compositeMark||!aggregate||isAggregateOp(aggregate)||isArgmaxDef(aggregate)||isArgminDef(aggregate)||(warn('Invalid aggregation operator "'.concat(aggregate,'".')),delete fieldDef.aggregate);timeUnit&&(fieldDef.timeUnit=normalizeTimeUnit(timeUnit));field&&(fieldDef.field="".concat(field));isBinning(bin)&&(fieldDef.bin=normalizeBin(bin,channel));isBinned(bin)&&!isXorY(channel)&&warn("Channel ".concat(channel,' should not be used with "binned" bin.'));
if(isTypedFieldDef(fieldDef)){({type:compositeMark}=fieldDef);var fullType=getFullName(compositeMark);compositeMark!==fullType&&(fieldDef.type=fullType);"quantitative"!==compositeMark&&isCountingAggregateOp(aggregate)&&(compositeMark='Invalid field type "'.concat(compositeMark,'" for aggregate: "').concat(aggregate,'", using "quantitative" instead.'),warn(compositeMark),fieldDef.type="quantitative")}else isSecondaryRangeChannel(channel)||(compositeMark=defaultType$2(fieldDef,channel),fieldDef.type=
compositeMark);if(isTypedFieldDef(fieldDef)){const {compatible,warning}=channelCompatibility(fieldDef,channel)||{};!1===compatible&&warn(warning)}if("sort"in fieldDef&&vega.isString(fieldDef.sort)){({sort:compositeMark}=fieldDef);if(compositeMark in SORT_BY_CHANNEL_INDEX)return Object.assign({},fieldDef,{sort:{encoding:compositeMark}});fullType=compositeMark.substr(1);if("-"===compositeMark.charAt(0)&&fullType in SORT_BY_CHANNEL_INDEX)return Object.assign({},fieldDef,{sort:{encoding:fullType,order:"descending"}})}if(fieldDef&&
"header"in fieldDef&&({header:compositeMark}=fieldDef,compositeMark)){var $jscomp$destructuring$var28=compositeMark;fullType=Object.assign({},$jscomp$destructuring$var28);$jscomp$destructuring$var28=$jscomp$destructuring$var28.orient;fullType=(delete fullType.orient,fullType);if($jscomp$destructuring$var28)return Object.assign({},fieldDef,{header:Object.assign({},fullType,{labelOrient:compositeMark.labelOrient||$jscomp$destructuring$var28,titleOrient:compositeMark.titleOrient||$jscomp$destructuring$var28})})}return fieldDef}
function normalizeBin(bin,channel){return vega.isBoolean(bin)?{maxbins:autoMaxBins(channel)}:"binned"===bin?{binned:!0}:bin.maxbins||bin.step?bin:Object.assign({},bin,{maxbins:autoMaxBins(channel)})}function channelCompatibility(fieldDef,channel){var type=fieldDef.type;if("geojson"===type&&"shape"!==channel)return{compatible:!1,warning:"Channel ".concat(channel," should not be used with a geojson data.")};switch(channel){case "row":case "column":case "facet":return isDiscrete(fieldDef)?COMPATIBLE:
{compatible:!1,warning:"".concat(channel," encoding should be discrete (ordinal / nominal / binned).")};case "x":case "y":case "xOffset":case "yOffset":case "color":case "fill":case "stroke":case "text":case "detail":case "key":case "tooltip":case "href":case "url":case "angle":case "theta":case "radius":case "description":return COMPATIBLE;case "longitude":case "longitude2":case "latitude":case "latitude2":return"quantitative"!==type?{compatible:!1,warning:"Channel ".concat(channel," should be used with a quantitative field only, not ").concat(fieldDef.type,
" field.")}:COMPATIBLE;case "opacity":case "fillOpacity":case "strokeOpacity":case "strokeWidth":case "size":case "theta2":case "radius2":case "x2":case "y2":return"nominal"!==type||fieldDef.sort?COMPATIBLE:{compatible:!1,warning:"Channel ".concat(channel," should not be used with an unsorted discrete field.")};case "shape":case "strokeDash":if(type=!isDiscrete(fieldDef)){var _def$scale;type=!(isScaleFieldDef(fieldDef)&&CONTINUOUS_TO_DISCRETE_SCALES.has(null===(_def$scale=fieldDef.scale)||void 0===
_def$scale?void 0:_def$scale.type))}return type?{compatible:!1,warning:"".concat(channel," encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).")}:COMPATIBLE;case "order":return"nominal"!==fieldDef.type||"sort"in fieldDef?COMPATIBLE:{compatible:!1,warning:"Channel order is inappropriate for nominal field, which has no inherent order."}}}function isFieldOrDatumDefForTimeFormat(fieldOrDatumDef){var {formatType}=getFormatMixins(fieldOrDatumDef),JSCompiler_temp;
if(!(JSCompiler_temp="time"===formatType)){if(formatType=!formatType)formatType=fieldOrDatumDef&&("temporal"===fieldOrDatumDef.type||isFieldDef(fieldOrDatumDef)&&!!fieldOrDatumDef.timeUnit);JSCompiler_temp=formatType}return JSCompiler_temp}function valueExpr(v,_ref5){let {timeUnit,type,wrapTime,undefinedIfExprNotRequired}=_ref5;var _normalizeTimeUnit2=(_ref5=timeUnit&&(null===(_normalizeTimeUnit2=normalizeTimeUnit(timeUnit))||void 0===_normalizeTimeUnit2?void 0:_normalizeTimeUnit2.unit))||"temporal"===
type;let expr;isExprRef(v)?expr=v.expr:isSignalRef(v)?expr=v.signal:isDateTime(v)?(_normalizeTimeUnit2=!0,expr=dateTimeToExpr(v)):(vega.isString(v)||vega.isNumber(v))&&_normalizeTimeUnit2&&(expr="datetime(".concat(stringify(v),")"),LOCAL_SINGLE_TIMEUNIT_INDEX[_ref5]&&(vega.isNumber(v)&&1E4>v||vega.isString(v)&&isNaN(Date.parse(v)))&&(expr=dateTimeToExpr({[_ref5]:v})));return expr?wrapTime&&_normalizeTimeUnit2?"time(".concat(expr,")"):expr:undefinedIfExprNotRequired?void 0:stringify(v)}function valueArray(fieldOrDatumDef,
values){const {type}=fieldOrDatumDef;return values.map(v=>{const expr=valueExpr(v,{timeUnit:isFieldDef(fieldOrDatumDef)?fieldOrDatumDef.timeUnit:void 0,type,undefinedIfExprNotRequired:!0});return void 0!==expr?{signal:expr}:v})}function binRequiresRange(fieldDef,channel){return isBinning(fieldDef.bin)?!!SCALE_CHANNEL_INDEX[channel]&&["ordinal","nominal"].includes(fieldDef.type):(console.warn("Only call this method for binned field defs."),!1)}function isConditionalAxisValue(v){return v&&v.condition}
function isUnitSpec(spec){return"mark"in spec}function channelHasField(encoding,channel){return(encoding=encoding&&encoding[channel])?vega.isArray(encoding)?some(encoding,fieldDef=>!!fieldDef.field):isFieldDef(encoding)||hasConditionalFieldDef(encoding):!1}function channelHasFieldOrDatum(encoding,channel){return(encoding=encoding&&encoding[channel])?vega.isArray(encoding)?some(encoding,fieldDef=>!!fieldDef.field):isFieldDef(encoding)||isDatumDef(encoding)||hasConditionalFieldOrDatumDef(encoding):
!1}function channelHasNestedOffsetScale(encoding,channel){if(isXorY(channel)){const fieldDef=encoding[channel];if((isFieldDef(fieldDef)||isDatumDef(fieldDef))&&isDiscrete$1(fieldDef.type))return channel=getOffsetScaleChannel(channel),channelHasFieldOrDatum(encoding,channel)}return!1}function isAggregate$1(encoding){return some(CHANNELS,channel=>channelHasField(encoding,channel)?(channel=encoding[channel],vega.isArray(channel)?some(channel,fieldDef=>!!fieldDef.aggregate):(channel=getFieldDef(channel))&&
!!channel.aggregate):!1)}function extractTransformsFromEncoding(oldEncoding,config){const groupby=[],bins=[],timeUnits=[],aggregate=[],encoding={};forEach(oldEncoding,(channelDef,channel)=>{if(isFieldDef(channelDef)){var $jscomp$destructuring$var31=Object.assign({},channelDef),field=channelDef.field;const aggOp=channelDef.aggregate,bin=channelDef.bin,timeUnit=channelDef.timeUnit;$jscomp$destructuring$var31=(delete $jscomp$destructuring$var31.field,delete $jscomp$destructuring$var31.aggregate,delete $jscomp$destructuring$var31.bin,
delete $jscomp$destructuring$var31.timeUnit,$jscomp$destructuring$var31);if(aggOp||timeUnit||bin){var guide=getGuide(channelDef);const isTitleDefined=null===guide||void 0===guide?void 0:guide.title;guide=vgField(channelDef,{forAs:!0});$jscomp$destructuring$var31=Object.assign({},isTitleDefined?[]:{title:title$jscomp$0(channelDef,config,{allowDisabling:!0})},$jscomp$destructuring$var31,{field:guide});if(aggOp){let op;isArgmaxDef(aggOp)?(op="argmax",guide=vgField({op:"argmax",field:aggOp.argmax},{forAs:!0}),
$jscomp$destructuring$var31.field="".concat(guide,".").concat(field)):isArgminDef(aggOp)?(op="argmin",guide=vgField({op:"argmin",field:aggOp.argmin},{forAs:!0}),$jscomp$destructuring$var31.field="".concat(guide,".").concat(field)):"boxplot"!==aggOp&&"errorbar"!==aggOp&&"errorband"!==aggOp&&(op=aggOp);op&&(channelDef={op,as:guide},field&&(channelDef.field=field),aggregate.push(channelDef))}else groupby.push(guide),isTypedFieldDef(channelDef)&&isBinning(bin)?(bins.push({bin,field,as:guide}),groupby.push(vgField(channelDef,
{binSuffix:"end"})),binRequiresRange(channelDef,channel)&&groupby.push(vgField(channelDef,{binSuffix:"range"})),isXorY(channel)&&(field={field:"".concat(guide,"_end")},encoding["".concat(channel,"2")]=field),$jscomp$destructuring$var31.bin="binned",isSecondaryRangeChannel(channel)||($jscomp$destructuring$var31.type="quantitative")):timeUnit&&(timeUnits.push({timeUnit,field,as:guide}),(field=isTypedFieldDef(channelDef)&&"temporal"!==channelDef.type&&"time")&&("text"===channel||"tooltip"===channel?
$jscomp$destructuring$var31.formatType=field:NONPOSITION_CHANNEL_INDEX[channel]?$jscomp$destructuring$var31.legend=Object.assign({},{formatType:field},$jscomp$destructuring$var31.legend):isXorY(channel)&&($jscomp$destructuring$var31.axis=Object.assign({},{formatType:field},$jscomp$destructuring$var31.axis))));encoding[channel]=$jscomp$destructuring$var31}else groupby.push(field),encoding[channel]=oldEncoding[channel]}else encoding[channel]=oldEncoding[channel]});return{bins,timeUnits,aggregate,groupby,
encoding}}function markChannelCompatible(encoding,channel,mark){mark=getSupportedMark(channel)[mark];return mark&&("binned"!==mark||(mark=encoding["x2"===channel?"x":"y"],isFieldDef(mark)&&isFieldDef(encoding[channel])&&isBinned(mark.bin)))?!0:!1}function initEncoding(encoding,mark,filled,config){const normalizedEncoding={};for(var key of keys$jscomp$0(encoding))CHANNEL_INDEX[key]||warn(invalidEncodingChannel(key));for(let channel of UNIT_CHANNELS)if(encoding[channel]){key=encoding[channel];if(channel in
OFFSET_SCALE_CHANNEL_INDEX){var mainChannel=getMainChannelFromOffsetChannel(channel);const positionDef=normalizedEncoding[mainChannel];if(isFieldDef(positionDef)){if(isContinuous(positionDef.type)&&isFieldDef(key)){warn(offsetNestedInsideContinuousPositionScaleDropped(mainChannel));continue}}else channel=mainChannel,warn(replaceOffsetWithMainChannel(mainChannel))}"angle"!==channel||"arc"!==mark||encoding.theta||(warn("Arc marks uses theta channel rather than angle, replacing angle with theta."),channel=
"theta");if(markChannelCompatible(encoding,channel,mark)){if("size"===channel&&"line"===mark&&(mainChannel=getFieldDef(encoding[channel]),null!==mainChannel&&void 0!==mainChannel&&mainChannel.aggregate)){warn("Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.");continue}if("color"===channel&&(filled?"fill"in encoding:"stroke"in encoding))warn(droppingColor("encoding",{fill:"fill"in encoding,stroke:"stroke"in encoding}));else if("detail"===channel||"order"===
channel&&!vega.isArray(key)&&!isValueDef(key)||"tooltip"===channel&&vega.isArray(key))key&&(normalizedEncoding[channel]=vega.array(key).reduce((defs,fieldDef)=>{isFieldDef(fieldDef)?defs.push(initFieldDef(fieldDef,channel)):warn(emptyFieldDef(fieldDef,channel));return defs},[]));else{if("tooltip"===channel&&null===key)normalizedEncoding[channel]=null;else if(!(isFieldDef(key)||isDatumDef(key)||isValueDef(key)||isConditionalDef(key)||isSignalRef(key))){warn(emptyFieldDef(key,channel));continue}normalizedEncoding[channel]=
initChannelDef(key,channel,config)}}else warn(incompatibleChannel(channel,mark))}return normalizedEncoding}function normalizeEncoding(encoding,config){const normalizedEncoding={};for(const channel of keys$jscomp$0(encoding)){const newChannelDef=initChannelDef(encoding[channel],channel,config,{compositeMark:!0});normalizedEncoding[channel]=newChannelDef}return normalizedEncoding}function fieldDefs(encoding){const arr=[];for(const channel of keys$jscomp$0(encoding))if(channelHasField(encoding,channel)){const channelDefArray=
vega.array(encoding[channel]);for(const def of channelDefArray)isFieldDef(def)?arr.push(def):hasConditionalFieldDef(def)&&arr.push(def.condition)}return arr}function forEach(mapping,f,thisArg){if(mapping)for(const channel of keys$jscomp$0(mapping)){const el=mapping[channel];if(vega.isArray(el))for(const channelDef of el)f.call(thisArg,channelDef,channel);else f.call(thisArg,el,channel)}}function reduce(mapping,f,init,thisArg){return mapping?keys$jscomp$0(mapping).reduce((r,channel)=>{const map=mapping[channel];
return vega.isArray(map)?map.reduce((r1,channelDef)=>f.call(thisArg,r1,channelDef,channel),r):f.call(thisArg,r,map,channel)},init):init}function pathGroupingFields(mark,encoding){return keys$jscomp$0(encoding).reduce((details,channel)=>{switch(channel){case "x":case "y":case "href":case "description":case "url":case "x2":case "y2":case "xOffset":case "yOffset":case "theta":case "theta2":case "radius":case "radius2":case "latitude":case "longitude":case "latitude2":case "longitude2":case "text":case "shape":case "angle":case "tooltip":return details;
case "order":if("line"===mark||"trail"===mark)return details;case "detail":case "key":channel=encoding[channel];if(vega.isArray(channel)||isFieldDef(channel))for(var fieldDef of vega.array(channel))fieldDef.aggregate||details.push(vgField(fieldDef,{}));return details;case "size":if("trail"===mark)return details;case "color":case "fill":case "stroke":case "opacity":case "fillOpacity":case "strokeOpacity":case "strokeDash":case "strokeWidth":return(fieldDef=getFieldDef(encoding[channel]))&&!fieldDef.aggregate&&
details.push(vgField(fieldDef,{})),details}},[])}function getCompositeMarkTooltip(tooltipSummary,continuousAxisChannelDef,encodingWithoutContinuousAxis){let withFieldName=3<arguments.length&&void 0!==arguments[3]?arguments[3]:!0;if("tooltip"in encodingWithoutContinuousAxis)return{tooltip:encodingWithoutContinuousAxis.tooltip};const fiveSummaryTooltip=tooltipSummary.map(_ref=>{let {fieldPrefix,titlePrefix}=_ref;_ref=withFieldName?" of ".concat(getTitle(continuousAxisChannelDef)):"";return{field:fieldPrefix+
continuousAxisChannelDef.field,type:continuousAxisChannelDef.type,title:isSignalRef(titlePrefix)?{signal:"".concat(titlePrefix,'"').concat(escape(_ref),'"')}:titlePrefix+_ref}}),tooltipFieldDefs=fieldDefs(encodingWithoutContinuousAxis).map(toStringFieldDef);return{tooltip:[...fiveSummaryTooltip,...unique(tooltipFieldDefs,hash)]}}function getTitle(continuousAxisChannelDef){const {title,field}=continuousAxisChannelDef;return getFirstDefined(title,field)}function makeCompositeAggregatePartFactory(compositeMarkDef,
continuousAxis,continuousAxisChannelDef,sharedEncoding,compositeMarkConfig){const {scale,axis}=continuousAxisChannelDef;return _ref2=>{let {partName,mark,positionPrefix,endPositionPrefix,extraEncoding={}}=_ref2;_ref2=getTitle(continuousAxisChannelDef);return partLayerMixins(compositeMarkDef,partName,compositeMarkConfig,{mark,encoding:Object.assign({},{[continuousAxis]:Object.assign({},{field:"".concat(positionPrefix,"_").concat(continuousAxisChannelDef.field),type:continuousAxisChannelDef.type},void 0!==
_ref2?{title:_ref2}:{},void 0!==scale?{scale}:{},void 0!==axis?{axis}:{})},vega.isString(endPositionPrefix)?{["".concat(continuousAxis,"2")]:{field:"".concat(endPositionPrefix,"_").concat(continuousAxisChannelDef.field)}}:{},sharedEncoding,extraEncoding)})}}function partLayerMixins(markDef,part,compositeMarkConfig,partBaseSpec){const {clip,color,opacity}=markDef,mark=markDef.type;return markDef[part]||void 0===markDef[part]&&compositeMarkConfig[part]?[Object.assign({},partBaseSpec,{mark:Object.assign({},
compositeMarkConfig[part],clip?{clip}:{},color?{color}:{},opacity?{opacity}:{},isMarkDef(partBaseSpec.mark)?partBaseSpec.mark:{type:partBaseSpec.mark},{style:"".concat(mark,"-").concat(part)},vega.isBoolean(markDef[part])?{}:markDef[part])})]:[]}function compositeMarkContinuousAxis(spec,orient,compositeMark){({encoding:spec}=spec);orient="vertical"===orient?"y":"x";const continuousAxisChannelDef=spec[orient],continuousAxisChannelDef2=spec["".concat(orient,"2")],continuousAxisChannelDefError=spec["".concat(orient,
"Error")];spec=spec["".concat(orient,"Error2")];return{continuousAxisChannelDef:filterAggregateFromChannelDef(continuousAxisChannelDef,compositeMark),continuousAxisChannelDef2:filterAggregateFromChannelDef(continuousAxisChannelDef2,compositeMark),continuousAxisChannelDefError:filterAggregateFromChannelDef(continuousAxisChannelDefError,compositeMark),continuousAxisChannelDefError2:filterAggregateFromChannelDef(spec,compositeMark),continuousAxis:orient}}function filterAggregateFromChannelDef(continuousAxisChannelDef,
compositeMark){if(null!==continuousAxisChannelDef&&void 0!==continuousAxisChannelDef&&continuousAxisChannelDef.aggregate){var $jscomp$destructuring$var35=Object.assign({},continuousAxisChannelDef);continuousAxisChannelDef=continuousAxisChannelDef.aggregate;$jscomp$destructuring$var35=(delete $jscomp$destructuring$var35.aggregate,$jscomp$destructuring$var35);continuousAxisChannelDef!==compositeMark&&(compositeMark="Continuous axis should not have customized aggregation function ".concat(continuousAxisChannelDef,
"; ").concat(compositeMark," already agregates the axis."),warn(compositeMark));return $jscomp$destructuring$var35}return continuousAxisChannelDef}function compositeMarkOrient(spec,compositeMark){const {mark,encoding}=spec,{x,y}=encoding;if(isMarkDef(mark)&&mark.orient)return mark.orient;if(isContinuousFieldOrDatumDef(x)){if(isContinuousFieldOrDatumDef(y)){spec=isFieldDef(x)&&x.aggregate;const yAggregate=isFieldDef(y)&&y.aggregate;if(!spec&&yAggregate===compositeMark)return"vertical";if(yAggregate||
spec!==compositeMark){if(spec===compositeMark&&yAggregate===compositeMark)throw Error("Both x and y cannot have aggregate");return isFieldOrDatumDefForTimeFormat(y)&&!isFieldOrDatumDefForTimeFormat(x)?"horizontal":"vertical"}}return"horizontal"}if(isContinuousFieldOrDatumDef(y))return"vertical";throw Error("Need a valid continuous axis for ".concat(compositeMark,"s"));}function getBoxPlotType(extent){return vega.isNumber(extent)?"tukey":extent}function normalizeBoxPlot(spec$jscomp$0,_ref){var _markDef$extent,
{config}=_ref,$jscomp$destructuring$var36=spec$jscomp$0=Object.assign({},spec$jscomp$0,{encoding:normalizeEncoding(spec$jscomp$0.encoding,config)});_ref=Object.assign({},$jscomp$destructuring$var36);var mark=$jscomp$destructuring$var36.mark;$jscomp$destructuring$var36=$jscomp$destructuring$var36.params;_ref=(delete _ref.mark,delete _ref.encoding,delete _ref.params,delete _ref.projection,_ref);mark=isMarkDef(mark)?mark:{type:mark};$jscomp$destructuring$var36&&warn(selectionNotSupported("boxplot"));
$jscomp$destructuring$var36=null!==(_markDef$extent=mark.extent)&&void 0!==_markDef$extent?_markDef$extent:config.boxplot.extent;var sizeValue=getMarkPropOrConfig("size",mark,config);_markDef$extent=getBoxPlotType($jscomp$destructuring$var36);var spec=spec$jscomp$0;spec$jscomp$0=compositeMarkOrient(spec,"boxplot");const {continuousAxisChannelDef,continuousAxis}=compositeMarkContinuousAxis(spec,spec$jscomp$0,"boxplot");var continuousFieldName=continuousAxisChannelDef.field,boxPlotType=getBoxPlotType($jscomp$destructuring$var36),
boxplotSpecificAggregate=[...boxParamsQuartiles(continuousFieldName),{op:"median",field:continuousFieldName,as:"mid_box_".concat(continuousFieldName)},{op:"min",field:continuousFieldName,as:("min-max"===boxPlotType?"lower_whisker_":"min_")+continuousFieldName},{op:"max",field:continuousFieldName,as:("min-max"===boxPlotType?"upper_whisker_":"max_")+continuousFieldName}];continuousFieldName="min-max"===boxPlotType||"tukey"===boxPlotType?[]:[{calculate:'datum["upper_box_'.concat(continuousFieldName,
'"] - datum["lower_box_').concat(continuousFieldName,'"]'),as:"iqr_".concat(continuousFieldName)},{calculate:'min(datum["upper_box_'.concat(continuousFieldName,'"] + datum["iqr_').concat(continuousFieldName,'"] * ').concat($jscomp$destructuring$var36,', datum["max_').concat(continuousFieldName,'"])'),as:"upper_whisker_".concat(continuousFieldName)},{calculate:'max(datum["lower_box_'.concat(continuousFieldName,'"] - datum["iqr_').concat(continuousFieldName,'"] * ').concat($jscomp$destructuring$var36,
', datum["min_').concat(continuousFieldName,'"])'),as:"lower_whisker_".concat(continuousFieldName)}];spec=Object.assign({},spec.encoding);var JSCompiler_inline_result;boxPlotType=(delete spec[continuousAxis],spec);spec=Object.assign({},boxPlotType);boxPlotType=boxPlotType.tooltip;spec=(delete spec.tooltip,spec);if(boxPlotType){var customTooltipWithoutAggregatedField;if(vega.isArray(boxPlotType)){for(var t of boxPlotType)t.aggregate?(JSCompiler_inline_result||(JSCompiler_inline_result=[]),JSCompiler_inline_result.push(t)):
(customTooltipWithoutAggregatedField||(customTooltipWithoutAggregatedField=[]),customTooltipWithoutAggregatedField.push(t));JSCompiler_inline_result&&(spec.tooltip=JSCompiler_inline_result)}else boxPlotType.aggregate?spec.tooltip=boxPlotType:customTooltipWithoutAggregatedField=boxPlotType;vega.isArray(customTooltipWithoutAggregatedField)&&1===customTooltipWithoutAggregatedField.length&&(customTooltipWithoutAggregatedField=customTooltipWithoutAggregatedField[0]);JSCompiler_inline_result={customTooltipWithoutAggregatedField,
filteredEncoding:spec}}else JSCompiler_inline_result={filteredEncoding:spec};const {customTooltipWithoutAggregatedField:customTooltipWithoutAggregatedField$jscomp$0,filteredEncoding}=JSCompiler_inline_result,{bins,timeUnits,aggregate,groupby,encoding:encodingWithoutContinuousAxis}=extractTransformsFromEncoding(filteredEncoding,config);JSCompiler_inline_result=[...bins,...timeUnits,{aggregate:[...aggregate,...boxplotSpecificAggregate],groupby},...continuousFieldName];const {bins:bins$jscomp$0,timeUnits:timeUnits$jscomp$0,
transform,continuousAxisChannelDef:continuousAxisChannelDef$jscomp$0,continuousAxis:continuousAxis$jscomp$0,groupby:groupby$jscomp$0,aggregate:aggregate$jscomp$0,encodingWithoutContinuousAxis:encodingWithoutContinuousAxis$jscomp$0,ticksOrient,boxOrient,customTooltipWithoutAggregatedField:customTooltipWithoutAggregatedField$jscomp$2}={bins,timeUnits,transform:JSCompiler_inline_result,groupby,aggregate,continuousAxisChannelDef,continuousAxis,encodingWithoutContinuousAxis,ticksOrient:"vertical"===spec$jscomp$0?
"horizontal":"vertical",boxOrient:spec$jscomp$0,customTooltipWithoutAggregatedField:customTooltipWithoutAggregatedField$jscomp$0};customTooltipWithoutAggregatedField=Object.assign({},encodingWithoutContinuousAxis$jscomp$0);JSCompiler_inline_result=encodingWithoutContinuousAxis$jscomp$0.color;boxplotSpecificAggregate=encodingWithoutContinuousAxis$jscomp$0.size;customTooltipWithoutAggregatedField=(delete customTooltipWithoutAggregatedField.color,delete customTooltipWithoutAggregatedField.size,customTooltipWithoutAggregatedField);
t=makeCompositeAggregatePartFactory(mark,continuousAxis$jscomp$0,continuousAxisChannelDef$jscomp$0,customTooltipWithoutAggregatedField,config.boxplot);spec$jscomp$0=makeCompositeAggregatePartFactory(mark,continuousAxis$jscomp$0,continuousAxisChannelDef$jscomp$0,encodingWithoutContinuousAxis$jscomp$0,config.boxplot);boxplotSpecificAggregate=makeCompositeAggregatePartFactory(mark,continuousAxis$jscomp$0,continuousAxisChannelDef$jscomp$0,Object.assign({},customTooltipWithoutAggregatedField,boxplotSpecificAggregate?
{size:boxplotSpecificAggregate}:{}),config.boxplot);continuousFieldName=getCompositeMarkTooltip([{fieldPrefix:"min-max"===_markDef$extent?"upper_whisker_":"max_",titlePrefix:"Max"},{fieldPrefix:"upper_box_",titlePrefix:"Q3"},{fieldPrefix:"mid_box_",titlePrefix:"Median"},{fieldPrefix:"lower_box_",titlePrefix:"Q1"},{fieldPrefix:"min-max"===_markDef$extent?"lower_whisker_":"min_",titlePrefix:"Min"}],continuousAxisChannelDef$jscomp$0,encodingWithoutContinuousAxis$jscomp$0);spec={type:"tick",color:"black",
opacity:1,orient:ticksOrient,invalid:null,aria:!1};boxPlotType="min-max"===_markDef$extent?continuousFieldName:getCompositeMarkTooltip([{fieldPrefix:"upper_whisker_",titlePrefix:"Upper Whisker"},{fieldPrefix:"lower_whisker_",titlePrefix:"Lower Whisker"}],continuousAxisChannelDef$jscomp$0,encodingWithoutContinuousAxis$jscomp$0);t=[...t({partName:"rule",mark:{type:"rule",invalid:null,aria:!1},positionPrefix:"lower_whisker",endPositionPrefix:"lower_box",extraEncoding:boxPlotType}),...t({partName:"rule",
mark:{type:"rule",invalid:null,aria:!1},positionPrefix:"upper_box",endPositionPrefix:"upper_whisker",extraEncoding:boxPlotType}),...t({partName:"ticks",mark:spec,positionPrefix:"lower_whisker",extraEncoding:boxPlotType}),...t({partName:"ticks",mark:spec,positionPrefix:"upper_whisker",extraEncoding:boxPlotType})];sizeValue=[...("tukey"!==_markDef$extent?t:[]),...spec$jscomp$0({partName:"box",mark:Object.assign({},{type:"bar"},sizeValue?{size:sizeValue}:{},{orient:boxOrient,invalid:null,ariaRoleDescription:"box"}),
positionPrefix:"lower_box",endPositionPrefix:"upper_box",extraEncoding:continuousFieldName}),...boxplotSpecificAggregate({partName:"median",mark:Object.assign({},{type:"tick",invalid:null},vega.isObject(config.boxplot.median)&&config.boxplot.median.color?{color:config.boxplot.median.color}:{},sizeValue?{size:sizeValue}:{},{orient:ticksOrient,aria:!1}),positionPrefix:"mid_box",extraEncoding:continuousFieldName})];if("min-max"===_markDef$extent){var _outerSpec$transform;return Object.assign({},_ref,
{transform:(null!==(_outerSpec$transform=_ref.transform)&&void 0!==_outerSpec$transform?_outerSpec$transform:[]).concat(transform),layer:sizeValue})}_outerSpec$transform='datum["lower_box_'.concat(continuousAxisChannelDef$jscomp$0.field,'"]');_markDef$extent='datum["upper_box_'.concat(continuousAxisChannelDef$jscomp$0.field,'"]');spec$jscomp$0="(".concat(_markDef$extent," - ").concat(_outerSpec$transform,")");_outerSpec$transform="".concat(_outerSpec$transform," - ").concat($jscomp$destructuring$var36,
" * ").concat(spec$jscomp$0);spec$jscomp$0="".concat(_markDef$extent," + ").concat($jscomp$destructuring$var36," * ").concat(spec$jscomp$0);boxplotSpecificAggregate='datum["'.concat(continuousAxisChannelDef$jscomp$0.field,'"]');$jscomp$destructuring$var36={joinaggregate:boxParamsQuartiles(continuousAxisChannelDef$jscomp$0.field),groupby:groupby$jscomp$0};_markDef$extent={transform:[{filter:"(".concat(_outerSpec$transform," \x3c\x3d ").concat(boxplotSpecificAggregate,") \x26\x26 (").concat(boxplotSpecificAggregate,
" \x3c\x3d ").concat(spec$jscomp$0,")")},{aggregate:[{op:"min",field:continuousAxisChannelDef$jscomp$0.field,as:"lower_whisker_".concat(continuousAxisChannelDef$jscomp$0.field)},{op:"max",field:continuousAxisChannelDef$jscomp$0.field,as:"upper_whisker_".concat(continuousAxisChannelDef$jscomp$0.field)},{op:"min",field:"lower_box_".concat(continuousAxisChannelDef$jscomp$0.field),as:"lower_box_".concat(continuousAxisChannelDef$jscomp$0.field)},{op:"max",field:"upper_box_".concat(continuousAxisChannelDef$jscomp$0.field),
as:"upper_box_".concat(continuousAxisChannelDef$jscomp$0.field)},...aggregate$jscomp$0],groupby:groupby$jscomp$0}],layer:t};customTooltipWithoutAggregatedField=Object.assign({},customTooltipWithoutAggregatedField);customTooltipWithoutAggregatedField=(delete customTooltipWithoutAggregatedField.tooltip,customTooltipWithoutAggregatedField);const {scale,axis}=continuousAxisChannelDef$jscomp$0;t=getTitle(continuousAxisChannelDef$jscomp$0);continuousFieldName=omit(axis,["title"]);config=partLayerMixins(mark,
"outliers",config.boxplot,{transform:[{filter:"(".concat(boxplotSpecificAggregate," \x3c ").concat(_outerSpec$transform,") || (").concat(boxplotSpecificAggregate," \x3e ").concat(spec$jscomp$0,")")}],mark:"point",encoding:Object.assign({},{[continuousAxis$jscomp$0]:Object.assign({},{field:continuousAxisChannelDef$jscomp$0.field,type:continuousAxisChannelDef$jscomp$0.type},void 0!==t?{title:t}:{},void 0!==scale?{scale}:{},isEmpty(continuousFieldName)?{}:{axis:continuousFieldName})},customTooltipWithoutAggregatedField,
JSCompiler_inline_result?{color:JSCompiler_inline_result}:{},customTooltipWithoutAggregatedField$jscomp$2?{tooltip:customTooltipWithoutAggregatedField$jscomp$2}:{})})[0];mark=[...bins$jscomp$0,...timeUnits$jscomp$0,$jscomp$destructuring$var36];config?config={transform:mark,layer:[config,_markDef$extent]}:(config=_markDef$extent,config.transform.unshift(...mark));return Object.assign({},_ref,{layer:[config,{transform,layer:sizeValue}]})}function boxParamsQuartiles(continousAxisField){return[{op:"q1",
field:continousAxisField,as:"lower_box_".concat(continousAxisField)},{op:"q3",field:continousAxisField,as:"upper_box_".concat(continousAxisField)}]}function normalizeErrorBar(spec,_ref){({config:_ref}=_ref);spec=Object.assign({},spec,{encoding:normalizeEncoding(spec.encoding,_ref)});const {transform,continuousAxisChannelDef,continuousAxis,encodingWithoutContinuousAxis,ticksOrient,markDef,outerSpec,tooltipEncoding}=errorBarParams(spec,"errorbar",_ref);delete encodingWithoutContinuousAxis.size;spec=
makeCompositeAggregatePartFactory(markDef,continuousAxis,continuousAxisChannelDef,encodingWithoutContinuousAxis,_ref.errorbar);_ref=markDef.thickness;var size=markDef.size;size=Object.assign({},{type:"tick",orient:ticksOrient,aria:!1},void 0!==_ref?{thickness:_ref}:{},void 0!==size?{size}:{});spec=[...spec({partName:"ticks",mark:size,positionPrefix:"lower",extraEncoding:tooltipEncoding}),...spec({partName:"ticks",mark:size,positionPrefix:"upper",extraEncoding:tooltipEncoding}),...spec({partName:"rule",
mark:Object.assign({},{type:"rule",ariaRoleDescription:"errorbar"},void 0!==_ref?{size:_ref}:{}),positionPrefix:"lower",endPositionPrefix:"upper",extraEncoding:tooltipEncoding})];return Object.assign({},outerSpec,{transform},1<spec.length?{layer:spec}:Object.assign({},spec[0]))}function errorBarOrientAndInputType(spec,compositeMark){var {encoding}=spec;if(!(!isFieldOrDatumDef(encoding.x)&&!isFieldOrDatumDef(encoding.y)||isFieldOrDatumDef(encoding.x2)||isFieldOrDatumDef(encoding.y2)||isFieldOrDatumDef(encoding.xError)||
isFieldOrDatumDef(encoding.xError2)||isFieldOrDatumDef(encoding.yError)||isFieldOrDatumDef(encoding.yError2)))return{orient:compositeMarkOrient(spec,compositeMark),inputType:"raw"};var JSCompiler_inline_result=isFieldOrDatumDef(encoding.x2)||isFieldOrDatumDef(encoding.y2);var JSCompiler_inline_result$jscomp$0=isFieldOrDatumDef(encoding.xError)||isFieldOrDatumDef(encoding.xError2)||isFieldOrDatumDef(encoding.yError)||isFieldOrDatumDef(encoding.yError2);spec=encoding.x;const y=encoding.y;if(JSCompiler_inline_result){if(JSCompiler_inline_result$jscomp$0)throw Error("".concat(compositeMark,
" cannot be both type aggregated-upper-lower and aggregated-error"));JSCompiler_inline_result=encoding.x2;encoding=encoding.y2;if(isFieldOrDatumDef(JSCompiler_inline_result)&&isFieldOrDatumDef(encoding))throw Error("".concat(compositeMark," cannot have both x2 and y2"));if(isFieldOrDatumDef(JSCompiler_inline_result)){if(isContinuousFieldOrDatumDef(spec))return{orient:"horizontal",inputType:"aggregated-upper-lower"};throw Error("Both x and x2 have to be quantitative in ".concat(compositeMark));}if(isFieldOrDatumDef(encoding)){if(isContinuousFieldOrDatumDef(y))return{orient:"vertical",
inputType:"aggregated-upper-lower"};throw Error("Both y and y2 have to be quantitative in ".concat(compositeMark));}}else{JSCompiler_inline_result=encoding.xError;JSCompiler_inline_result$jscomp$0=encoding.yError;const yError2=encoding.yError2;if(isFieldOrDatumDef(encoding.xError2)&&!isFieldOrDatumDef(JSCompiler_inline_result))throw Error("".concat(compositeMark," cannot have xError2 without xError"));if(isFieldOrDatumDef(yError2)&&!isFieldOrDatumDef(JSCompiler_inline_result$jscomp$0))throw Error("".concat(compositeMark,
" cannot have yError2 without yError"));if(isFieldOrDatumDef(JSCompiler_inline_result)&&isFieldOrDatumDef(JSCompiler_inline_result$jscomp$0))throw Error("".concat(compositeMark," cannot have both xError and yError with both are quantiative"));if(isFieldOrDatumDef(JSCompiler_inline_result)){if(isContinuousFieldOrDatumDef(spec))return{orient:"horizontal",inputType:"aggregated-error"};throw Error("All x, xError, and xError2 (if exist) have to be quantitative");}if(isFieldOrDatumDef(JSCompiler_inline_result$jscomp$0)){if(isContinuousFieldOrDatumDef(y))return{orient:"vertical",
inputType:"aggregated-error"};throw Error("All y, yError, and yError2 (if exist) have to be quantitative");}}throw Error("No ranged axis");}function errorBarParams(spec,compositeMark,config){var _outerSpec$transform,$jscomp$destructuring$var46=Object.assign({},spec),mark=spec.mark,encoding=spec.encoding,params=spec.params;$jscomp$destructuring$var46=(delete $jscomp$destructuring$var46.mark,delete $jscomp$destructuring$var46.encoding,delete $jscomp$destructuring$var46.params,delete $jscomp$destructuring$var46.projection,
$jscomp$destructuring$var46);mark=isMarkDef(mark)?mark:{type:mark};params&&warn(selectionNotSupported(compositeMark));const {orient,inputType}=errorBarOrientAndInputType(spec,compositeMark),{continuousAxisChannelDef,continuousAxisChannelDef2,continuousAxisChannelDefError,continuousAxisChannelDefError2,continuousAxis}=compositeMarkContinuousAxis(spec,orient,compositeMark);var errorBarSpecificAggregate$jscomp$0=[];spec=[];params=continuousAxisChannelDef.field;var tooltipTitleWithFieldName$jscomp$0=
!1;if("raw"===inputType){var tooltipSummary=mark.center?mark.center:mark.extent?"iqr"===mark.extent?"median":"mean":config.errorbar.center;var extent=mark.extent?mark.extent:"mean"===tooltipSummary?"stderr":"iqr";"median"===tooltipSummary!==("iqr"===extent)&&(errorBarSpecificAggregate$jscomp$0=extent,errorBarSpecificAggregate$jscomp$0="".concat(tooltipSummary," is not usually used with ").concat(errorBarSpecificAggregate$jscomp$0," for ").concat(compositeMark,"."),warn(errorBarSpecificAggregate$jscomp$0));
"stderr"===extent||"stdev"===extent?(errorBarSpecificAggregate$jscomp$0=[{op:extent,field:params,as:"extent_".concat(params)},{op:tooltipSummary,field:params,as:"center_".concat(params)}],spec=[{calculate:'datum["center_'.concat(params,'"] + datum["extent_').concat(params,'"]'),as:"upper_".concat(params)},{calculate:'datum["center_'.concat(params,'"] - datum["extent_').concat(params,'"]'),as:"lower_".concat(params)}],tooltipSummary=[{fieldPrefix:"center_",titlePrefix:titleCase(tooltipSummary)},{fieldPrefix:"upper_",
titlePrefix:getTitlePrefix(tooltipSummary,extent,"+")},{fieldPrefix:"lower_",titlePrefix:getTitlePrefix(tooltipSummary,extent,"-")}],tooltipTitleWithFieldName$jscomp$0=!0):("ci"===extent?(compositeMark="mean",tooltipSummary="ci0",extent="ci1"):(compositeMark="median",tooltipSummary="q1",extent="q3"),errorBarSpecificAggregate$jscomp$0=[{op:tooltipSummary,field:params,as:"lower_".concat(params)},{op:extent,field:params,as:"upper_".concat(params)},{op:compositeMark,field:params,as:"center_".concat(params)}],
tooltipSummary=[{fieldPrefix:"upper_",titlePrefix:title$jscomp$0({field:params,aggregate:extent,type:"quantitative"},config,{allowDisabling:!1})},{fieldPrefix:"lower_",titlePrefix:title$jscomp$0({field:params,aggregate:tooltipSummary,type:"quantitative"},config,{allowDisabling:!1})},{fieldPrefix:"center_",titlePrefix:title$jscomp$0({field:params,aggregate:compositeMark,type:"quantitative"},config,{allowDisabling:!1})}])}else{if(mark.center||mark.extent){compositeMark=mark.center;var extent$jscomp$0=
mark.extent;compositeMark="".concat(extent$jscomp$0?"extent ":"").concat(extent$jscomp$0&&compositeMark?"and ":"").concat(compositeMark?"center ":"").concat(extent$jscomp$0&&compositeMark?"are ":"is ","not needed when data are aggregated.");warn(compositeMark)}"aggregated-upper-lower"===inputType?(tooltipSummary=[],spec=[{calculate:'datum["'.concat(continuousAxisChannelDef2.field,'"]'),as:"upper_".concat(params)},{calculate:'datum["'.concat(params,'"]'),as:"lower_".concat(params)}]):"aggregated-error"===
inputType&&(tooltipSummary=[{fieldPrefix:"",titlePrefix:params}],spec=[{calculate:'datum["'.concat(params,'"] + datum["').concat(continuousAxisChannelDefError.field,'"]'),as:"upper_".concat(params)}],continuousAxisChannelDefError2?spec.push({calculate:'datum["'.concat(params,'"] + datum["').concat(continuousAxisChannelDefError2.field,'"]'),as:"lower_".concat(params)}):spec.push({calculate:'datum["'.concat(params,'"] - datum["').concat(continuousAxisChannelDefError.field,'"]'),as:"lower_".concat(params)}));
for(extent of spec)tooltipSummary.push({fieldPrefix:extent.as.substring(0,6),titlePrefix:replaceAll(replaceAll(extent.calculate,'datum["',""),'"]',"")})}const {errorBarSpecificAggregate,postAggregateCalculates,tooltipSummary:tooltipSummary$jscomp$0,tooltipTitleWithFieldName}={postAggregateCalculates:spec,errorBarSpecificAggregate:errorBarSpecificAggregate$jscomp$0,tooltipSummary,tooltipTitleWithFieldName:tooltipTitleWithFieldName$jscomp$0};encoding=Object.assign({},encoding);spec="x"===continuousAxis?
"x2":"y2";params="x"===continuousAxis?"xError":"yError";tooltipTitleWithFieldName$jscomp$0="x"===continuousAxis?"xError2":"yError2";encoding=(delete encoding[continuousAxis],delete encoding[spec],delete encoding[params],delete encoding[tooltipTitleWithFieldName$jscomp$0],encoding);const {bins,timeUnits,aggregate:oldAggregate,groupby:oldGroupBy,encoding:encodingWithoutContinuousAxis}=extractTransformsFromEncoding(encoding,config);config=[...oldAggregate,...errorBarSpecificAggregate];encoding="raw"!==
inputType?[]:oldGroupBy;spec=getCompositeMarkTooltip(tooltipSummary$jscomp$0,continuousAxisChannelDef,encodingWithoutContinuousAxis,tooltipTitleWithFieldName);return{transform:[...(null!==(_outerSpec$transform=$jscomp$destructuring$var46.transform)&&void 0!==_outerSpec$transform?_outerSpec$transform:[]),...bins,...timeUnits,...(0===config.length?[]:[{aggregate:config,groupby:encoding}]),...postAggregateCalculates],groupby:encoding,continuousAxisChannelDef,continuousAxis,encodingWithoutContinuousAxis,
ticksOrient:"vertical"===orient?"horizontal":"vertical",markDef:mark,outerSpec:$jscomp$destructuring$var46,tooltipEncoding:spec}}function getTitlePrefix(center,extent,operation){return"".concat(titleCase(center)," ").concat(operation," ").concat(extent)}function normalizeErrorBand(spec,_ref){({config:_ref}=_ref);spec=Object.assign({},spec,{encoding:normalizeEncoding(spec.encoding,_ref)});const {transform,continuousAxisChannelDef,continuousAxis,encodingWithoutContinuousAxis,markDef,outerSpec,tooltipEncoding}=
errorBarParams(spec,"errorband",_ref);_ref=makeCompositeAggregatePartFactory(markDef,continuousAxis,continuousAxisChannelDef,encodingWithoutContinuousAxis,_ref.errorband);spec=void 0!==spec.encoding.x&&void 0!==spec.encoding.y;let bandMark={type:spec?"area":"rect"},bordersMark={type:spec?"line":"rule"};const interpolate=Object.assign({},markDef.interpolate?{interpolate:markDef.interpolate}:{},markDef.tension&&markDef.interpolate?{tension:markDef.tension}:{});spec?(bandMark=Object.assign({},bandMark,
interpolate,{ariaRoleDescription:"errorband"}),bordersMark=Object.assign({},bordersMark,interpolate,{aria:!1})):markDef.interpolate?warn(errorBand1DNotSupport("interpolate")):markDef.tension&&warn(errorBand1DNotSupport("tension"));return Object.assign({},outerSpec,{transform,layer:[..._ref({partName:"band",mark:bandMark,positionPrefix:"lower",endPositionPrefix:"upper",extraEncoding:tooltipEncoding}),..._ref({partName:"borders",mark:bordersMark,positionPrefix:"lower",extraEncoding:tooltipEncoding}),
..._ref({partName:"borders",mark:bordersMark,positionPrefix:"upper",extraEncoding:tooltipEncoding})]})}function add$jscomp$0(mark,run,parts){run=new CompositeMarkNormalizer(mark,run);compositeMarkRegistry[mark]={normalizer:run,parts}}function isLegendBinding(bind){return!!bind&&("legend"===bind||!!bind.legend)}function isLegendStreamBinding(bind){return isLegendBinding(bind)&&vega.isObject(bind)}function assembleParameterSignals(params){const signals=[];for(const param of params||[])if(!param.select){var $jscomp$destructuring$var53=
param,$jscomp$destructuring$var54=Object.assign({},$jscomp$destructuring$var53);params=$jscomp$destructuring$var53.expr;$jscomp$destructuring$var53=$jscomp$destructuring$var53.bind;$jscomp$destructuring$var54=(delete $jscomp$destructuring$var54.expr,delete $jscomp$destructuring$var54.bind,$jscomp$destructuring$var54);$jscomp$destructuring$var53&&params?(params=Object.assign({},$jscomp$destructuring$var54,{bind:$jscomp$destructuring$var53,init:params}),signals.push(params)):(params=Object.assign({},
$jscomp$destructuring$var54,params?{update:params}:{},$jscomp$destructuring$var53?{bind:$jscomp$destructuring$var53}:{}),signals.push(params))}return signals}function extractTopLevelProperties(t,includeParams){const o={};for(const p of TOP_LEVEL_PROPERTIES)t&&void 0!==t[p]&&(o[p]=signalRefOrValue(t[p]));includeParams&&(o.params=t.params);return o}function getStepFor(_ref){let {step,offsetIsDiscrete}=_ref;if(offsetIsDiscrete){var _step$for;return null!==(_step$for=step.for)&&void 0!==_step$for?_step$for:
"offset"}return"position"}function isStep(size){return vega.isObject(size)&&void 0!==size.step}function isFrameMixins(o){return o.view||o.width||o.height}function extractCompositionLayout(spec,specType,config){const layout={},{spacing:spacingConfig,columns}=config[specType];void 0!==spacingConfig&&(layout.spacing=spacingConfig);void 0!==columns&&("facet"in spec&&!isFacetMapping(spec.facet)||"concat"in spec)&&(layout.columns=columns);"vconcat"in spec&&(layout.columns=1);for(const prop of COMPOSITION_LAYOUT_PROPERTIES)if(void 0!==
spec[prop])if("spacing"===prop){var _spacing$row,_spacing$column;specType=spec[prop];layout[prop]=vega.isNumber(specType)?specType:{row:null!==(_spacing$row=specType.row)&&void 0!==_spacing$row?_spacing$row:spacingConfig,column:null!==(_spacing$column=specType.column)&&void 0!==_spacing$column?_spacing$column:spacingConfig}}else layout[prop]=spec[prop];return layout}function getViewConfigContinuousSize(viewConfig,channel){var _viewConfig$channel;return null!==(_viewConfig$channel=viewConfig[channel])&&
void 0!==_viewConfig$channel?_viewConfig$channel:viewConfig["width"===channel?"continuousWidth":"continuousHeight"]}function getViewConfigDiscreteStep(viewConfig,channel){viewConfig=getViewConfigDiscreteSize(viewConfig,channel);return isStep(viewConfig)?viewConfig.step:20}function getViewConfigDiscreteSize(viewConfig,channel){var _viewConfig$channel2;const size=null!==(_viewConfig$channel2=viewConfig[channel])&&void 0!==_viewConfig$channel2?_viewConfig$channel2:viewConfig["width"===channel?"discreteWidth":
"discreteHeight"];return getFirstDefined(size,{step:viewConfig.step})}function colorSignalConfig(){let color=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};return{signals:[{name:"color",value:vega.isObject(color)?Object.assign({},DEFAULT_COLOR,color):DEFAULT_COLOR}],mark:{color:{signal:"color.blue"}},rule:{color:{signal:"color.gray0"}},text:{color:{signal:"color.gray0"}},style:{"guide-label":{fill:{signal:"color.gray0"}},"guide-title":{fill:{signal:"color.gray0"}},"group-title":{fill:{signal:"color.gray0"}},
"group-subtitle":{fill:{signal:"color.gray0"}},cell:{stroke:{signal:"color.gray8"}}},axis:{domainColor:{signal:"color.gray13"},gridColor:{signal:"color.gray8"},tickColor:{signal:"color.gray13"}},range:{category:[{signal:"color.blue"},{signal:"color.orange"},{signal:"color.red"},{signal:"color.teal"},{signal:"color.green"},{signal:"color.yellow"},{signal:"color.purple"},{signal:"color.pink"},{signal:"color.brown"},{signal:"color.grey8"}]}}}function getAxisConfigInternal(axisConfig){var props=keys$jscomp$0(axisConfig||
{});const axisConfigInternal={};for(const prop of props)props=axisConfig[prop],axisConfigInternal[prop]=isConditionalAxisValue(props)?signalOrValueRefWithCondition(props):signalRefOrValue(props);return axisConfigInternal}function initConfig(){var $jscomp$destructuring$var55=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},$jscomp$destructuring$var56=Object.assign({},$jscomp$destructuring$var55),color=$jscomp$destructuring$var55.color,font=$jscomp$destructuring$var55.font,fontSize=$jscomp$destructuring$var55.fontSize;
$jscomp$destructuring$var55=$jscomp$destructuring$var55.selection;$jscomp$destructuring$var56=(delete $jscomp$destructuring$var56.color,delete $jscomp$destructuring$var56.font,delete $jscomp$destructuring$var56.fontSize,delete $jscomp$destructuring$var56.selection,$jscomp$destructuring$var56);var JSCompiler_temp_const=vega.mergeConfig,JSCompiler_temp_const$jscomp$0=duplicate(defaultConfig);font=font?{text:{font},style:{"guide-label":{font},"guide-title":{font},"group-title":{font},"group-subtitle":{font}}}:
{};color=color?colorSignalConfig(color):{};fontSize=fontSize?{signals:[{name:"fontSize",value:vega.isObject(fontSize)?Object.assign({},DEFAULT_FONT_SIZE,fontSize):DEFAULT_FONT_SIZE}],text:{fontSize:{signal:"fontSize.text"}},style:{"guide-label":{fontSize:{signal:"fontSize.guideLabel"}},"guide-title":{fontSize:{signal:"fontSize.guideTitle"}},"group-title":{fontSize:{signal:"fontSize.groupTitle"}},"group-subtitle":{fontSize:{signal:"fontSize.groupSubtitle"}}}}:{};fontSize=JSCompiler_temp_const.call(vega,
{},JSCompiler_temp_const$jscomp$0,font,color,fontSize,$jscomp$destructuring$var56||{});$jscomp$destructuring$var55&&vega.writeConfig(fontSize,"selection",$jscomp$destructuring$var55,!0);$jscomp$destructuring$var55=omit(fontSize,configPropsWithExpr);for(var prop$jscomp$0 of["background","lineBreak","padding"])fontSize[prop$jscomp$0]&&($jscomp$destructuring$var55[prop$jscomp$0]=signalRefOrValue(fontSize[prop$jscomp$0]));for(var markConfigType of MARK_CONFIGS)fontSize[markConfigType]&&($jscomp$destructuring$var55[markConfigType]=
replaceExprRef(fontSize[markConfigType]));for(var axisConfigType of AXIS_CONFIGS)fontSize[axisConfigType]&&($jscomp$destructuring$var55[axisConfigType]=getAxisConfigInternal(fontSize[axisConfigType]));for(const headerConfigType of HEADER_CONFIGS)fontSize[headerConfigType]&&($jscomp$destructuring$var55[headerConfigType]=replaceExprRef(fontSize[headerConfigType]));fontSize.legend&&($jscomp$destructuring$var55.legend=replaceExprRef(fontSize.legend));fontSize.scale&&($jscomp$destructuring$var55.scale=
replaceExprRef(fontSize.scale));if(fontSize.style){prop$jscomp$0=fontSize.style;markConfigType=keys$jscomp$0(prop$jscomp$0);axisConfigType={};for(const prop of markConfigType)axisConfigType[prop]=getAxisConfigInternal(prop$jscomp$0[prop]);$jscomp$destructuring$var55.style=axisConfigType}fontSize.title&&($jscomp$destructuring$var55.title=replaceExprRef(fontSize.title));fontSize.view&&($jscomp$destructuring$var55.view=replaceExprRef(fontSize.view));return $jscomp$destructuring$var55}function stripAndRedirectConfig(config){config=
duplicate(config);for(var prop$jscomp$0 of VL_ONLY_CONFIG_PROPERTIES)delete config[prop$jscomp$0];if(config.axis)for(var prop$jscomp$1 in config.axis)isConditionalAxisValue(config.axis[prop$jscomp$1])&&delete config.axis[prop$jscomp$1];if(config.legend)for(var prop$jscomp$2 of VL_ONLY_LEGEND_CONFIG)delete config.legend[prop$jscomp$2];if(config.mark){for(var prop$jscomp$3 of VL_ONLY_MARK_CONFIG_PROPERTIES)delete config.mark[prop$jscomp$3];config.mark.tooltip&&vega.isObject(config.mark.tooltip)&&delete config.mark.tooltip}config.params&&
(config.signals=(config.signals||[]).concat(assembleParameterSignals(config.params)),delete config.params);for(var markType of MARK_STYLES){for(const prop of VL_ONLY_MARK_CONFIG_PROPERTIES)delete config[markType][prop];if(prop$jscomp$0=VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX[markType])for(const prop of prop$jscomp$0)delete config[markType][prop];prop$jscomp$1=prop$jscomp$0=void 0;prop$jscomp$2=config;prop$jscomp$3=markType;var toProp=void 0,propConfig=prop$jscomp$2[prop$jscomp$3];"view"===
prop$jscomp$3&&(toProp="cell");propConfig=Object.assign({},propConfig,prop$jscomp$2.style[null!==(prop$jscomp$1=toProp)&&void 0!==prop$jscomp$1?prop$jscomp$1:prop$jscomp$3]);isEmpty(propConfig)||(prop$jscomp$2.style[null!==(prop$jscomp$0=toProp)&&void 0!==prop$jscomp$0?prop$jscomp$0:prop$jscomp$3]=propConfig);delete prop$jscomp$2[prop$jscomp$3]}for(const m of keys$jscomp$0(compositeMarkRegistry))delete config[m];markType=config;const {titleMarkConfig,subtitleMarkConfig,subtitle}=extractTitleConfig(markType.title);
isEmpty(titleMarkConfig)||(markType.style["group-title"]=Object.assign({},markType.style["group-title"],titleMarkConfig));isEmpty(subtitleMarkConfig)||(markType.style["group-subtitle"]=Object.assign({},markType.style["group-subtitle"],subtitleMarkConfig));isEmpty(subtitle)?delete markType.title:markType.title=subtitle;for(const prop in config)vega.isObject(config[prop])&&isEmpty(config[prop])&&delete config[prop];return isEmpty(config)?void 0:config}function isUnbinnedQuantitative(channelDef){return isFieldDef(channelDef)&&
"quantitative"===(channelDef&&channelDef.type)&&!channelDef.bin}function potentialStackedChannel(encoding,x){const y="x"===x?"y":"radius";var xDef=encoding[x];encoding=encoding[y];if(isFieldDef(xDef)&&isFieldDef(encoding))if(isUnbinnedQuantitative(xDef)&&isUnbinnedQuantitative(encoding)){if(xDef.stack)return x;if(encoding.stack)return y;const xAggregate=isFieldDef(xDef)&&!!xDef.aggregate,yAggregate=isFieldDef(encoding)&&!!encoding.aggregate;if(xAggregate!==yAggregate)return xAggregate?x:y;var _xDef$scale,
_yDef$scale;xDef=null===(_xDef$scale=xDef.scale)||void 0===_xDef$scale?void 0:_xDef$scale.type;_xDef$scale=null===(_yDef$scale=encoding.scale)||void 0===_yDef$scale?void 0:_yDef$scale.type;if(xDef&&"linear"!==xDef)return y;if(_xDef$scale&&"linear"!==_xDef$scale)return x}else{if(isUnbinnedQuantitative(xDef))return x;if(isUnbinnedQuantitative(encoding))return y}else{if(isUnbinnedQuantitative(xDef))return x;if(isUnbinnedQuantitative(encoding))return y}}function getDimensionChannel(channel){switch(channel){case "x":return"y";
case "y":return"x";case "theta":return"radius";case "radius":return"theta"}}function stack$jscomp$1(m,encoding){var _stackedFieldDef$scal,_stackedFieldDef$scal2;let opt=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};const mark=isMarkDef(m)?m.type:m;if(!STACKABLE_MARKS.has(mark))return null;const fieldChannel=potentialStackedChannel(encoding,"x")||potentialStackedChannel(encoding,"theta");if(!fieldChannel)return null;const stackedFieldDef=encoding[fieldChannel];var stackedField=isFieldDef(stackedFieldDef)?
vgField(stackedFieldDef,{}):void 0,dimensionChannel=getDimensionChannel(fieldChannel);const groupbyChannels=[],groupbyFields=new Set;if(encoding[dimensionChannel]){var dimensionDef=encoding[dimensionChannel];(dimensionDef=isFieldDef(dimensionDef)?vgField(dimensionDef,{}):void 0)&&dimensionDef!==stackedField&&(groupbyChannels.push(dimensionChannel),groupbyFields.add(dimensionDef));dimensionChannel="x"===dimensionChannel?"xOffset":"yOffset";dimensionDef=encoding[dimensionChannel];(dimensionDef=isFieldDef(dimensionDef)?
vgField(dimensionDef,{}):void 0)&&dimensionDef!==stackedField&&(groupbyChannels.push(dimensionChannel),groupbyFields.add(dimensionDef))}stackedField=NONPOSITION_CHANNELS.reduce((sc,channel)=>{if("tooltip"!==channel&&channelHasField(encoding,channel)){var channelDef=encoding[channel];for(const cDef of vega.array(channelDef)){channelDef=getFieldDef(cDef);if(channelDef.aggregate)continue;const f=vgField(channelDef,{});f&&groupbyFields.has(f)||sc.push({channel,fieldDef:channelDef})}}return sc},[]);let offset;
void 0!==stackedFieldDef.stack?offset=vega.isBoolean(stackedFieldDef.stack)?stackedFieldDef.stack?"zero":null:stackedFieldDef.stack:STACK_BY_DEFAULT_MARKS.has(mark)&&(offset="zero");if(!(offset&&offset in STACK_OFFSET_INDEX)||isAggregate$1(encoding)&&0===stackedField.length)return null;if(null!==stackedFieldDef&&void 0!==stackedFieldDef&&null!==(_stackedFieldDef$scal=stackedFieldDef.scale)&&void 0!==_stackedFieldDef$scal&&_stackedFieldDef$scal.type&&(null===stackedFieldDef||void 0===stackedFieldDef?
void 0:null===(_stackedFieldDef$scal2=stackedFieldDef.scale)||void 0===_stackedFieldDef$scal2?void 0:_stackedFieldDef$scal2.type)!==ScaleType.LINEAR){if(opt.disallowNonLinearStack)return null;warn("Cannot stack non-linear scale (".concat(stackedFieldDef.scale.type,")."))}if(isFieldOrDatumDef(encoding[getSecondaryRangeChannel(fieldChannel)]))return void 0!==stackedFieldDef.stack&&warn(cannotStackRangedMark(fieldChannel)),null;isFieldDef(stackedFieldDef)&&stackedFieldDef.aggregate&&!SUM_OPS.has(stackedFieldDef.aggregate)&&
warn('Stacking is applied even though the aggregate function is non-summative ("'.concat(stackedFieldDef.aggregate,'").'));return{groupbyChannels,groupbyFields,fieldChannel,impute:null===stackedFieldDef.impute?!1:isPathMark(mark),stackBy:stackedField,offset}}function getPointOverlay(markDef){let markConfig=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},encoding=2<arguments.length?arguments[2]:void 0;if("transparent"===markDef.point)return{opacity:0};if(markDef.point)return vega.isObject(markDef.point)?
markDef.point:{};if(void 0!==markDef.point)return null;if(markConfig.point||encoding.shape)return vega.isObject(markConfig.point)?markConfig.point:{}}function getLineOverlay(markDef){let markConfig=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(markDef.line)return!0===markDef.line?{}:markDef.line;if(void 0!==markDef.line)return null;if(markConfig.line)return!0===markConfig.line?{}:markConfig.line}function replaceRepeaterInEncoding(encoding,repeater){return repeater?replaceRepeaterInMapping(encoding,
repeater):encoding}function replaceRepeatInProp(prop,o,repeater){const val=o[prop];if(val&&!vega.isString(val)&&"repeat"in val){if(val.repeat in repeater)return Object.assign({},o,{[prop]:repeater[val.repeat]});warn('Unknown repeated value "'.concat(val.repeat,'".'))}else return o}function replaceRepeaterInFieldDef(fieldDef,repeater){fieldDef=replaceRepeatInProp("field",fieldDef,repeater);if(void 0!==fieldDef){if(null===fieldDef)return null;"sort"in fieldDef&&isSortField(fieldDef.sort)&&(repeater=
replaceRepeatInProp("field",fieldDef.sort,repeater),fieldDef=Object.assign({},fieldDef,repeater?{sort:repeater}:{}));return fieldDef}}function replaceRepeaterInFieldOrDatumDef(def,repeater){if(isFieldDef(def))return replaceRepeaterInFieldDef(def,repeater);repeater=replaceRepeatInProp("datum",def,repeater);repeater===def||repeater.type||(repeater.type="nominal");return repeater}function replaceRepeaterInChannelDef(channelDef,repeater){if(isFieldOrDatumDef(channelDef)){if(repeater=replaceRepeaterInFieldOrDatumDef(channelDef,
repeater))return repeater;if(isConditionalDef(channelDef))return{condition:channelDef.condition}}else{if(hasConditionalFieldOrDatumDef(channelDef)){if(repeater=replaceRepeaterInFieldOrDatumDef(channelDef.condition,repeater))return Object.assign({},channelDef,{condition:repeater});channelDef=Object.assign({},channelDef);return delete channelDef.condition,channelDef}return channelDef}}function replaceRepeaterInMapping(mapping,repeater){const out={};for(const channel in mapping)if(vega.hasOwnProperty(mapping,
channel)){var channelDef=mapping[channel];vega.isArray(channelDef)?out[channel]=channelDef.map(cd=>replaceRepeaterInChannelDef(cd,repeater)).filter(cd=>cd):(channelDef=replaceRepeaterInChannelDef(channelDef,repeater),void 0!==channelDef&&(out[channel]=channelDef))}return out}function mergeEncoding(_ref2){let {parentEncoding,encoding={},layer}=_ref2;_ref2={};if(parentEncoding){var channels=new Set([...keys$jscomp$0(parentEncoding),...keys$jscomp$0(encoding)]);for(const channel of channels){channels=
encoding[channel];const parentChannelDef=parentEncoding[channel];if(isFieldOrDatumDef(channels))channels=Object.assign({},parentChannelDef,channels),_ref2[channel]=channels;else if(hasConditionalFieldOrDatumDef(channels))_ref2[channel]=Object.assign({},channels,{condition:Object.assign({},parentChannelDef,channels.condition)});else if(channels||null===channels)_ref2[channel]=channels;else if(layer||isValueDef(parentChannelDef)||isSignalRef(parentChannelDef)||isFieldOrDatumDef(parentChannelDef)||vega.isArray(parentChannelDef))_ref2[channel]=
parentChannelDef}}else _ref2=encoding;return!_ref2||isEmpty(_ref2)?void 0:_ref2}function mergeProjection(opt){const {parentProjection:parentProjection$jscomp$0,projection:projection$jscomp$0}=opt;if(parentProjection$jscomp$0&&projection$jscomp$0){const {parentProjection,projection}={parentProjection:parentProjection$jscomp$0,projection:projection$jscomp$0};opt="Layer's shared projection ".concat(stringify(parentProjection)," is overridden by a child projection ").concat(stringify(projection),".");
warn(opt)}return null!==projection$jscomp$0&&void 0!==projection$jscomp$0?projection$jscomp$0:parentProjection$jscomp$0}function normalizeTransform(transform){return transform.map(t=>"filter"in t?{filter:normalizeLogicalComposition(t.filter,normalizePredicate$1)}:t)}function normalizeTransforms(spec,normParams){var $jscomp$destructuring$var87=Object.assign({},spec);const tx=spec.transform;$jscomp$destructuring$var87=(delete $jscomp$destructuring$var87.transform,$jscomp$destructuring$var87);return tx?
(spec=tx.map(t=>{if("filter"in t)return{filter:normalizePredicate(t,normParams)};if("bin"in t&&vega.isObject(t.bin))return Object.assign({},t,{bin:normalizeBinExtent(t.bin)});if("lookup"in t){var $jscomp$destructuring$var88=t.from,$jscomp$destructuring$var89=Object.assign({},$jscomp$destructuring$var88);$jscomp$destructuring$var88=$jscomp$destructuring$var88.selection;$jscomp$destructuring$var89=(delete $jscomp$destructuring$var89.selection,$jscomp$destructuring$var89);return $jscomp$destructuring$var88?
Object.assign({},t,{from:Object.assign({},{param:$jscomp$destructuring$var88},$jscomp$destructuring$var89)}):t}return t}),Object.assign({},$jscomp$destructuring$var87,{transform:spec})):spec}function normalizeChannelDef(obj,normParams){var _enc$scale,_enc$scale$domain;obj=duplicate(obj);isFieldDef(obj)&&vega.isObject(obj.bin)&&(obj.bin=normalizeBinExtent(obj.bin));isScaleFieldDef(obj)&&null!==(_enc$scale=obj.scale)&&void 0!==_enc$scale&&null!==(_enc$scale$domain=_enc$scale.domain)&&void 0!==_enc$scale$domain&&
_enc$scale$domain.selection&&(_enc$scale$domain=obj.scale.domain,_enc$scale=Object.assign({},_enc$scale$domain),_enc$scale$domain=_enc$scale$domain.selection,_enc$scale=(delete _enc$scale.selection,_enc$scale),obj.scale.domain=Object.assign({},_enc$scale,_enc$scale$domain?{param:_enc$scale$domain}:{}));isConditionalDef(obj)&&(vega.isArray(obj.condition)?obj.condition=obj.condition.map(c=>{var $jscomp$destructuring$var93=Object.assign({},c);const param=c.param;$jscomp$destructuring$var93=(delete $jscomp$destructuring$var93.selection,
delete $jscomp$destructuring$var93.param,delete $jscomp$destructuring$var93.test,$jscomp$destructuring$var93);return param?c:Object.assign({},$jscomp$destructuring$var93,{test:normalizePredicate(c,normParams)})}):(_enc$scale$domain=normalizeChannelDef(obj.condition,normParams),_enc$scale=Object.assign({},_enc$scale$domain),_enc$scale$domain=_enc$scale$domain.param,_enc$scale=(delete _enc$scale.selection,delete _enc$scale.param,delete _enc$scale.test,_enc$scale),obj.condition=_enc$scale$domain?obj.condition:
Object.assign({},_enc$scale,{test:normalizePredicate(obj.condition,normParams)})));return obj}function normalizeBinExtent(bin){var ext=bin.extent;if(null!==ext&&void 0!==ext&&ext.selection){var $jscomp$destructuring$var97=Object.assign({},ext);ext=ext.selection;$jscomp$destructuring$var97=(delete $jscomp$destructuring$var97.selection,$jscomp$destructuring$var97);return Object.assign({},bin,{extent:Object.assign({},$jscomp$destructuring$var97,{param:ext})})}return bin}function normalizePredicate(op,
normParams){const normalizeSelectionComposition=o=>normalizeLogicalComposition(o,param=>{var _normParams$emptySele2,_normParams$selection3,_normParams$selection4;const empty=null!==(_normParams$emptySele2=normParams.emptySelections[param])&&void 0!==_normParams$emptySele2?_normParams$emptySele2:!0;_normParams$emptySele2={param,empty};null!==(_normParams$selection4=(_normParams$selection3=normParams.selectionPredicates)[param])&&void 0!==_normParams$selection4?_normParams$selection4:_normParams$selection3[param]=
[];normParams.selectionPredicates[param].push(_normParams$emptySele2);return _normParams$emptySele2});return op.selection?normalizeSelectionComposition(op.selection):normalizeLogicalComposition(op.test||op.filter,o=>o.selection?normalizeSelectionComposition(o.selection):o)}function addSpecNameToParams(spec,params){var _params$path;return spec.name?Object.assign({},params,{path:(null!==(_params$path=params.path)&&void 0!==_params$path?_params$path:[]).concat(spec.name)}):params}function normalize$jscomp$0(spec,
config){void 0===config&&(config=initConfig(spec.config));const normalizedSpec=normalizeGenericSpec(spec,config),{width:width$jscomp$0,height:height$jscomp$0}=spec;{let {width,height}={width:width$jscomp$0,height:height$jscomp$0,autosize:spec.autosize};spec=isUnitSpec(normalizedSpec)||"layer"in normalizedSpec;const autosizeDefault={};spec?"container"==width&&"container"==height?(autosizeDefault.type="fit",autosizeDefault.contains="padding"):"container"==width?(autosizeDefault.type="fit-x",autosizeDefault.contains=
"padding"):"container"==height&&(autosizeDefault.type="fit-y",autosizeDefault.contains="padding"):("container"==width&&(warn(containerSizeNonSingle("width")),width=void 0),"container"==height&&(warn(containerSizeNonSingle("height")),height=void 0));config=Object.assign({},{type:"pad"},autosizeDefault,config?_normalizeAutoSize(config.autosize):{},_normalizeAutoSize(normalizedSpec.autosize));"fit"!==config.type||spec||(warn('Autosize "fit" only works for single views and layered views.'),config.type=
"pad");"container"==width&&"fit"!=config.type&&"fit-x"!=config.type&&warn(containerSizeNotCompatibleWithAutosize("width"));"container"==height&&"fit"!=config.type&&"fit-y"!=config.type&&warn(containerSizeNotCompatibleWithAutosize("height"));config=deepEqual(config,{type:"pad"})?void 0:config}return Object.assign({},normalizedSpec,config?{autosize:config}:{})}function normalizeGenericSpec(spec){const normParams={config:1<arguments.length&&void 0!==arguments[1]?arguments[1]:{}};return topLevelSelectionNormalizer.map(coreNormalizer.map(selectionCompatNormalizer.map(spec,
normParams),normParams),normParams)}function _normalizeAutoSize(autosize){return vega.isString(autosize)?{type:autosize}:null!==autosize&&void 0!==autosize?autosize:{}}function makeExplicit(value){return{explicit:!0,value}}function makeImplicit(value){return{explicit:!1,value}}function tieBreakByComparing(compare){return(v1,v2,property,propertyOf)=>{const diff=compare(v1.value,v2.value);return 0<diff?v1:0>diff?v2:defaultTieBreaker(v1,v2,property,propertyOf)}}function defaultTieBreaker(v1$jscomp$0,
v2,property,propertyOf){if(v1$jscomp$0.explicit&&v2.explicit){var v1=v1$jscomp$0.value;v2=v2.value;property="Conflicting ".concat(propertyOf.toString(),' property "').concat(property.toString(),'" (').concat(stringify(v1)," and ").concat(stringify(v2),"). Using ").concat(stringify(v1),".");warn(property)}return v1$jscomp$0}function mergeValuesWithExplicit(v1,v2,property,propertyOf){let tieBreaker=4<arguments.length&&void 0!==arguments[4]?arguments[4]:defaultTieBreaker;return void 0===v1||void 0===
v1.value?v2:v1.explicit&&!v2.explicit?v1:v2.explicit&&!v1.explicit?v2:deepEqual(v1.value,v2.value)?v1:tieBreaker(v1,v2,property,propertyOf)}function isNamedData(data){return"name"in data&&!("url"in data)&&!("values"in data)&&!isGenerator(data)}function isGenerator(data){return data&&("sequence"in data||"sphere"in data||"graticule"in data)}function assembleInit(init){let isExpr=1<arguments.length&&void 0!==arguments[1]?arguments[1]:!0,wrap=2<arguments.length&&void 0!==arguments[2]?arguments[2]:vega.identity;
if(vega.isArray(init)){const assembled=init.map(v=>assembleInit(v,isExpr,wrap));return isExpr?"[".concat(assembled.join(", "),"]"):assembled}return isDateTime(init)?isExpr?wrap(dateTimeToExpr(init)):wrap(dateTimeToTimestamp(init)):isExpr?wrap(stringify(init)):init}function assembleFacetSignals(model,signals){model.component.selection&&keys$jscomp$0(model.component.selection).length&&(model=vega.stringValue(model.getName("cell")),signals.unshift({name:"facet",value:{},on:[{events:vega.parseSelector("mousemove",
"scope"),update:"isTuple(facet) ? facet : group(".concat(model,").datum")}]}));return cleanupEmptyOnArray(signals)}function assembleTopLevelSignals(model,signals){var hasSelections=!1;for(const selCmpt of vals$jscomp$0(null!==(_model$component$sele2=model.component.selection)&&void 0!==_model$component$sele2?_model$component$sele2:{})){var _model$component$sele2;const name=selCmpt.name;hasSelections=vega.stringValue(name+"_store");if(0===signals.filter(s=>s.name===name).length){_model$component$sele2=
"global"===selCmpt.resolve?"union":selCmpt.resolve;const isPoint="point"===selCmpt.type?", true, true)":")";signals.push({name:selCmpt.name,update:"".concat("vlSelectionResolve","(").concat(hasSelections,", ").concat(vega.stringValue(_model$component$sele2)).concat(isPoint)})}hasSelections=!0;for(const c of selectionCompilers)c.defined(selCmpt)&&c.topLevelSignals&&(signals=c.topLevelSignals(model,selCmpt,signals))}hasSelections&&0===signals.filter(s=>"unit"===s.name).length&&signals.unshift({name:"unit",
value:{},on:[{events:"mousemove",update:"isTuple(group()) ? group() : unit"}]});return cleanupEmptyOnArray(signals)}function assembleUnitSelectionData(model,data){data=[...data];for(const selCmpt of vals$jscomp$0(null!==(_model$component$sele3=model.component.selection)&&void 0!==_model$component$sele3?_model$component$sele3:{})){var _model$component$sele3;_model$component$sele3={name:selCmpt.name+"_store"};if(selCmpt.init){const fields=selCmpt.project.items.map(proj=>{proj=Object.assign({},proj);
return delete proj.signals,proj});_model$component$sele3.values=selCmpt.init.map(i=>({unit:unitName(model,{escape:!1}),fields,values:assembleInit(i,!1)}))}data.filter(d=>d.name===selCmpt.name+"_store").length||data.push(_model$component$sele3)}return data}function assembleUnitSelectionMarks(model,marks){for(const selCmpt of vals$jscomp$0(null!==(_model$component$sele4=model.component.selection)&&void 0!==_model$component$sele4?_model$component$sele4:{})){var _model$component$sele4;for(const c of selectionCompilers)c.defined(selCmpt)&&
c.marks&&(marks=c.marks(model,selCmpt,marks))}return marks}function assembleLayerSelectionMarks(model,marks){for(const child of model.children)isUnitModel(child)&&(marks=assembleUnitSelectionMarks(child,marks));return marks}function cleanupEmptyOnArray(signals){return signals.map(s=>{s.on&&!s.on.length&&delete s.on;return s})}function domain$jscomp$0(model,channel){model=vega.stringValue(model.scaleName(channel));return"domain(".concat(model,")")}function isTopLevelLayer(model){var _model$parent$parent;
return model.parent&&isLayerModel(model.parent)&&(null!==(_model$parent$parent=!model.parent.parent)&&void 0!==_model$parent$parent?_model$parent$parent:isTopLevelLayer(model.parent.parent))}function channelSignals(model,selCmpt,proj,init){const channel=proj.channel,vname=proj.signals.visual;proj=proj.signals.data;const hasScales=scaleBindings.defined(selCmpt),scaleName=vega.stringValue(model.scaleName(channel));var scale=model.getScaleComponent(channel);scale=scale?scale.get("type"):void 0;const scaled=
str=>"scale(".concat(scaleName,", ").concat(str,")"),size=model.getSizeSignalRef("x"===channel?"width":"height").signal,coord="".concat(channel,"(unit)");model=events$jscomp$0(selCmpt,(def,evt)=>[...def,{events:evt.between[0],update:"[".concat(coord,", ").concat(coord,"]")},{events:evt,update:"[".concat(vname,"[0], clamp(").concat(coord,", 0, ").concat(size,")]")}]);model.push({events:{signal:selCmpt.name+"_scale_trigger"},update:hasContinuousDomain(scale)?"[".concat(scaled("".concat(proj,"[0]")),
", ").concat(scaled("".concat(proj,"[1]")),"]"):"[0, 0]"});return hasScales?[{name:proj,on:[]}]:[Object.assign({},{name:vname},init?{init:assembleInit(init,!0,scaled)}:{value:[]},{on:model}),Object.assign({},{name:proj},init?{init:assembleInit(init)}:{},{on:[{events:{signal:vname},update:"".concat(vname,"[0] \x3d\x3d\x3d ").concat(vname,"[1] ? null : invert(").concat(scaleName,", ").concat(vname,")")}]})]}function events$jscomp$0(selCmpt,cb){return selCmpt.events.reduce((on,evt)=>evt.between?cb(on,
evt):(warn("".concat(evt," is not an ordered event stream for interval selections.")),on),[])}function wrapCondition(model,channelDef,vgChannel,refFn){var condition=isConditionalDef(channelDef)&&channelDef.condition;channelDef=refFn(channelDef);return condition?(condition=vega.array(condition).map(c=>{const conditionValueRef=refFn(c);if(c.param){const {param,empty}=c;c=parseSelectionPredicate(model,{param,empty});return Object.assign({},{test:c},conditionValueRef)}c=expression$jscomp$0(model,c.test);
return Object.assign({},{test:c},conditionValueRef)}),{[vgChannel]:[...condition,...(void 0!==channelDef?[channelDef]:[])]}):void 0!==channelDef?{[vgChannel]:channelDef}:{}}function text$1(model){let channel=1<arguments.length&&void 0!==arguments[1]?arguments[1]:"text";return wrapCondition(model,model.encoding[channel],channel,cDef=>textRef(cDef,model.config))}function textRef(channelDef,config){let expr=2<arguments.length&&void 0!==arguments[2]?arguments[2]:"datum";if(channelDef){if(isValueDef(channelDef))return signalOrValueRef(channelDef.value);
if(isFieldOrDatumDef(channelDef)){const {format,formatType}=getFormatMixins(channelDef);return formatSignalRef({fieldOrDatumDef:channelDef,format,formatType,expr,config})}}}function tooltip(model){let opt=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};const {encoding,markDef,config,stack}=model,channelDef=encoding.tooltip;if(vega.isArray(channelDef))return{tooltip:tooltipRefForEncoding({tooltip:channelDef},stack,config,opt)};const datum=opt.reactiveGeom?"datum.datum":"datum";return wrapCondition(model,
channelDef,"tooltip",cDef=>{const tooltipRefFromChannelDef=textRef(cDef,config,datum);if(tooltipRefFromChannelDef)return tooltipRefFromChannelDef;if(null!==cDef){cDef=getMarkPropOrConfig("tooltip",markDef,config);!0===cDef&&(cDef={content:"encoding"});if(vega.isString(cDef))return{value:cDef};if(vega.isObject(cDef))return isSignalRef(cDef)?cDef:"encoding"===cDef.content?tooltipRefForEncoding(encoding,stack,config,opt):{signal:datum}}})}function tooltipData(encoding,stack,config){function add(fDef,
channel){var _value,mainChannel=getMainRangeChannel(channel);fDef=isTypedFieldDef(fDef)?fDef:Object.assign({},fDef,{type:encoding[mainChannel].type});mainChannel=fDef.title||titleFormatter(fDef,config);mainChannel=vega.array(mainChannel).join(", ");if(isXorY(channel)){const channel2="x"===channel?"x2":"y2";var fieldDef2=getFieldDef(encoding[channel2]);if(isBinned(fDef.bin)&&fieldDef2){var value=vgField(fDef,{expr});fieldDef2=vgField(fieldDef2,{expr});const {format,formatType}=getFormatMixins(fDef);
value=binFormatExpression(value,fieldDef2,format,formatType,config);toSkip[channel2]=!0}else if(stack&&stack.fieldChannel===channel&&"normalize"===stack.offset){const {format,formatType}=getFormatMixins(fDef);value=formatSignalRef({fieldOrDatumDef:fDef,format,formatType,expr,config,normalizeStack:!0}).signal}}null!==(_value=value)&&void 0!==_value?_value:value=textRef(fDef,config,expr).signal;tuples.push({channel,key:mainChannel,value})}var {reactiveGeom}=3<arguments.length&&void 0!==arguments[3]?
arguments[3]:{};const toSkip={},expr=reactiveGeom?"datum.datum":"datum",tuples=[];forEach(encoding,(channelDef,channel)=>{isFieldDef(channelDef)?add(channelDef,channel):hasConditionalFieldDef(channelDef)&&add(channelDef.condition,channel)});reactiveGeom={};for(const $jscomp$destructuring$var109 of tuples){const {channel,key,value}=$jscomp$destructuring$var109;toSkip[channel]||reactiveGeom[key]||(reactiveGeom[key]=value)}return reactiveGeom}function tooltipRefForEncoding(encoding,stack,config){var {reactiveGeom}=
3<arguments.length&&void 0!==arguments[3]?arguments[3]:{};reactiveGeom=tooltipData(encoding,stack,config,{reactiveGeom});reactiveGeom=entries$1(reactiveGeom).map(_ref=>{let [key,value]=_ref;return'"'.concat(key,'": ').concat(value)});return 0<reactiveGeom.length?{signal:"{".concat(reactiveGeom.join(", "),"}")}:void 0}function description(model){const {encoding,markDef,config,stack}=model;var channelDef=encoding.description;if(channelDef)return wrapCondition(model,channelDef,"description",cDef=>textRef(cDef,
model.config));channelDef=getMarkPropOrConfig("description",markDef,config);if(null!=channelDef)return{description:signalOrValueRef(channelDef)};if(!1===config.aria)return{};channelDef=tooltipData(encoding,stack,config);if(!isEmpty(channelDef))return{description:{signal:entries$1(channelDef).map((_ref,index)=>{let [key,value]=_ref;return'"'.concat(0<index?"; ":"").concat(key,': " + (').concat(value,")")}).join(" + ")}}}function nonPosition(channel,model){let opt=2<arguments.length&&void 0!==arguments[2]?
arguments[2]:{};const {markDef,encoding,config}=model,{vgChannel}=opt;let {defaultRef,defaultValue}=opt;if(void 0===defaultRef){var _defaultValue;null!==(_defaultValue=defaultValue)&&void 0!==_defaultValue?_defaultValue:defaultValue=getMarkPropOrConfig(channel,markDef,config,{vgChannel,ignoreVgConfig:!0});void 0!==defaultValue&&(defaultRef=signalOrValueRef(defaultValue))}return wrapCondition(model,encoding[channel],null!==vgChannel&&void 0!==vgChannel?vgChannel:channel,cDef=>midPoint({channel,channelDef:cDef,
markDef,config,scaleName:model.scaleName(channel),scale:model.getScaleComponent(channel),stack:null,defaultRef}))}function color$jscomp$0(model){var _opt$filled,_ref,_getMarkPropOrConfig,_getMarkPropOrConfig2,opt=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{filled:void 0};const {markDef,encoding,config}=model;var {type:markType}=markDef;opt=null!==(_opt$filled=opt.filled)&&void 0!==_opt$filled?_opt$filled:getMarkPropOrConfig("filled",markDef,config);markType=contains(["bar","point","circle",
"square","geoshape"],markType)?"transparent":void 0;_opt$filled=null!==(_ref=null!==(_getMarkPropOrConfig=getMarkPropOrConfig(!0===opt?"color":void 0,markDef,config,{vgChannel:"fill"}))&&void 0!==_getMarkPropOrConfig?_getMarkPropOrConfig:config.mark[!0===opt&&"color"])&&void 0!==_ref?_ref:markType;_ref=null!==(_getMarkPropOrConfig2=getMarkPropOrConfig(!1===opt?"color":void 0,markDef,config,{vgChannel:"stroke"}))&&void 0!==_getMarkPropOrConfig2?_getMarkPropOrConfig2:config.mark[!1===opt&&"color"];
_getMarkPropOrConfig2=opt?"fill":"stroke";_getMarkPropOrConfig=Object.assign({},_opt$filled?{fill:signalOrValueRef(_opt$filled)}:{},_ref?{stroke:signalOrValueRef(_ref)}:{});markDef.color&&(opt?markDef.fill:markDef.stroke)&&warn(droppingColor("property",{fill:"fill"in markDef,stroke:"stroke"in markDef}));return Object.assign({},_getMarkPropOrConfig,nonPosition("color",model,{vgChannel:_getMarkPropOrConfig2,defaultValue:opt?_opt$filled:_ref}),nonPosition("fill",model,{defaultValue:encoding.fill?_opt$filled:
void 0}),nonPosition("stroke",model,{defaultValue:encoding.stroke?_ref:void 0}))}function zindex(model){const {encoding,mark}=model,order=encoding.order;return!isPathMark(mark)&&isValueDef(order)?wrapCondition(model,order,"zindex",cd=>signalOrValueRef(cd.value)):{}}function positionOffset(_ref){let {channel:baseChannel,markDef,encoding={},model,bandPosition}=_ref;_ref="".concat(baseChannel,"Offset");const defaultValue=markDef[_ref],channelDef=encoding[_ref];return"xOffset"!==_ref&&"yOffset"!==_ref||
!channelDef?(_ref=markDef[_ref])?{offsetType:"visual",offset:_ref}:{}:{offsetType:"encoding",offset:midPoint({channel:_ref,channelDef,markDef,config:null===model||void 0===model?void 0:model.config,scaleName:model.scaleName(_ref),scale:model.getScaleComponent(_ref),stack:null,defaultRef:signalOrValueRef(defaultValue),bandPosition})}}function pointPosition(channel$jscomp$0,model,_ref){let {defaultPos,vgChannel}=_ref;const {encoding,markDef:markDef$jscomp$0,config,stack:stack$jscomp$0}=model;_ref=encoding[channel$jscomp$0];
const channel2Def=encoding[getSecondaryRangeChannel(channel$jscomp$0)],scaleName$jscomp$0=model.scaleName(channel$jscomp$0),scale=model.getScaleComponent(channel$jscomp$0),{offset:offset$jscomp$0,offsetType}=positionOffset({channel:channel$jscomp$0,markDef:markDef$jscomp$0,encoding,model,bandPosition:.5}),defaultRef=pointPositionDefaultRef({model,defaultPos,channel:channel$jscomp$0,scaleName:scaleName$jscomp$0,scale});if(!_ref&&isXorY(channel$jscomp$0)&&(encoding.latitude||encoding.longitude))model=
{field:model.getName(channel$jscomp$0)};else a:{model={channel:channel$jscomp$0,channelDef:_ref,channel2Def,markDef:markDef$jscomp$0,config,scaleName:scaleName$jscomp$0,scale,stack:stack$jscomp$0,offset:offset$jscomp$0,defaultRef,bandPosition:"encoding"===offsetType?0:void 0};const {channel,channelDef,scaleName,stack,offset,markDef}=model;if(isFieldOrDatumDef(channelDef)&&stack&&channel===stack.fieldChannel){if(isFieldDef(channelDef)&&(model=channelDef.bandPosition,void 0!==model||"text"!==markDef.type||
"radius"!==channel&&"theta"!==channel||(model=.5),void 0!==model)){model=interpolatedSignalRef({scaleName,fieldOrDatumDef:channelDef,startSuffix:"start",bandPosition:model,offset});break a}model=valueRefForFieldOrDatumDef(channelDef,scaleName,{suffix:"end"},{offset})}else model=midPointRefWithPositionInvalidTest(model)}return model?{[vgChannel||channel$jscomp$0]:model}:void 0}function pointPositionDefaultRef(_ref2){let {model,defaultPos,channel,scaleName,scale}=_ref2;const {markDef,config}=model;
return()=>{var mainChannel=getMainRangeChannel(channel),vgChannel=getVgPositionChannel(channel);vgChannel=getMarkPropOrConfig(channel,markDef,config,{vgChannel});if(void 0!==vgChannel)return widthHeightValueOrSignalRef(channel,vgChannel);switch(defaultPos){case "zeroOrMin":case "zeroOrMax":if(scaleName&&(vgChannel=scale.get("type"),!contains([ScaleType.LOG,ScaleType.TIME,ScaleType.UTC],vgChannel)&&scale.domainDefinitelyIncludesZero()))return{scale:scaleName,value:0};if("zeroOrMin"===defaultPos)return"y"===
mainChannel?{field:{group:"height"}}:{value:0};switch(mainChannel){case "radius":return{signal:"min(".concat(model.width.signal,",").concat(model.height.signal,")/2")};case "theta":return{signal:"2*PI"};case "x":return{field:{group:"width"}};case "y":return{value:0}}break;case "mid":return mainChannel=model[getSizeChannel(channel)],Object.assign({},mainChannel,{mult:.5})}}}function vgAlignedPositionChannel(channel,markDef,config){let defaultAlign=3<arguments.length&&void 0!==arguments[3]?arguments[3]:
"middle";if("radius"===channel||"theta"===channel)return getVgPositionChannel(channel);var alignChannel="x"===channel?"align":"baseline";const align=getMarkPropOrConfig(alignChannel,markDef,config);isSignalRef(align)?(warn("The ".concat(alignChannel," for range marks cannot be an expression")),alignChannel=void 0):alignChannel=align;return"x"===channel?ALIGNED_X_CHANNEL[alignChannel||("top"===defaultAlign?"left":"center")]:BASELINED_Y_CHANNEL[alignChannel||defaultAlign]}function pointOrRangePosition(channel,
model,_ref){let {defaultPos,defaultPos2,range}=_ref;return range?rangePosition(channel,model,{defaultPos,defaultPos2}):pointPosition(channel,model,{defaultPos})}function rangePosition(channel$jscomp$0,model,_ref2){let {defaultPos,defaultPos2}=_ref2;const {markDef:markDef$jscomp$1,config:config$jscomp$1}=model;var channel2=getSecondaryRangeChannel(channel$jscomp$0);_ref2=getSizeChannel(channel$jscomp$0);{const {encoding,mark,markDef:markDef$jscomp$0,stack:stack$jscomp$0,config:config$jscomp$0}=model;
var baseChannel=getMainRangeChannel(channel2),sizeChannel=getSizeChannel(channel2);const vgChannel=getVgPositionChannel(channel2);var channelDef$jscomp$0=encoding[baseChannel],scaleName$jscomp$0=model.scaleName(baseChannel);const scale$jscomp$0=model.getScaleComponent(baseChannel);({offset:baseChannel}=channel2 in encoding||channel2 in markDef$jscomp$0?positionOffset({channel:channel2,markDef:markDef$jscomp$0,encoding,model}):positionOffset({channel:baseChannel,markDef:markDef$jscomp$0,encoding,model}));
if(channelDef$jscomp$0||"x2"!==channel2&&"y2"!==channel2||!encoding.latitude&&!encoding.longitude){let {channel,channelDef,channel2Def,markDef,config,scaleName,scale,stack,offset,defaultRef}={channel:channel2,channelDef:channelDef$jscomp$0,channel2Def:encoding[channel2],markDef:markDef$jscomp$0,config:config$jscomp$0,scaleName:scaleName$jscomp$0,scale:scale$jscomp$0,stack:stack$jscomp$0,offset:baseChannel,defaultRef:void 0};channelDef$jscomp$0=isFieldOrDatumDef(channelDef)&&stack&&channel.charAt(0)===
stack.fieldChannel.charAt(0)?valueRefForFieldOrDatumDef(channelDef,scaleName,{suffix:"start"},{offset}):midPointRefWithPositionInvalidTest({channel,channelDef:channel2Def,scaleName,scale,stack,markDef,config,offset,defaultRef});channel2=void 0!==channelDef$jscomp$0?{[vgChannel]:channelDef$jscomp$0}:position2orSize(channel2,markDef$jscomp$0)||position2orSize(channel2,{[channel2]:getMarkStyleConfig(channel2,markDef$jscomp$0,config$jscomp$0.style),[sizeChannel]:getMarkStyleConfig(sizeChannel,markDef$jscomp$0,
config$jscomp$0.style)})||position2orSize(channel2,config$jscomp$0[mark])||position2orSize(channel2,config$jscomp$0.mark)||{[vgChannel]:pointPositionDefaultRef({model,defaultPos:defaultPos2,channel:channel2,scaleName:scaleName$jscomp$0,scale:scale$jscomp$0})()}}else sizeChannel=getSizeChannel(channel2),scaleName$jscomp$0=model.markDef[sizeChannel],channel2=null!=scaleName$jscomp$0?{[sizeChannel]:{value:scaleName$jscomp$0}}:{[vgChannel]:{field:model.getName(channel2)}}}_ref2=channel2[_ref2]?vgAlignedPositionChannel(channel$jscomp$0,
markDef$jscomp$1,config$jscomp$1):getVgPositionChannel(channel$jscomp$0);return Object.assign({},pointPosition(channel$jscomp$0,model,{defaultPos,vgChannel:_ref2}),channel2)}function position2orSize(channel,markDef){const sizeChannel=getSizeChannel(channel),vgChannel=getVgPositionChannel(channel);if(void 0!==markDef[vgChannel])return{[vgChannel]:widthHeightValueOrSignalRef(channel,markDef[vgChannel])};if(void 0!==markDef[channel])return{[vgChannel]:widthHeightValueOrSignalRef(channel,markDef[channel])};
if(markDef[sizeChannel])if(markDef=markDef[sizeChannel],isRelativeBandSize(markDef))warn("Position range does not support relative band size for ".concat(sizeChannel,"."));else return{[sizeChannel]:widthHeightValueOrSignalRef(channel,markDef)}}function rectPosition(model$jscomp$0,channel$jscomp$0){var _ref,_encoding$sizeChannel;const {config:config$jscomp$0,encoding:encoding$jscomp$0,markDef:markDef$jscomp$0}=model$jscomp$0;var mark=markDef$jscomp$0.type,channel2=getSecondaryRangeChannel(channel$jscomp$0),
sizeChannel=getSizeChannel(channel$jscomp$0),channelDef=encoding$jscomp$0[channel$jscomp$0];channel2=encoding$jscomp$0[channel2];var scale=model$jscomp$0.getScaleComponent(channel$jscomp$0);scale=scale?scale.get("type"):void 0;const orient=markDef$jscomp$0.orient,hasSizeDef=null!==(_ref=null!==(_encoding$sizeChannel=encoding$jscomp$0[sizeChannel])&&void 0!==_encoding$sizeChannel?_encoding$sizeChannel:encoding$jscomp$0.size)&&void 0!==_ref?_ref:getMarkPropOrConfig("size",markDef$jscomp$0,config$jscomp$0,
{vgChannel:sizeChannel});_ref="bar"===mark&&("x"===channel$jscomp$0?"vertical"===orient:"horizontal"===orient);if(!isFieldDef(channelDef)||!(isBinning(channelDef.bin)||isBinned(channelDef.bin)||channelDef.timeUnit&&!channel2)||hasSizeDef&&!isRelativeBandSize(hasSizeDef)||hasDiscreteDomain(scale)){if((isFieldOrDatumDef(channelDef)&&hasDiscreteDomain(scale)||_ref)&&!channel2){var JSCompiler_inline_result;{const {markDef,encoding,config,stack}=model$jscomp$0;mark=markDef.orient;var scaleName=model$jscomp$0.scaleName(channel$jscomp$0);
_ref=model$jscomp$0.getScaleComponent(channel$jscomp$0);var vgSizeChannel=getSizeChannel(channel$jscomp$0),channel2$jscomp$0=getSecondaryRangeChannel(channel$jscomp$0);_encoding$sizeChannel=getOffsetChannel(channel$jscomp$0);_encoding$sizeChannel=model$jscomp$0.scaleName(_encoding$sizeChannel);mark="horizontal"===mark&&"y"===channel$jscomp$0||"vertical"===mark&&"x"===channel$jscomp$0;if(encoding.size||markDef.size)mark?JSCompiler_inline_result=nonPosition("size",model$jscomp$0,{vgChannel:vgSizeChannel,
defaultRef:signalOrValueRef(markDef.size)}):warn('Cannot apply size to non-oriented mark "'.concat(markDef.type,'".'));mark=getBandSize({channel:channel$jscomp$0,fieldDef:channelDef,markDef,config,scaleType:null===_ref||void 0===_ref?void 0:_ref.get("type"),useVlSizeChannel:mark});JSCompiler_inline_result=JSCompiler_inline_result||{[vgSizeChannel]:defaultSizeRef(vgSizeChannel,_encoding$sizeChannel||scaleName,_ref,config,mark)};_encoding$sizeChannel="band"===(null===_ref||void 0===_ref?void 0:_ref.get("type"))&&
"band"in JSCompiler_inline_result[vgSizeChannel]?"top":"middle";_encoding$sizeChannel=vgAlignedPositionChannel(channel$jscomp$0,markDef,config,_encoding$sizeChannel);sizeChannel="xc"===_encoding$sizeChannel||"yc"===_encoding$sizeChannel;const {offset,offsetType}=positionOffset({channel:channel$jscomp$0,markDef,encoding,model:model$jscomp$0,bandPosition:sizeChannel?.5:0});model$jscomp$0=midPointRefWithPositionInvalidTest({channel:channel$jscomp$0,channelDef,markDef,config,scaleName,scale:_ref,stack,
offset,defaultRef:pointPositionDefaultRef({model:model$jscomp$0,defaultPos:"mid",channel:channel$jscomp$0,scaleName,scale:_ref}),bandPosition:sizeChannel?"encoding"===offsetType?0:.5:isSignalRef(mark)?{signal:"(1-".concat(mark,")/2")}:isRelativeBandSize(mark)?(1-mark.band)/2:0});vgSizeChannel?JSCompiler_inline_result=Object.assign({},{[_encoding$sizeChannel]:model$jscomp$0},JSCompiler_inline_result):(channel$jscomp$0=getVgPositionChannel(channel2$jscomp$0),JSCompiler_inline_result=JSCompiler_inline_result[vgSizeChannel],
JSCompiler_inline_result=offset?Object.assign({},JSCompiler_inline_result,{offset}):JSCompiler_inline_result,JSCompiler_inline_result={[_encoding$sizeChannel]:model$jscomp$0,[channel$jscomp$0]:vega.isArray(model$jscomp$0)?[model$jscomp$0[0],Object.assign({},model$jscomp$0[1],{offset:JSCompiler_inline_result})]:Object.assign({},model$jscomp$0,{offset:JSCompiler_inline_result})})}return JSCompiler_inline_result}return rangePosition(channel$jscomp$0,model$jscomp$0,{defaultPos:"zeroOrMax",defaultPos2:"zeroOrMin"})}a:{let {fieldDef,
fieldDef2,channel,model}={fieldDef:channelDef,fieldDef2:channel2,channel:channel$jscomp$0,model:model$jscomp$0};const {config,markDef,encoding}=model;model$jscomp$0=model.getScaleComponent(channel);JSCompiler_inline_result=model.scaleName(channel);channel$jscomp$0=model$jscomp$0?model$jscomp$0.get("type"):void 0;model$jscomp$0=model$jscomp$0.get("reverse");channel$jscomp$0=getBandSize({channel,fieldDef,markDef,config,scaleType:channel$jscomp$0});channelDef=null===(scaleName=model.component.axes[channel])||
void 0===scaleName?void 0:scaleName[0];channelDef=null!==(channel2$jscomp$0=null===channelDef||void 0===channelDef?void 0:channelDef.get("translate"))&&void 0!==channel2$jscomp$0?channel2$jscomp$0:.5;channel2$jscomp$0=isXorY(channel)?null!==(vgSizeChannel=getMarkPropOrConfig("binSpacing",markDef,config))&&void 0!==vgSizeChannel?vgSizeChannel:0:0;vgSizeChannel=getSecondaryRangeChannel(channel);scaleName=getVgPositionChannel(channel);_ref=getVgPositionChannel(vgSizeChannel);({offset:_encoding$sizeChannel}=
positionOffset({channel,markDef,encoding,model,bandPosition:0}));channel$jscomp$0=isSignalRef(channel$jscomp$0)?{signal:"(1-".concat(channel$jscomp$0.signal,")/2")}:isRelativeBandSize(channel$jscomp$0)?(1-channel$jscomp$0.band)/2:.5;if(isBinning(fieldDef.bin)||fieldDef.timeUnit)JSCompiler_inline_result={[_ref]:rectBinRef({fieldDef,scaleName:JSCompiler_inline_result,bandPosition:channel$jscomp$0,offset:getBinSpacing(vgSizeChannel,channel2$jscomp$0,model$jscomp$0,channelDef,_encoding$sizeChannel)}),
[scaleName]:rectBinRef({fieldDef,scaleName:JSCompiler_inline_result,bandPosition:isSignalRef(channel$jscomp$0)?{signal:"1-".concat(channel$jscomp$0.signal)}:1-channel$jscomp$0,offset:getBinSpacing(channel,channel2$jscomp$0,model$jscomp$0,channelDef,_encoding$sizeChannel)})};else{if(isBinned(fieldDef.bin)){channel$jscomp$0=valueRefForFieldOrDatumDef(fieldDef,JSCompiler_inline_result,{},{offset:getBinSpacing(vgSizeChannel,channel2$jscomp$0,model$jscomp$0,channelDef,_encoding$sizeChannel)});if(isFieldDef(fieldDef2)){JSCompiler_inline_result=
{[_ref]:channel$jscomp$0,[scaleName]:valueRefForFieldOrDatumDef(fieldDef2,JSCompiler_inline_result,{},{offset:getBinSpacing(channel,channel2$jscomp$0,model$jscomp$0,channelDef,_encoding$sizeChannel)})};break a}if(vega.isObject(fieldDef.bin)&&fieldDef.bin.step){JSCompiler_inline_result={[_ref]:channel$jscomp$0,[scaleName]:{signal:'scale("'.concat(JSCompiler_inline_result,'", ').concat(vgField(fieldDef,{expr:"datum"})," + ").concat(fieldDef.bin.step,")"),offset:getBinSpacing(channel,channel2$jscomp$0,
model$jscomp$0,channelDef,_encoding$sizeChannel)}};break a}}warn(channelRequiredForBinned(vgSizeChannel));JSCompiler_inline_result=void 0}}return JSCompiler_inline_result}function defaultSizeRef(sizeChannel,scaleName,scale,config,bandSize){if(isRelativeBandSize(bandSize))if(scale){const scaleType=scale.get("type");if("band"===scaleType)return{scale:scaleName,band:bandSize.band};1!==bandSize.band&&warn("Cannot use the relative band size with ".concat(scaleType," scale."))}else return{mult:bandSize.band,
field:{group:sizeChannel}};else{if(isSignalRef(bandSize))return bandSize;if(bandSize)return{value:bandSize}}return scale&&(scaleName=scale.get("range"),isVgRangeStep(scaleName)&&vega.isNumber(scaleName.step))?{value:scaleName.step-2}:{value:getViewConfigDiscreteStep(config.view,sizeChannel)-2}}function getBinSpacing(channel,spacing,reverse,translate,offset){if(channel in POLAR_POSITION_CHANNEL_INDEX)return 0;channel="x"===channel||"y2"===channel?-spacing/2:spacing/2;if(isSignalRef(reverse)||isSignalRef(offset)||
isSignalRef(translate))return reverse=signalOrStringValue(reverse),offset=signalOrStringValue(offset),translate=(translate=signalOrStringValue(translate))?"".concat(translate," + "):"",reverse=reverse?"(".concat(reverse," ? -1 : 1) * "):"",channel=offset?"(".concat(offset," + ").concat(channel,")"):channel,{signal:translate+reverse+channel};offset=offset||0;return translate+(reverse?-offset-channel:+offset+channel)}function rectBinRef(_ref3){let {fieldDef,scaleName,bandPosition,offset}=_ref3;return interpolatedSignalRef({scaleName,
fieldOrDatumDef:fieldDef,bandPosition,offset})}function baseEncodeEntry(model,ignore){const {fill,stroke}="include"===ignore.color?color$jscomp$0(model):{};var JSCompiler_temp_const=Object,JSCompiler_temp_const$jscomp$0=JSCompiler_temp_const.assign;ignore=markDefProperties(model.markDef,ignore);var JSCompiler_temp_const$jscomp$1=wrapAllFieldsInvalid(model,"fill",fill),JSCompiler_temp_const$jscomp$2=wrapAllFieldsInvalid(model,"stroke",stroke),JSCompiler_temp_const$jscomp$3=nonPosition("opacity",model),
JSCompiler_temp_const$jscomp$4=nonPosition("fillOpacity",model),JSCompiler_temp_const$jscomp$5=nonPosition("strokeOpacity",model),JSCompiler_temp_const$jscomp$6=nonPosition("strokeWidth",model),JSCompiler_temp_const$jscomp$7=nonPosition("strokeDash",model),JSCompiler_temp_const$jscomp$8=zindex(model),JSCompiler_temp_const$jscomp$9=tooltip(model),JSCompiler_temp_const$jscomp$10=text$1(model,"href");{const {markDef:markDef$jscomp$0,config:config$jscomp$0}=model,enableAria=getMarkPropOrConfig("aria",
markDef$jscomp$0,config$jscomp$0);if(!1===enableAria)model={};else{var JSCompiler_temp_const$jscomp$11=Object,JSCompiler_temp_const$jscomp$12=JSCompiler_temp_const$jscomp$11.assign;{const {mark,markDef,config}=model;if(!1===config.aria)var JSCompiler_inline_result={};else JSCompiler_inline_result=getMarkPropOrConfig("ariaRoleDescription",markDef,config),JSCompiler_inline_result=null!=JSCompiler_inline_result?{ariaRoleDescription:{value:JSCompiler_inline_result}}:mark in VG_MARK_INDEX?{}:{ariaRoleDescription:{value:mark}}}model=
JSCompiler_temp_const$jscomp$12.call(JSCompiler_temp_const$jscomp$11,{},enableAria?{aria:enableAria}:{},JSCompiler_inline_result,description(model))}}return JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const,{},ignore,JSCompiler_temp_const$jscomp$1,JSCompiler_temp_const$jscomp$2,JSCompiler_temp_const$jscomp$3,JSCompiler_temp_const$jscomp$4,JSCompiler_temp_const$jscomp$5,JSCompiler_temp_const$jscomp$6,JSCompiler_temp_const$jscomp$7,JSCompiler_temp_const$jscomp$8,JSCompiler_temp_const$jscomp$9,
JSCompiler_temp_const$jscomp$10,model)}function wrapAllFieldsInvalid(model,channel,valueRef){const {config,mark,markDef}=model;return"hide"===getMarkPropOrConfig("invalid",markDef,config)&&valueRef&&!isPathMark(mark)&&(model=allFieldsInvalidPredicate$1(model,{invalid:!0,channels:SCALE_CHANNELS}))?{[channel]:[{test:model,value:null},...vega.array(valueRef)]}:valueRef?{[channel]:valueRef}:{}}function markDefProperties(mark,ignore){return VG_MARK_CONFIGS.reduce((m,prop)=>{ALWAYS_IGNORE.has(prop)||void 0===
mark[prop]||"ignore"===ignore[prop]||(m[prop]=signalOrValueRef(mark[prop]));return m},{})}function allFieldsInvalidPredicate$1(model,_ref){let {invalid=!1,channels}=_ref;_ref=channels.reduce((aggregator,channel)=>{var scaleComponent=model.getScaleComponent(channel);scaleComponent&&(scaleComponent=scaleComponent.get("type"),(channel=model.vgField(channel,{expr:"datum"}))&&hasContinuousDomain(scaleComponent)&&(aggregator[channel]=!0));return aggregator},{});_ref=keys$jscomp$0(_ref);if(0<_ref.length){const op=
invalid?"||":"\x26\x26";return _ref.map(field=>fieldInvalidPredicate(field,invalid)).join(" ".concat(op," "))}}function defined(model){const {config,markDef}=model;return getMarkPropOrConfig("invalid",markDef,config)&&(model=allFieldsInvalidPredicate(model,{channels:POSITION_SCALE_CHANNELS}))?{defined:{signal:model}}:{}}function allFieldsInvalidPredicate(model,_ref){let {invalid=!1,channels}=_ref;_ref=channels.reduce((aggregator,channel)=>{var scaleComponent=model.getScaleComponent(channel);scaleComponent&&
(scaleComponent=scaleComponent.get("type"),(channel=model.vgField(channel,{expr:"datum"}))&&hasContinuousDomain(scaleComponent)&&(aggregator[channel]=!0));return aggregator},{});_ref=keys$jscomp$0(_ref);if(0<_ref.length){const op=invalid?"||":"\x26\x26";return _ref.map(field=>fieldInvalidPredicate(field,invalid)).join(" ".concat(op," "))}}function valueIfDefined(prop,value){if(void 0!==value)return{[prop]:signalOrValueRef(value)}}function onDelta$1(model,selCmpt,proj,size,signals){var _scaleCmpt$get,
_scaleCmpt$get2,name=selCmpt.name,anchor=name+"_translate_anchor";name+="_translate_delta";var channel=proj.channel;const hasScales=scaleBindings.defined(selCmpt);selCmpt=signals.filter(s=>s.name===proj.signals[hasScales?"data":"visual"])[0];size=model.getSizeSignalRef(size).signal;model=model.getScaleComponent(channel);signals=model.get("type");var reversed=model.get("reverse");reversed=hasScales?"x"===channel?reversed?"":"-":reversed?"-":"":"";anchor="".concat(anchor,".extent_").concat(channel);
channel="".concat(reversed).concat(name,".").concat(channel," / ").concat(hasScales?"".concat(size):"span(".concat(anchor,")"));reversed=hasScales?"log"===signals?"panLog":"symlog"===signals?"panSymlog":"pow"===signals?"panPow":"panLinear":"panLinear";const arg=hasScales?"pow"===signals?", ".concat(null!==(_scaleCmpt$get=model.get("exponent"))&&void 0!==_scaleCmpt$get?_scaleCmpt$get:1):"symlog"===signals?", ".concat(null!==(_scaleCmpt$get2=model.get("constant"))&&void 0!==_scaleCmpt$get2?_scaleCmpt$get2:
1):"":"";_scaleCmpt$get="".concat(reversed,"(").concat(anchor,", ").concat(channel).concat(arg,")");selCmpt.on.push({events:{signal:name},update:hasScales?_scaleCmpt$get:"clampRange(".concat(_scaleCmpt$get,", 0, ").concat(size,")")})}function onDelta(model,selCmpt,proj,size,signals){var _scaleCmpt$get,_scaleCmpt$get2,name=selCmpt.name,channel=proj.channel;const hasScales=scaleBindings.defined(selCmpt);selCmpt=signals.filter(s=>s.name===proj.signals[hasScales?"data":"visual"])[0];size=model.getSizeSignalRef(size).signal;
signals=model.getScaleComponent(channel);const scaleType=signals.get("type"),base=hasScales?domain$jscomp$0(model,channel):selCmpt.name;model=name+"_zoom_delta";name="".concat(name).concat("_zoom_anchor",".").concat(channel);channel=hasScales?"log"===scaleType?"zoomLog":"symlog"===scaleType?"zoomSymlog":"pow"===scaleType?"zoomPow":"zoomLinear":"zoomLinear";const arg=hasScales?"pow"===scaleType?", ".concat(null!==(_scaleCmpt$get=signals.get("exponent"))&&void 0!==_scaleCmpt$get?_scaleCmpt$get:1):"symlog"===
scaleType?", ".concat(null!==(_scaleCmpt$get2=signals.get("constant"))&&void 0!==_scaleCmpt$get2?_scaleCmpt$get2:1):"":"";_scaleCmpt$get="".concat(channel,"(").concat(base,", ").concat(name,", ").concat(model).concat(arg,")");selCmpt.on.push({events:{signal:model},update:hasScales?_scaleCmpt$get:"clampRange(".concat(_scaleCmpt$get,", 0, ").concat(size,")")})}function unitName(model){var {escape}=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{escape:!0};escape=escape?vega.stringValue(model.name):
model.name;var JSCompiler_inline_result;for(JSCompiler_inline_result=model.parent;JSCompiler_inline_result&&!isFacetModel(JSCompiler_inline_result);)JSCompiler_inline_result=JSCompiler_inline_result.parent;if(JSCompiler_inline_result){const {facet}=JSCompiler_inline_result;for(const channel of FACET_CHANNELS)facet[channel]&&(escape+=" + '__facet_".concat(channel,"_' + (facet[").concat(vega.stringValue(JSCompiler_inline_result.vgField(channel)),"])"))}return escape}function requiresSelectionId(model){var _model$component$sele;
return vals$jscomp$0(null!==(_model$component$sele=model.component.selection)&&void 0!==_model$component$sele?_model$component$sele:{}).reduce((identifier,selCmpt)=>identifier||selCmpt.project.items.some(proj=>"_vgsid_"===proj.field),!1)}function disableDirectManipulation(selCmpt,selDef){!vega.isString(selDef.select)&&selDef.select.on||delete selCmpt.events;!vega.isString(selDef.select)&&selDef.select.clear||delete selCmpt.clear;!vega.isString(selDef.select)&&selDef.select.toggle||delete selCmpt.toggle}
function getName(node){const name=[];if("Identifier"===node.type)return[node.name];if("Literal"===node.type)return[node.value];"MemberExpression"===node.type&&(name.push(...getName(node.object)),name.push(...getName(node.property)));return name}function startsWithDatum(node){return"MemberExpression"===node.object.type?startsWithDatum(node.object):"datum"===node.object.name}function getDependentFields(expression){expression=vega.parseExpression(expression);const dependents=new Set;expression.visit(node=>
{"MemberExpression"===node.type&&startsWithDatum(node)&&dependents.add(getName(node).slice(1).join("."))});return dependents}function parseSelectionPredicate(model,pred,dfnode){var datum=3<arguments.length&&void 0!==arguments[3]?arguments[3]:"datum",name=vega.isString(pred)?pred:pred.param,vname=varName(name),store=vega.stringValue(vname+"_store");let selCmpt;try{selCmpt=model.getSelectionComponent(vname,name)}catch(e){return"!!".concat(vname)}selCmpt.project.timeUnit&&(name=null!==dfnode&&void 0!==
dfnode?dfnode:model.component.data.raw,vname=selCmpt.project.timeUnit.clone(),name.parent?vname.insertAsParentOf(name):name.parent=vname);datum="vlSelectionTest(".concat(store,", ").concat(datum).concat("global"===selCmpt.resolve?")":", ".concat(vega.stringValue(selCmpt.resolve),")"));store="length(data(".concat(store,"))");return!1===pred.empty?"".concat(store," \x26\x26 ").concat(datum):"!".concat(store," || ").concat(datum)}function parseSelectionExtent(model,name,extent){const vname=varName(name),
encoding=extent.encoding;let field=extent.field,selCmpt;try{selCmpt=model.getSelectionComponent(vname,name)}catch(e){return vname}encoding||field?encoding&&!field&&(model=selCmpt.project.items.filter(p=>p.channel===encoding),!model.length||1<model.length?(field=selCmpt.project.items[0].field,warn((model.length?"Multiple ":"No ")+"matching ".concat(vega.stringValue(encoding)," encoding found for selection ").concat(vega.stringValue(extent.param),". ")+'Using "field": '.concat(vega.stringValue(field),
"."))):field=model[0].field):(field=selCmpt.project.items[0].field,1<selCmpt.project.items.length&&warn('A "field" or "encoding" must be specified when using a selection as a scale domain. '+'Using "field": '.concat(vega.stringValue(field),".")));return"".concat(selCmpt.name,"[").concat(vega.stringValue(replacePathInField(field)),"]")}function expression$jscomp$0(model,filterOp,node){return logicalExpr(filterOp,predicate=>vega.isString(predicate)?predicate:(null===predicate||void 0===predicate?0:
predicate.param)?parseSelectionPredicate(model,predicate,node):fieldFilterExpression(predicate))}function assembleTitle(title,config){if(title)return vega.isArray(title)&&!isText(title)?title.map(fieldDef=>titleFormatter(fieldDef,config)).join(", "):title}function setAxisEncode(axis,part,vgProp,vgRef){var _axis$encode,_axis$encode2,_axis$encode2$part,_axis$encode$part,_axis$encode$part$upd;null!==(_axis$encode=axis.encode)&&void 0!==_axis$encode?_axis$encode:axis.encode={};null!==(_axis$encode2$part=
(_axis$encode2=axis.encode)[part])&&void 0!==_axis$encode2$part?_axis$encode2$part:_axis$encode2[part]={};null!==(_axis$encode$part$upd=(_axis$encode$part=axis.encode[part]).update)&&void 0!==_axis$encode$part$upd?_axis$encode$part$upd:_axis$encode$part.update={};axis.encode[part].update[vgProp]=vgRef}function assembleAxis(axisCmpt,kind,config){var opt=3<arguments.length&&void 0!==arguments[3]?arguments[3]:{header:!1},$jscomp$destructuring$var111=axisCmpt.combine(),$jscomp$destructuring$var112=Object.assign({},
$jscomp$destructuring$var111),disable=$jscomp$destructuring$var111.disable;const orient=$jscomp$destructuring$var111.orient,scale=$jscomp$destructuring$var111.scale;var labelExpr=$jscomp$destructuring$var111.labelExpr;const title=$jscomp$destructuring$var111.title;$jscomp$destructuring$var111=$jscomp$destructuring$var111.zindex;$jscomp$destructuring$var112=(delete $jscomp$destructuring$var112.disable,delete $jscomp$destructuring$var112.orient,delete $jscomp$destructuring$var112.scale,delete $jscomp$destructuring$var112.labelExpr,
delete $jscomp$destructuring$var112.title,delete $jscomp$destructuring$var112.zindex,$jscomp$destructuring$var112);if(!disable){for(const prop in $jscomp$destructuring$var112){var propType=AXIS_PROPERTY_TYPE[prop];disable=$jscomp$destructuring$var112[prop];if(propType&&propType!==kind&&"both"!==propType)delete $jscomp$destructuring$var112[prop];else if(isConditionalAxisValue(disable)){propType=disable;disable=Object.assign({},propType);propType=propType.condition;disable=(delete disable.condition,
disable);propType=vega.array(propType);const propIndex=CONDITIONAL_AXIS_PROP_INDEX[prop];if(propIndex){const {vgProp,part}=propIndex;disable=[...propType.map(c=>{var $jscomp$destructuring$var116=Object.assign({},c);c=c.test;$jscomp$destructuring$var116=(delete $jscomp$destructuring$var116.test,$jscomp$destructuring$var116);return Object.assign({},{test:expression$jscomp$0(null,c)},$jscomp$destructuring$var116)}),disable];setAxisEncode($jscomp$destructuring$var112,part,vgProp,disable);delete $jscomp$destructuring$var112[prop]}else null===
propIndex&&(disable={signal:propType.map(c=>{var $jscomp$destructuring$var118=Object.assign({},c);c=c.test;$jscomp$destructuring$var118=(delete $jscomp$destructuring$var118.test,$jscomp$destructuring$var118);return"".concat(expression$jscomp$0(null,c)," ? ").concat(exprFromValueRefOrSignalRef($jscomp$destructuring$var118)," : ")}).join("")+exprFromValueRefOrSignalRef(disable)},$jscomp$destructuring$var112[prop]=disable)}else if(isSignalRef(disable)&&(propType=CONDITIONAL_AXIS_PROP_INDEX[prop])){const {vgProp,
part}=propType;setAxisEncode($jscomp$destructuring$var112,part,vgProp,disable);delete $jscomp$destructuring$var112[prop]}contains(["labelAlign","labelBaseline"],prop)&&null===$jscomp$destructuring$var112[prop]&&delete $jscomp$destructuring$var112[prop]}if("grid"===kind){if($jscomp$destructuring$var112.grid)return $jscomp$destructuring$var112.encode&&({grid:labelExpr}=$jscomp$destructuring$var112.encode,$jscomp$destructuring$var112.encode=Object.assign({},labelExpr?{grid:labelExpr}:{}),isEmpty($jscomp$destructuring$var112.encode)&&
delete $jscomp$destructuring$var112.encode),Object.assign({},{scale,orient},$jscomp$destructuring$var112,{domain:!1,labels:!1,aria:!1,maxExtent:0,minExtent:0,ticks:!1,zindex:getFirstDefined($jscomp$destructuring$var111,0)})}else if(opt.header||!axisCmpt.mainExtracted){if(void 0!==labelExpr){var _axis$encode3,_axis$encode3$labels;opt=labelExpr;null!==(_axis$encode3=$jscomp$destructuring$var112.encode)&&void 0!==_axis$encode3&&null!==(_axis$encode3$labels=_axis$encode3.labels)&&void 0!==_axis$encode3$labels&&
_axis$encode3$labels.update&&isSignalRef($jscomp$destructuring$var112.encode.labels.update.text)&&(opt=replaceAll(labelExpr,"datum.label",$jscomp$destructuring$var112.encode.labels.update.text.signal));setAxisEncode($jscomp$destructuring$var112,"labels","text",{signal:opt})}null===$jscomp$destructuring$var112.labelAlign&&delete $jscomp$destructuring$var112.labelAlign;if($jscomp$destructuring$var112.encode){for(const part of AXIS_PARTS)axisCmpt.hasAxisPart(part)||delete $jscomp$destructuring$var112.encode[part];
isEmpty($jscomp$destructuring$var112.encode)&&delete $jscomp$destructuring$var112.encode}labelExpr=assembleTitle(title,config);return Object.assign({},{scale,orient,grid:!1},labelExpr?{title:labelExpr}:{},$jscomp$destructuring$var112,!1===config.aria?{aria:!1}:{},{zindex:getFirstDefined($jscomp$destructuring$var111,0)})}}}function assembleAxisSignals(model){const {axes}=model.component,signals=[];for(const channel of POSITION_SCALE_CHANNELS)if(axes[channel])for(const axis of axes[channel])if(!axis.get("disable")&&
!axis.get("gridScale")){const sizeType="x"===channel?"height":"width",update=model.getSizeSignalRef(sizeType).signal;sizeType!==update&&signals.push({name:sizeType,update})}return signals}function assembleAxes(axisComponents,config){const {x=[],y=[]}=axisComponents;return[...x.map(a=>assembleAxis(a,"grid",config)),...y.map(a=>assembleAxis(a,"grid",config)),...x.map(a=>assembleAxis(a,"main",config)),...y.map(a=>assembleAxis(a,"main",config))].filter(a=>a)}function getAxisConfigFromConfigTypes(configTypes,
config,channel,orient){return Object.assign.apply(null,[{},...configTypes.map(configType=>{if("axisOrient"===configType){configType="x"===channel?"bottom":"left";const orientConfig1=config["x"===channel?"axisBottom":"axisLeft"]||{},orientConfig2=config["x"===channel?"axisTop":"axisRight"]||{},props=new Set([...keys$jscomp$0(orientConfig1),...keys$jscomp$0(orientConfig2)]),conditionalOrientAxisConfig={};for(const prop of props.values())conditionalOrientAxisConfig[prop]={signal:"".concat(orient.signal,
' \x3d\x3d\x3d "').concat(configType,'" ? ').concat(signalOrStringValue(orientConfig1[prop])," : ").concat(signalOrStringValue(orientConfig2[prop]))};return conditionalOrientAxisConfig}return config[configType]})])}function getAxisConfigs(channel,scaleType,orient,config){var typeBasedConfigTypes="band"===scaleType?["axisDiscrete","axisBand"]:"point"===scaleType?["axisDiscrete","axisPoint"]:QUANTITATIVE_SCALES.has(scaleType)?["axisQuantitative"]:"time"===scaleType||"utc"===scaleType?["axisTemporal"]:
[];const axisChannel="x"===channel?"axisX":"axisY";scaleType=isSignalRef(orient)?"axisOrient":"axis".concat(titleCase(orient));typeBasedConfigTypes=[...typeBasedConfigTypes,...typeBasedConfigTypes.map(c=>axisChannel+c.substr(4))];scaleType=["axis",scaleType,axisChannel];return{vlOnlyAxisConfig:getAxisConfigFromConfigTypes(typeBasedConfigTypes,config,channel,orient),vgAxisConfig:getAxisConfigFromConfigTypes(scaleType,config,channel,orient),axisConfigStyle:getAxisConfigStyle([...scaleType,...typeBasedConfigTypes],
config)}}function getAxisConfigStyle(axisConfigTypes,config){const toMerge=[{}];for(const configType of axisConfigTypes){var _config$configType;if(axisConfigTypes=null===(_config$configType=config[configType])||void 0===_config$configType?void 0:_config$configType.style){axisConfigTypes=vega.array(axisConfigTypes);for(const s of axisConfigTypes)toMerge.push(config.style[s])}}return Object.assign.apply(null,toMerge)}function getAxisConfig(property,styleConfigIndex,style){let axisConfigs=3<arguments.length&&
void 0!==arguments[3]?arguments[3]:{};const styleConfig=getStyleConfig(property,style,styleConfigIndex);if(void 0!==styleConfig)return{configFrom:"style",configValue:styleConfig};for(const configFrom of["vlOnlyAxisConfig","vgAxisConfig","axisConfigStyle"]){var _axisConfigs$configFr;if(void 0!==(null===(_axisConfigs$configFr=axisConfigs[configFrom])||void 0===_axisConfigs$configFr?void 0:_axisConfigs$configFr[property]))return{configFrom,configValue:axisConfigs[configFrom][property]}}return{}}function getLabelAngle(fieldOrDatumDef,
axis,channel,styleConfig,axisConfigs){const labelAngle=null===axis||void 0===axis?void 0:axis.labelAngle;if(void 0!==labelAngle)return isSignalRef(labelAngle)?labelAngle:normalizeAngle(labelAngle);({configValue:axis}=getAxisConfig("labelAngle",styleConfig,null===axis||void 0===axis?void 0:axis.style,axisConfigs));if(void 0!==axis)return normalizeAngle(axis);if("x"===channel&&contains(["nominal","ordinal"],fieldOrDatumDef.type)&&(!isFieldDef(fieldOrDatumDef)||!fieldOrDatumDef.timeUnit))return 270}
function normalizeAngleExpr(angle){return"(((".concat(angle.signal," % 360) + 360) % 360)")}function defaultLabelBaseline(angle,orient,channel,alwaysIncludeMiddle){if(void 0!==angle)return"x"===channel?isSignalRef(angle)?(alwaysIncludeMiddle=normalizeAngleExpr(angle),orient=isSignalRef(orient)?"(".concat(orient.signal,' \x3d\x3d\x3d "top")'):"top"===orient,{signal:"(45 \x3c ".concat(alwaysIncludeMiddle," \x26\x26 ").concat(alwaysIncludeMiddle," \x3c 135) || (225 \x3c ").concat(alwaysIncludeMiddle,
" \x26\x26 ").concat(alwaysIncludeMiddle,' \x3c 315) ? "middle" :')+"(".concat(alwaysIncludeMiddle," \x3c\x3d 45 || 315 \x3c\x3d ").concat(alwaysIncludeMiddle,") \x3d\x3d\x3d ").concat(orient,' ? "bottom" : "top"')}):45<angle&&135>angle||225<angle&&315>angle?"middle":isSignalRef(orient)?(alwaysIncludeMiddle=45>=angle||315<=angle?"\x3d\x3d\x3d":"!\x3d\x3d",{signal:"".concat(orient.signal," ").concat(alwaysIncludeMiddle,' "top" ? "bottom" : "top"')}):(45>=angle||315<=angle)===("top"===orient)?"bottom":
"top":isSignalRef(angle)?(angle=normalizeAngleExpr(angle),orient=isSignalRef(orient)?"(".concat(orient.signal,' \x3d\x3d\x3d "left")'):"left"===orient,alwaysIncludeMiddle=alwaysIncludeMiddle?'"middle"':"null",{signal:"".concat(angle," \x3c\x3d 45 || 315 \x3c\x3d ").concat(angle," || (135 \x3c\x3d ").concat(angle," \x26\x26 ").concat(angle," \x3c\x3d 225) ? ").concat(alwaysIncludeMiddle," : (45 \x3c\x3d ").concat(angle," \x26\x26 ").concat(angle," \x3c\x3d 135) \x3d\x3d\x3d ").concat(orient,' ? "top" : "bottom"')}):
45>=angle||315<=angle||135<=angle&&225>=angle?alwaysIncludeMiddle?"middle":null:isSignalRef(orient)?(alwaysIncludeMiddle=45<=angle&&135>=angle?"\x3d\x3d\x3d":"!\x3d\x3d",{signal:"".concat(orient.signal," ").concat(alwaysIncludeMiddle,' "left" ? "top" : "bottom"')}):(45<=angle&&135>=angle)===("left"===orient)?"top":"bottom"}function defaultLabelAlign(angle,orient,channel){if(void 0!==angle){var startAngle=(channel="x"===channel)?0:90,mainOrient=channel?"bottom":"left";return isSignalRef(angle)?(angle=
normalizeAngleExpr(angle),orient=isSignalRef(orient)?"(".concat(orient.signal,' \x3d\x3d\x3d "').concat(mainOrient,'")'):orient===mainOrient,{signal:"(".concat(startAngle?"(".concat(angle," + 90)"):angle," % 180 \x3d\x3d\x3d 0) ? ").concat(channel?null:'"center"'," :")+"(".concat(startAngle," \x3c ").concat(angle," \x26\x26 ").concat(angle," \x3c ").concat(180+startAngle,") \x3d\x3d\x3d ").concat(orient,' ? "left" : "right"')}):0===(angle+startAngle)%180?channel?null:"center":isSignalRef(orient)?
(channel=startAngle<angle&&angle<180+startAngle?"\x3d\x3d\x3d":"!\x3d\x3d",orient="".concat(orient.signal," ").concat(channel,' "').concat(mainOrient,'"'),{signal:"".concat(orient,' ? "left" : "right"')}):(startAngle<angle&&angle<180+startAngle)===(orient===mainOrient)?"left":"right"}}function getFieldDefTitle(model,channel){var channel2="x"===channel?"x2":"y2";channel=model.fieldDef(channel);model=model.fieldDef(channel2);channel2=channel?channel.title:void 0;model=model?model.title:void 0;if(channel2&&
model)return mergeTitle(channel2,model);if(channel2)return channel2;if(model)return model;if(void 0!==channel2)return channel2;if(void 0!==model)return model}function sortArrayIndexField(fieldDef,channel,opt){return vgField(fieldDef,Object.assign({},{prefix:channel,suffix:"sort_index"},null!==opt&&void 0!==opt?opt:{}))}function getHeaderChannel(channel,orient){return contains(["top","bottom"],orient)?"column":contains(["left","right"],orient)?"row":"row"===channel?"row":"column"}function getHeaderProperty(prop,
header,config,channel){return getFirstDefined((header||{})[prop],("row"===channel?config.headerRow:"column"===channel?config.headerColumn:config.headerFacet)[prop],config.header[prop])}function getHeaderProperties(properties,header,config,channel){const props={};for(const prop of properties)properties=getHeaderProperty(prop,header||{},config,channel),void 0!==properties&&(props[prop]=properties);return props}function defaultHeaderGuideAlign(headerChannel,angle){switch(2<arguments.length&&void 0!==
arguments[2]?arguments[2]:"middle"){case "start":return{align:"left"};case "end":return{align:"right"}}const align=defaultLabelAlign(angle,"row"===headerChannel?"left":"top","row"===headerChannel?"y":"x");return align?{align}:{}}function defaultHeaderGuideBaseline(angle,channel){return(angle=defaultLabelBaseline(angle,"row"===channel?"left":"top","row"===channel?"y":"x",!0))?{baseline:angle}:{}}function assembleLabelTitle(facetFieldDef,channel,config){const {format,formatType,labelAngle,labelAnchor,
labelOrient,labelExpr}=getHeaderProperties("format formatType labelAngle labelAnchor labelOrient labelExpr".split(" "),facetFieldDef.header,config,channel),titleTextExpr=formatSignalRef({fieldOrDatumDef:facetFieldDef,format,formatType,expr:"parent",config}).signal,headerChannel=getHeaderChannel(channel,labelOrient);return Object.assign({},{text:{signal:labelExpr?replaceAll(replaceAll(labelExpr,"datum.label",titleTextExpr),"datum.value",vgField(facetFieldDef,{expr:"parent"})):titleTextExpr}},"row"===
channel?{orient:"left"}:{},{style:"guide-label",frame:"group"},defaultHeaderGuideBaseline(labelAngle,headerChannel),defaultHeaderGuideAlign(headerChannel,labelAngle,labelAnchor),assembleHeaderProperties(config,facetFieldDef,channel,HEADER_LABEL_PROPERTIES,HEADER_LABEL_PROPERTIES_MAP))}function assembleHeaderProperties(config,facetFieldDef,channel,properties,propertiesMap){const props={};for(const prop of properties)propertiesMap[prop]&&(properties=getHeaderProperty(prop,null===facetFieldDef||void 0===
facetFieldDef?void 0:facetFieldDef.header,config,channel),void 0!==properties&&(props[propertiesMap[prop]]=properties));return props}function assembleLayoutSignals(model){return[...sizeSignals(model,"width"),...sizeSignals(model,"height"),...sizeSignals(model,"childWidth"),...sizeSignals(model,"childHeight")]}function sizeSignals(model,sizeType){var channel="width"===sizeType?"x":"y",size=model.component.layoutSize.get(sizeType);if(!size||"merged"===size)return[];sizeType=model.getSizeSignalRef(sizeType).signal;
if("step"===size){if(size=model.getScaleComponent(channel)){var type=size.get("type");const range=size.get("range");if(hasDiscreteDomain(type)&&isVgRangeStep(range))return type=model.scaleName(channel),isFacetModel(model.parent)&&"independent"===model.parent.component.resolve.scale[channel]?[stepSignal(type,range)]:[stepSignal(type,range),{name:sizeType,update:sizeExpr(type,size,"domain('".concat(type,"').length"))}]}throw Error("layout size is step although width/height is not step.");}return"container"==
size?(channel=(size=sizeType.endsWith("width"))?"containerSize()[0]":"containerSize()[1]",model=getViewConfigContinuousSize(model.config.view,size?"width":"height"),model="isFinite(".concat(channel,") ? ").concat(channel," : ").concat(model),[{name:sizeType,init:model,on:[{update:model,events:"window:resize"}]}]):[{name:sizeType,value:size}]}function stepSignal(scaleName,range){scaleName="".concat(scaleName,"_step");return isSignalRef(range.step)?{name:scaleName,update:range.step.signal}:{name:scaleName,
value:range.step}}function sizeExpr(scaleName,scaleComponent,cardinality){const type=scaleComponent.get("type"),padding=scaleComponent.get("padding"),paddingOuter=getFirstDefined(scaleComponent.get("paddingOuter"),padding);scaleComponent=scaleComponent.get("paddingInner");scaleComponent="band"===type?void 0!==scaleComponent?scaleComponent:padding:1;return"bandspace(".concat(cardinality,", ").concat(signalOrStringValue(scaleComponent),", ").concat(signalOrStringValue(paddingOuter),") * ").concat(scaleName,
"_step")}function getSizeTypeFromLayoutSizeType(layoutSizeType){return"childWidth"===layoutSizeType?"width":"childHeight"===layoutSizeType?"height":layoutSizeType}function guideEncodeEntry(encoding,model){return keys$jscomp$0(encoding).reduce((encode,channel)=>Object.assign({},encode,wrapCondition(model,encoding[channel],channel,def=>signalOrValueRef(def.value))),{})}function defaultScaleResolve(channel,model){if(isFacetModel(model))return"theta"===channel?"independent":"shared";if(isLayerModel(model))return"shared";
if(isConcatModel(model))return isXorY(channel)||"theta"===channel||"radius"===channel?"independent":"shared";throw Error("invalid model type for resolve");}function parseGuideResolve(resolve,channel){const channelScaleResolve=resolve.scale[channel],guide=isXorY(channel)?"axis":"legend";return"independent"===channelScaleResolve?("shared"===resolve[guide][channel]&&warn('Setting the scale to be independent for "'.concat(channel,'" means we also have to set the guide (axis or legend) to be independent.')),
"independent"):resolve[guide][channel]||"shared"}function getMaxValue(channelDef){return getConditionValue(channelDef,(v,conditionalDef)=>Math.max(v,conditionalDef.value))}function getFirstConditionValue(channelDef){return getConditionValue(channelDef,(v,conditionalDef)=>getFirstDefined(v,conditionalDef.value))}function getConditionValue(channelDef,reducer){const condition=channelDef&&channelDef.condition;if(condition&&(vega.isArray(condition)||isValueDef(condition)))return vega.array(channelDef.condition).reduce(reducer,
channelDef.value);if(isValueDef(channelDef))return channelDef.value}function selectedCondition(model,legendCmpt,fieldDef){model=legendCmpt.get("selections");if(null!==model&&void 0!==model&&model.length){var field=vega.stringValue(fieldDef.field);return model.map(name=>{const store=vega.stringValue(varName(name)+"_store");return"(!length(data(".concat(store,")) || (").concat(name,"[").concat(field,"] \x26\x26 indexof(").concat(name,"[").concat(field,"], datum.value) \x3e\x3d 0))")}).join(" || ")}}
function gradientLengthSignal(model,sizeType,min,max){model=model.getSizeSignalRef(sizeType).signal;return{signal:"clamp(".concat(model,", ").concat(min,", ").concat(max,")")}}function parseLegend(model$jscomp$0){var JSCompiler_temp;if(isUnitModel(model$jscomp$0)){var {encoding:encoding$jscomp$0}=model$jscomp$0,legendComponent={};for(const channel$jscomp$0 of["color",...LEGEND_SCALE_CHANNELS]){var def=getFieldOrDatumDef(encoding$jscomp$0[channel$jscomp$0]);if(def&&model$jscomp$0.getScaleComponent(channel$jscomp$0)&&
("shape"!==channel$jscomp$0||!isFieldDef(def)||"geojson"!==def.type)){a:{var _legend$direction=def=void 0,_ref13=void 0,_model$fieldDef=void 0,_legend=void 0,_legend$encoding=void 0;var JSCompiler_inline_result=void 0;var model=model$jscomp$0,channel$jscomp$1=channel$jscomp$0;let legend=model.legend(channel$jscomp$1);const {markDef,encoding,config}=model;var legendConfig$jscomp$0=config.legend;b:{var JSCompiler_inline_result$jscomp$0=model;var channel$jscomp$2=channel$jscomp$1,scale=JSCompiler_inline_result$jscomp$0.scaleName(channel$jscomp$2);
if("trail"===JSCompiler_inline_result$jscomp$0.mark){if("color"===channel$jscomp$2){JSCompiler_inline_result$jscomp$0={stroke:scale};break b}if("size"===channel$jscomp$2){JSCompiler_inline_result$jscomp$0={strokeWidth:scale};break b}}JSCompiler_inline_result$jscomp$0="color"===channel$jscomp$2?JSCompiler_inline_result$jscomp$0.markDef.filled?{fill:scale}:{stroke:scale}:{[channel$jscomp$2]:scale}}JSCompiler_inline_result$jscomp$0=new LegendComponent({},JSCompiler_inline_result$jscomp$0);channel$jscomp$2=
null===(_model$fieldDef=model.fieldDef(channel$jscomp$1))||void 0===_model$fieldDef?void 0:_model$fieldDef.field;for(const selCmpt of vals$jscomp$0(null!==(JSCompiler_temp=model.component.selection)&&void 0!==JSCompiler_temp?JSCompiler_temp:{})){var _selCmpt$project$hasF;if((_model$fieldDef=null!==(_selCmpt$project$hasF=selCmpt.project.hasField[channel$jscomp$2])&&void 0!==_selCmpt$project$hasF?_selCmpt$project$hasF:selCmpt.project.hasChannel[channel$jscomp$1])&&legendBindings.defined(selCmpt)){var _legendCmpt$get;
scale=null!==(_legendCmpt$get=JSCompiler_inline_result$jscomp$0.get("selections"))&&void 0!==_legendCmpt$get?_legendCmpt$get:[];scale.push(selCmpt.name);JSCompiler_inline_result$jscomp$0.set("selections",scale,!1);_model$fieldDef.hasLegend=!0}}_model$fieldDef=void 0!==legend?!legend:legendConfig$jscomp$0.disable;JSCompiler_inline_result$jscomp$0.set("disable",_model$fieldDef,void 0!==legend);if(_model$fieldDef){def=JSCompiler_inline_result$jscomp$0;break a}legend=legend||{};channel$jscomp$2=model.getScaleComponent(channel$jscomp$1).get("type");
_model$fieldDef=getFieldOrDatumDef(encoding[channel$jscomp$1]);var timeUnit$jscomp$0=isFieldDef(_model$fieldDef)?null===(JSCompiler_inline_result=normalizeTimeUnit(_model$fieldDef.timeUnit))||void 0===JSCompiler_inline_result?void 0:JSCompiler_inline_result.unit:void 0;scale=legend.orient||config.legend.orient||"right";JSCompiler_inline_result={legend,channel:channel$jscomp$1,timeUnit:timeUnit$jscomp$0,scaleType:channel$jscomp$2};({legend:timeUnit$jscomp$0}=JSCompiler_inline_result);timeUnit$jscomp$0=
timeUnit$jscomp$0.type;b:{let {channel,timeUnit,scaleType}=JSCompiler_inline_result;if(isColorChannel(channel)){if(contains(["quarter","month","day"],timeUnit)){JSCompiler_inline_result="symbol";break b}if(CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)){JSCompiler_inline_result="gradient";break b}}JSCompiler_inline_result="symbol"}JSCompiler_inline_result=getFirstDefined(timeUnit$jscomp$0,JSCompiler_inline_result);let {legendConfig,legendType,orient,legend:legend$jscomp$0}={legend,legendType:JSCompiler_inline_result,
orient:scale,legendConfig:legendConfig$jscomp$0};if(null!==(_ref13=null!==(_legend$direction=legend$jscomp$0.direction)&&void 0!==_legend$direction?_legend$direction:legendConfig[legendType?"gradientDirection":"symbolDirection"])&&void 0!==_ref13)_legend$direction=_ref13;else b:{switch(orient){case "top":case "bottom":_legend$direction="horizontal";break b;case "left":case "right":case "none":case void 0:break;default:_legend$direction="gradient"===legendType?"horizontal":void 0;break b}_legend$direction=
void 0}legendConfig$jscomp$0={legend,channel:channel$jscomp$1,model,markDef,encoding,fieldOrDatumDef:_model$fieldDef,legendConfig:legendConfig$jscomp$0,config,scaleType:channel$jscomp$2,orient:scale,legendType:JSCompiler_inline_result,direction:_legend$direction};for(const property of LEGEND_COMPONENT_PROPERTIES)if(!("gradient"===JSCompiler_inline_result&&property.startsWith("symbol")||"symbol"===JSCompiler_inline_result&&property.startsWith("gradient"))&&(_legend$direction=property in legendRules?
legendRules[property](legendConfig$jscomp$0):legend[property],void 0!==_legend$direction)){b:{_ref13=model.fieldDef(channel$jscomp$1);switch(property){case "disable":_ref13=void 0!==legend;break b;case "values":_ref13=!(null===legend||void 0===legend||!legend.values);break b;case "title":if("title"===property&&_legend$direction===(null===_ref13||void 0===_ref13?void 0:_ref13.title)){_ref13=!0;break b}}_ref13=_legend$direction===(legend||{})[property]}(_ref13||void 0===config.legend[property])&&JSCompiler_inline_result$jscomp$0.set(property,
_legend$direction,_ref13)}legendConfig$jscomp$0=null!==(_legend$encoding=null===(_legend=legend)||void 0===_legend?void 0:_legend.encoding)&&void 0!==_legend$encoding?_legend$encoding:{};_legend=JSCompiler_inline_result$jscomp$0.get("selections");_legend$encoding={};channel$jscomp$1={fieldOrDatumDef:_model$fieldDef,model,channel:channel$jscomp$1,legendCmpt:JSCompiler_inline_result$jscomp$0,legendType:JSCompiler_inline_result};for(const part of"labels legend title symbols gradient entries".split(" ")){var _legendEncoding$part;
_legend$direction=guideEncodeEntry(null!==(_legendEncoding$part=legendConfig$jscomp$0[part])&&void 0!==_legendEncoding$part?_legendEncoding$part:{},model);_legend$direction=part in legendEncodeRules?legendEncodeRules[part](_legend$direction,channel$jscomp$1):_legend$direction;void 0===_legend$direction||isEmpty(_legend$direction)||(_legend$encoding[part]=Object.assign({},null!==_legend&&void 0!==_legend&&_legend.length&&isFieldDef(_model$fieldDef)?{name:"".concat(varName(_model$fieldDef.field),"_legend_").concat(part)}:
{},null!==_legend&&void 0!==_legend&&_legend.length?{interactive:!!_legend}:{},{update:_legend$direction}))}isEmpty(_legend$encoding)||JSCompiler_inline_result$jscomp$0.set("encode",_legend$encoding,!(null===(def=legend)||void 0===def||!def.encoding));def=JSCompiler_inline_result$jscomp$0}legendComponent[channel$jscomp$0]=def}}JSCompiler_temp=legendComponent}else{const {legends,resolve}=model$jscomp$0.component;for(encoding$jscomp$0 of model$jscomp$0.children){parseLegend(encoding$jscomp$0);for(legendComponent of keys$jscomp$0(encoding$jscomp$0.component.legends))resolve.legend[legendComponent]=
parseGuideResolve(model$jscomp$0.component.resolve,legendComponent),"shared"===resolve.legend[legendComponent]&&(legends[legendComponent]=mergeLegendComponent(legends[legendComponent],encoding$jscomp$0.component.legends[legendComponent]),legends[legendComponent]||(resolve.legend[legendComponent]="independent",delete legends[legendComponent]))}for(def of keys$jscomp$0(legends))for(model of model$jscomp$0.children)model.component.legends[def]&&"shared"===resolve.legend[def]&&delete model.component.legends[def];
JSCompiler_temp=legends}return model$jscomp$0.component.legends=JSCompiler_temp}function mergeLegendComponent(mergedLegend,childLegend){if(!mergedLegend)return childLegend.clone();var mergedOrient=mergedLegend.getWithExplicit("orient");const childOrient=childLegend.getWithExplicit("orient");if(!mergedOrient.explicit||!childOrient.explicit||mergedOrient.value===childOrient.value){var typeMerged=!1;for(const prop of LEGEND_COMPONENT_PROPERTIES)mergedOrient=mergeValuesWithExplicit(mergedLegend.getWithExplicit(prop),
childLegend.getWithExplicit(prop),prop,"legend",(v1,v2)=>{switch(prop){case "symbolType":return v1="circle"===v2.value?v2:v1,v1;case "title":return mergeTitleComponent(v1,v2);case "type":return typeMerged=!0,makeImplicit("symbol")}return defaultTieBreaker(v1,v2,prop,"legend")}),mergedLegend.setWithExplicit(prop,mergedOrient);if(typeMerged){var _mergedLegend$implici,_mergedLegend$implici2,_mergedLegend$explici,_mergedLegend$explici2;null!==(_mergedLegend$implici=mergedLegend.implicit)&&void 0!==_mergedLegend$implici&&
null!==(_mergedLegend$implici2=_mergedLegend$implici.encode)&&void 0!==_mergedLegend$implici2&&_mergedLegend$implici2.gradient&&deleteNestedProperty(mergedLegend.implicit,["encode","gradient"]);null!==(_mergedLegend$explici=mergedLegend.explicit)&&void 0!==_mergedLegend$explici&&null!==(_mergedLegend$explici2=_mergedLegend$explici.encode)&&void 0!==_mergedLegend$explici2&&_mergedLegend$explici2.gradient&&deleteNestedProperty(mergedLegend.explicit,["encode","gradient"])}return mergedLegend}}function assembleLegends(model){const legendComponentIndex=
model.component.legends,legendByDomain={};for(const channel of keys$jscomp$0(legendComponentIndex)){var scaleComponent=model.getScaleComponent(channel);scaleComponent=stringify(scaleComponent.get("domains"));if(legendByDomain[scaleComponent])for(const mergedLegendComponent of legendByDomain[scaleComponent])mergeLegendComponent(mergedLegendComponent,legendComponentIndex[channel])||legendByDomain[scaleComponent].push(legendComponentIndex[channel]);else legendByDomain[scaleComponent]=[legendComponentIndex[channel].clone()]}return vals$jscomp$0(legendByDomain).flat().map(l=>
{{var config=model.config,_legend$encode3,$jscomp$inline_1672=l.combine();l=Object.assign({},$jscomp$inline_1672);const disable=$jscomp$inline_1672.disable;$jscomp$inline_1672=$jscomp$inline_1672.labelExpr;l=(delete l.disable,delete l.labelExpr,delete l.selections,l);if(disable)var JSCompiler_inline_result=void 0;else{!1===config.aria&&void 0==l.aria&&(l.aria=!1);if(null!==(_legend$encode3=l.encode)&&void 0!==_legend$encode3&&_legend$encode3.symbols){config=l.encode.symbols.update;!config.fill||"transparent"===
config.fill.value||config.stroke||l.stroke||(config.stroke={value:"transparent"});for(var property of LEGEND_SCALE_CHANNELS)l[property]&&delete config[property]}l.title||delete l.title;if(void 0!==$jscomp$inline_1672){var _legend$encode4,_legend$encode4$label;property=$jscomp$inline_1672;null!==(_legend$encode4=l.encode)&&void 0!==_legend$encode4&&null!==(_legend$encode4$label=_legend$encode4.labels)&&void 0!==_legend$encode4$label&&_legend$encode4$label.update&&isSignalRef(l.encode.labels.update.text)&&
(property=replaceAll($jscomp$inline_1672,"datum.label",l.encode.labels.update.text.signal));_legend$encode4=l;_legend$encode4$label={signal:property};var _legend$encode2,_legend$encode2$part,_legend$encode$part,_legend$encode$part$u;null!==(JSCompiler_inline_result=_legend$encode4.encode)&&void 0!==JSCompiler_inline_result?JSCompiler_inline_result:_legend$encode4.encode={};null!==(_legend$encode2$part=(_legend$encode2=_legend$encode4.encode).labels)&&void 0!==_legend$encode2$part?_legend$encode2$part:
_legend$encode2.labels={};null!==(_legend$encode$part$u=(_legend$encode$part=_legend$encode4.encode.labels).update)&&void 0!==_legend$encode$part$u?_legend$encode$part$u:_legend$encode$part.update={};_legend$encode4.encode.labels.update.text=_legend$encode4$label}JSCompiler_inline_result=l}}return JSCompiler_inline_result}).filter(l=>void 0!==l)}function assembleProjectionsForModelAndChildren(model){return model.children.reduce((projections,child)=>projections.concat(child.assembleProjections()),
assembleProjectionForModel(model))}function assembleProjectionForModel(model){var component=model.component.projection;if(!component||component.merged)return[];const projection=component.combine(),{name}=projection;if(component.data){const size={signal:"[".concat(component.size.map(ref=>ref.signal).join(", "),"]")};component=component.data.reduce((sources,data)=>{data=isSignalRef(data)?data.signal:"data('".concat(model.lookupDataSource(data),"')");sources.includes(data)||sources.push(data);return sources},
[]);if(0>=component.length)throw Error("Projection's fit didn't find any data sources");return[Object.assign({},{name,size,fit:{signal:1<component.length?"[".concat(component.join(", "),"]"):component[0]}},projection)]}return[Object.assign({},{name},{translate:{signal:"[width / 2, height / 2]"}},projection)]}function parseProjection(model){var JSCompiler_temp_const=model.component,JSCompiler_temp;if(isUnitModel(model))if(model.hasProjection){const proj=replaceExprRef(model.specifiedProjection);var fit=
!(proj&&(null!=proj.scale||null!=proj.translate));const size=fit?[model.getSizeSignalRef("width"),model.getSizeSignalRef("height")]:void 0;if(fit){fit=[];const {encoding}=model;for(JSCompiler_temp$jscomp$0 of[["longitude","latitude"],["longitude2","latitude2"]])(getFieldOrDatumDef(encoding[JSCompiler_temp$jscomp$0[0]])||getFieldOrDatumDef(encoding[JSCompiler_temp$jscomp$0[1]]))&&fit.push({signal:model.getName("geojson_".concat(fit.length))});model.channelHasField("shape")&&"geojson"===model.typedFieldDef("shape").type&&
fit.push({signal:model.getName("geojson_".concat(fit.length))});0===fit.length&&fit.push(model.requestDataName(DataSourceType.Main));var JSCompiler_temp$jscomp$0=fit}else JSCompiler_temp$jscomp$0=void 0;model=new ProjectionComponent(model.projectionName(!0),Object.assign({},null!==(JSCompiler_temp=replaceExprRef(model.config.projection))&&void 0!==JSCompiler_temp?JSCompiler_temp:{},null!==proj&&void 0!==proj?proj:{}),size,JSCompiler_temp$jscomp$0);model.get("type")||model.set("type","equalEarth",
!1);JSCompiler_temp=model}else JSCompiler_temp=void 0;else JSCompiler_temp=parseNonUnitProjections(model);JSCompiler_temp_const.projection=JSCompiler_temp}function mergeIfNoConflict(first,second){const allPropertiesShared=every(PROJECTION_PROPERTIES,prop=>!vega.hasOwnProperty(first.explicit,prop)&&!vega.hasOwnProperty(second.explicit,prop)||vega.hasOwnProperty(first.explicit,prop)&&vega.hasOwnProperty(second.explicit,prop)&&deepEqual(first.get(prop),second.get(prop))?!0:!1);if(deepEqual(first.size,
second.size)){if(allPropertiesShared)return first;if(deepEqual(first.explicit,{}))return second;if(deepEqual(second.explicit,{}))return first}return null}function parseNonUnitProjections(model){if(0!==model.children.length){var nonUnitProjection;for(var child$jscomp$0 of model.children)parseProjection(child$jscomp$0);child$jscomp$0=every(model.children,child=>{if(child=child.component.projection){if(nonUnitProjection)return(child=mergeIfNoConflict(nonUnitProjection,child))&&(nonUnitProjection=child),
!!child;nonUnitProjection=child}return!0});if(nonUnitProjection&&child$jscomp$0){child$jscomp$0=model.projectionName(!0);const modelProjection=new ProjectionComponent(child$jscomp$0,nonUnitProjection.specifiedProjection,nonUnitProjection.size,duplicate(nonUnitProjection.data));for(const child of model.children)if(model=child.component.projection)model.isFit&&modelProjection.data.push(...child.component.projection.data),child.renameProjection(model.get("name"),child$jscomp$0),model.merged=!0;return modelProjection}}}
function binKey(bin,field){return"".concat(binToString(bin),"_").concat(field)}function getBinSignalName(model,field,bin){var _normalizeBin;bin=null!==(_normalizeBin=normalizeBin(bin,void 0))&&void 0!==_normalizeBin?_normalizeBin:{};field=binKey(bin,field);return model.getName("".concat(field,"_bins"))}function createBinComponent(t,bin,model){let as;as="as"in t?vega.isString(t.as)?[t.as,"".concat(t.as,"_end")]:[t.as[0],t.as[1]]:[vgField(t,{forAs:!0}),vgField(t,{binSuffix:"end",forAs:!0})];const normalizedBin=
Object.assign({},normalizeBin(bin,void 0));bin=binKey(normalizedBin,t.field);var JSCompiler_inline_result={signal:model.getName("".concat(bin,"_bins")),extentSignal:model.getName("".concat(bin,"_extent"))};const {signal,extentSignal}=JSCompiler_inline_result;if(isParameterExtent(normalizedBin.extent)){var span=normalizedBin.extent;span=parseSelectionExtent(model,span.param,span);delete normalizedBin.extent}t=Object.assign({},{bin:normalizedBin,field:t.field,as:[as]},signal?{signal}:{},extentSignal?
{extentSignal}:{},span?{span}:{});return{key:bin,binComponent:t}}function unquote(pattern){return pattern.startsWith("'")&&pattern.endsWith("'")||pattern.startsWith('"')&&pattern.endsWith('"')?pattern.slice(1,-1):pattern}function parseExpression(field,parse){field=accessPathWithDatum(field);if("number"===parse)return"toNumber(".concat(field,")");if("boolean"===parse)return"toBoolean(".concat(field,")");if("string"===parse)return"toString(".concat(field,")");if("date"===parse)return"toDate(".concat(field,
")");if("flatten"===parse)return field;if(parse.startsWith("date:"))return parse=unquote(parse.slice(5,parse.length)),"timeParse(".concat(field,",'").concat(parse,"')");if(parse.startsWith("utc:"))return parse=unquote(parse.slice(4,parse.length)),"utcParse(".concat(field,",'").concat(parse,"')");warn('Unrecognized parse "'.concat(parse,'".'));return null}function getImplicitFromFilterTransform(transform){const implicit={};forEachLeaf(transform.filter,filter=>{if(isFieldPredicate(filter)){let val=
null;if(isFieldEqualPredicate(filter))val=signalRefOrValue(filter.equal);else if(isFieldLTEPredicate(filter))val=signalRefOrValue(filter.lte);else if(isFieldLTPredicate(filter))val=signalRefOrValue(filter.lt);else if(isFieldGTPredicate(filter))val=signalRefOrValue(filter.gt);else if(isFieldGTEPredicate(filter))val=signalRefOrValue(filter.gte);else if(isFieldRangePredicate(filter))val=filter.range[0];else if(isFieldOneOfPredicate(filter)){var _filter$oneOf;val=(null!==(_filter$oneOf=filter.oneOf)&&
void 0!==_filter$oneOf?_filter$oneOf:filter["in"])[0]}val&&(isDateTime(val)?implicit[filter.field]="date":vega.isNumber(val)?implicit[filter.field]="number":vega.isString(val)&&(implicit[filter.field]="string"));filter.timeUnit&&(implicit[filter.field]="date")}});return implicit}function getImplicitFromEncoding(model){function add(fieldDef){if(isFieldOrDatumDefForTimeFormat(fieldDef))implicit[fieldDef.field]="date";else{var JSCompiler_temp;if(JSCompiler_temp="quantitative"===fieldDef.type)JSCompiler_temp=
fieldDef.aggregate,JSCompiler_temp=vega.isString(JSCompiler_temp)&&contains(["min","max"],JSCompiler_temp);JSCompiler_temp?implicit[fieldDef.field]="number":1<accessPathDepth(fieldDef.field)?fieldDef.field in implicit||(implicit[fieldDef.field]="flatten"):isScaleFieldDef(fieldDef)&&isSortField(fieldDef.sort)&&1<accessPathDepth(fieldDef.sort.field)&&(fieldDef.sort.field in implicit||(implicit[fieldDef.sort.field]="flatten"))}}const implicit={};(isUnitModel(model)||isFacetModel(model))&&model.forEachFieldDef((fieldDef,
channel)=>{isTypedFieldDef(fieldDef)?add(fieldDef):(channel=getMainRangeChannel(channel),channel=model.fieldDef(channel),add(Object.assign({},fieldDef,{type:channel.type})))});if(isUnitModel(model)){const {mark,markDef,encoding}=model;if(isPathMark(mark)&&!model.encoding.order){const dimensionChannelDef=encoding["horizontal"===markDef.orient?"y":"x"];!isFieldDef(dimensionChannelDef)||"quantitative"!==dimensionChannelDef.type||dimensionChannelDef.field in implicit||(implicit[dimensionChannelDef.field]=
"number")}}return implicit}function isDataSourceNode(node){return node instanceof SourceNode||node instanceof GraticuleNode||node instanceof SequenceNode}function getStackByFields(model){return model.stack.stackBy.reduce((fields,by)=>{(by=vgField(by.fieldDef))&&fields.push(by);return fields},[])}function isValidAsArray(as){return vega.isArray(as)&&as.every(s=>vega.isString(s))&&1<as.length}function cloneSubtree(facet){function clone(node){if(!(node instanceof FacetNode)){const copy=node.clone();if(copy instanceof
OutputNode){const newName="scale_"+copy.getSource();copy.setSource(newName);facet.model.component.data.outputNodes[newName]=copy}else(copy instanceof AggregateNode||copy instanceof StackNode||copy instanceof WindowTransformNode||copy instanceof JoinAggregateTransformNode)&&copy.addDimensions(facet.fields);for(const n of node.children.flatMap(clone))n.parent=copy;return[copy]}return node.children.flatMap(clone)}return clone}function moveFacetDown(node){if(node instanceof FacetNode)if(1!==node.numChildren()||
node.children[0]instanceof OutputNode){var facetMain=node.model.component.data.main;moveMainDownToFacet(facetMain);const cloner=cloneSubtree(node);node=node.children.map(cloner).flat();for(const c of node)c.parent=facetMain}else facetMain=node.children[0],(facetMain instanceof AggregateNode||facetMain instanceof StackNode||facetMain instanceof WindowTransformNode||facetMain instanceof JoinAggregateTransformNode)&&facetMain.addDimensions(node.fields),facetMain.swapWithParent(),moveFacetDown(node);
else node.children.map(moveFacetDown)}function moveMainDownToFacet(node){if(node instanceof OutputNode&&node.type===DataSourceType.Main&&1===node.numChildren()){const child=node.children[0];child instanceof FacetNode||(child.swapWithParent(),moveMainDownToFacet(node))}}function checkLinks(nodes){for(const node of nodes){for(const child of node.children)if(child.parent!==node)return!1;if(!checkLinks(node.children))return!1}return!0}function runOptimizer(optimizer,nodes){let modified=!1;for(const node of nodes)modified=
optimizer.optimize(node)||modified;return modified}function optimizationDataflowHelper(dataComponent,model,firstPass){let roots=dataComponent.sources,modified=!1;modified=runOptimizer(new RemoveUnnecessaryOutputNodes,roots)||modified;modified=runOptimizer(new RemoveUnnecessaryIdentifierNodes(model),roots)||modified;roots=roots.filter(r=>0<r.numChildren());modified=runOptimizer(new RemoveUnusedSubtrees,roots)||modified;roots=roots.filter(r=>0<r.numChildren());firstPass||(modified=runOptimizer(new MoveParseUp,
roots)||modified,modified=runOptimizer(new MergeBins(model),roots)||modified,modified=runOptimizer(new RemoveDuplicateTimeUnits,roots)||modified,modified=runOptimizer(new MergeParse,roots)||modified,modified=runOptimizer(new MergeAggregates,roots)||modified,modified=runOptimizer(new MergeTimeUnits,roots)||modified,modified=runOptimizer(new MergeIdenticalNodes,roots)||modified,modified=runOptimizer(new MergeOutputs,roots)||modified);dataComponent.sources=roots;return modified}function parseUnitScaleDomain(model$jscomp$0){const localScaleComponents=
model$jscomp$0.component.scales;for(const channel of keys$jscomp$0(localScaleComponents)){var model=model$jscomp$0,channel$jscomp$0=channel,scaleType=model.getScaleComponent(channel$jscomp$0).get("type"),{encoding}=model;var JSCompiler_inline_result=model.scaleDomain(channel$jscomp$0);var fieldDef=model.typedFieldDef(channel$jscomp$0),scaleConfig=model.config.scale;if("unaggregated"===JSCompiler_inline_result){const {valid,reason}=canUseUnaggregatedDomain(fieldDef,scaleType);valid||(warn(reason),
JSCompiler_inline_result=void 0)}else void 0===JSCompiler_inline_result&&scaleConfig.useUnaggregatedDomain&&({valid:fieldDef}=canUseUnaggregatedDomain(fieldDef,scaleType),fieldDef&&(JSCompiler_inline_result="unaggregated"));JSCompiler_inline_result!==model.scaleDomain(channel$jscomp$0)&&(model.specifiedScales[channel$jscomp$0]=Object.assign({},model.specifiedScales[channel$jscomp$0],{domain:JSCompiler_inline_result}));model="x"===channel$jscomp$0&&getFieldOrDatumDef(encoding.x2)?getFieldOrDatumDef(encoding.x)?
mergeValuesWithExplicit(parseSingleChannelDomain(scaleType,JSCompiler_inline_result,model,"x"),parseSingleChannelDomain(scaleType,JSCompiler_inline_result,model,"x2"),"domain","scale",domainsTieBreaker):parseSingleChannelDomain(scaleType,JSCompiler_inline_result,model,"x2"):"y"===channel$jscomp$0&&getFieldOrDatumDef(encoding.y2)?getFieldOrDatumDef(encoding.y)?mergeValuesWithExplicit(parseSingleChannelDomain(scaleType,JSCompiler_inline_result,model,"y"),parseSingleChannelDomain(scaleType,JSCompiler_inline_result,
model,"y2"),"domain","scale",domainsTieBreaker):parseSingleChannelDomain(scaleType,JSCompiler_inline_result,model,"y2"):parseSingleChannelDomain(scaleType,JSCompiler_inline_result,model,channel$jscomp$0);localScaleComponents[channel].setWithExplicit("domains",model);encoding=void 0;channel$jscomp$0=model$jscomp$0.component.scales[channel];JSCompiler_inline_result=model$jscomp$0.specifiedScales[channel].domain;scaleType=null===(encoding=model$jscomp$0.fieldDef(channel))||void 0===encoding?void 0:encoding.bin;
encoding=isParameterDomain(JSCompiler_inline_result)&&JSCompiler_inline_result;scaleType=vega.isObject(scaleType)&&isParameterExtent(scaleType.extent)&&scaleType.extent;(encoding||scaleType)&&channel$jscomp$0.set("selectionExtent",null!==encoding&&void 0!==encoding?encoding:scaleType,!0);if(model$jscomp$0.component.data.isFaceted){for(channel$jscomp$0=model$jscomp$0;!isFacetModel(channel$jscomp$0)&&channel$jscomp$0.parent;)channel$jscomp$0=channel$jscomp$0.parent;if("shared"===channel$jscomp$0.component.resolve.scale[channel])for(const domain of model.value)isDataRefDomain(domain)&&
(domain.data="scale_"+domain.data.replace("scale_",""))}}}function parseNonUnitScaleDomain(model$jscomp$0){for(var child$jscomp$0 of model$jscomp$0.children){var model=child$jscomp$0;isUnitModel(model)?parseUnitScaleDomain(model):parseNonUnitScaleDomain(model)}model=model$jscomp$0.component.scales;for(const channel of keys$jscomp$0(model)){let domains;child$jscomp$0=null;for(const child of model$jscomp$0.children){var childComponent=child.component.scales[channel];childComponent&&(domains=void 0===
domains?childComponent.getWithExplicit("domains"):mergeValuesWithExplicit(domains,childComponent.getWithExplicit("domains"),"domains","scale",domainsTieBreaker),childComponent=childComponent.get("selectionExtent"),child$jscomp$0&&childComponent&&child$jscomp$0.param!==childComponent.param&&warn("The same selection must be used to override scale domains in a layered view."),child$jscomp$0=childComponent)}model[channel].setWithExplicit("domains",domains);child$jscomp$0&&model[channel].set("selectionExtent",
child$jscomp$0,!0)}}function mapDomainToDataSignal(domain,type,timeUnit){return domain.map(v=>{v=valueExpr(v,{timeUnit,type});return{signal:"{data: ".concat(v,"}")}})}function convertDomainIfItIsDateTime(domain,type,timeUnit){var _normalizeTimeUnit;timeUnit=null===(_normalizeTimeUnit=normalizeTimeUnit(timeUnit))||void 0===_normalizeTimeUnit?void 0:_normalizeTimeUnit.unit;return"temporal"===type||timeUnit?mapDomainToDataSignal(domain,type,timeUnit):[domain]}function parseSingleChannelDomain(scaleType,
domain,model,channel){var {encoding}=model;encoding=getFieldOrDatumDef(encoding[channel]);const {type}=encoding,timeUnit=encoding.timeUnit;if(domain&&domain.unionWith)return channel=parseSingleChannelDomain(scaleType,void 0,model,channel),domain=convertDomainIfItIsDateTime(domain.unionWith,type,timeUnit),makeExplicit([...channel.value,...domain]);if(isSignalRef(domain))return makeExplicit([domain]);if(domain&&"unaggregated"!==domain&&!isParameterDomain(domain))return makeExplicit(convertDomainIfItIsDateTime(domain,
type,timeUnit));var stack=model.stack;if(stack&&channel===stack.fieldChannel){if("normalize"===stack.offset)return makeImplicit([[0,1]]);domain=model.requestDataName(DataSourceType.Main);return makeImplicit([{data:domain,field:model.vgField(channel,{suffix:"start"})},{data:domain,field:model.vgField(channel,{suffix:"end"})}])}stack=SCALE_CHANNEL_INDEX[channel]&&isFieldDef(encoding)?domainSort(model,channel,scaleType):void 0;if(isDatumDef(encoding))return channel=convertDomainIfItIsDateTime([encoding.datum],
type,timeUnit),makeImplicit(channel);if("unaggregated"===domain)return channel=model.requestDataName(DataSourceType.Main),{field:domain}=encoding,makeImplicit([{data:channel,field:vgField({field:domain,aggregate:"min"})},{data:channel,field:vgField({field:domain,aggregate:"max"})}]);if(isBinning(encoding.bin)){if(hasDiscreteDomain(scaleType))return"bin-ordinal"===scaleType?makeImplicit([]):makeImplicit([{data:isBoolean(stack)?model.requestDataName(DataSourceType.Main):model.requestDataName(DataSourceType.Raw),
field:model.vgField(channel,binRequiresRange(encoding,channel)?{binSuffix:"range"}:{}),sort:!0!==stack&&vega.isObject(stack)?stack:{field:model.vgField(channel,{}),op:"min"}}]);({bin:domain}=encoding);if(isBinning(domain)){const binSignal=getBinSignalName(model,encoding.field,domain);return makeImplicit([new SignalRefWrapper(()=>{const signal=model.getSignalName(binSignal);return"[".concat(signal,".start, ").concat(signal,".stop]")})])}return makeImplicit([{data:model.requestDataName(DataSourceType.Main),
field:model.vgField(channel,{})}])}return encoding.timeUnit&&contains(["time","utc"],scaleType)&&hasBandEnd(encoding,isUnitModel(model)?model.encoding[getSecondaryRangeChannel(channel)]:void 0,model.markDef,model.config)?(domain=model.requestDataName(DataSourceType.Main),makeImplicit([{data:domain,field:model.vgField(channel)},{data:domain,field:model.vgField(channel,{suffix:"end"})}])):stack?makeImplicit([{data:isBoolean(stack)?model.requestDataName(DataSourceType.Main):model.requestDataName(DataSourceType.Raw),
field:model.vgField(channel),sort:stack}]):makeImplicit([{data:model.requestDataName(DataSourceType.Main),field:model.vgField(channel)}])}function normalizeSortField(sort,isStackedMeasure){const {op,field,order}=sort;return Object.assign({},{op:null!==op&&void 0!==op?op:isStackedMeasure?"sum":"min"},field?{field:replacePathInField(field)}:{},order?{order}:{})}function domainSort(model,channel,scaleType){if(hasDiscreteDomain(scaleType)){var fieldDef=model.fieldDef(channel);scaleType=fieldDef.sort;
if(isSortArray(scaleType))return{op:"min",field:sortArrayIndexField(fieldDef,channel),order:"ascending"};({stack:fieldDef}=model);var stackDimensions=fieldDef?new Set([...fieldDef.groupbyFields,...fieldDef.stackBy.map(s=>s.fieldDef.field)]):void 0;if(isSortField(scaleType))return model=fieldDef&&!stackDimensions.has(scaleType.field),normalizeSortField(scaleType,model);if(scaleType&&scaleType.encoding){const {encoding,order}=scaleType;model=model.fieldDef(encoding);const {aggregate,field}=model;channel=
fieldDef&&!stackDimensions.has(field);if(isArgminDef(aggregate)||isArgmaxDef(aggregate))return normalizeSortField({field:vgField(model),order},channel);if(isAggregateOp(aggregate)||!aggregate)return normalizeSortField({op:aggregate,field,order},channel)}else{if("descending"===scaleType)return{op:"min",field:model.vgField(channel),order:"descending"};if(contains(["ascending",void 0],scaleType))return!0}}}function canUseUnaggregatedDomain(fieldDef,scaleType){const {aggregate,type}=fieldDef;return aggregate?
vega.isString(aggregate)&&!SHARED_DOMAIN_OPS.has(aggregate)?{valid:!1,reason:'Unaggregated domain not applicable for "'.concat(aggregate,'" since it produces values outside the origin domain of the source data.')}:"quantitative"===type&&"log"===scaleType?{valid:!1,reason:"Unaggregated domain is currently unsupported for log scale (".concat(stringify(fieldDef),").")}:{valid:!0}:{valid:!1,reason:"Using unaggregated domain with raw field has no effect (".concat(stringify(fieldDef),").")}}function domainsTieBreaker(v1$jscomp$0,
v2$jscomp$0,property,propertyOf){if(v1$jscomp$0.explicit&&v2$jscomp$0.explicit){var v1=v1$jscomp$0.value,v2=v2$jscomp$0.value;property="Conflicting ".concat(propertyOf.toString(),' property "').concat(property.toString(),'" (').concat(stringify(v1)," and ").concat(stringify(v2),"). Using the union of the two domains.");warn(property)}return{explicit:v1$jscomp$0.explicit,value:[...v1$jscomp$0.value,...v2$jscomp$0.value]}}function mergeDomains(domains){var uniqueDomains=unique(domains.map(domain=>isDataRefDomain(domain)?
(domain=Object.assign({},domain),delete domain.sort,domain):domain),hash),sorts=unique(domains.map(d=>{if(isDataRefDomain(d))return d=d.sort,void 0===d||isBoolean(d)||("op"in d&&"count"===d.op&&delete d.field,"ascending"===d.order&&delete d.order),d}).filter(s=>void 0!==s),hash);if(0!==uniqueDomains.length){if(1===uniqueDomains.length){uniqueDomains=domains[0];if(isDataRefDomain(uniqueDomains)&&0<sorts.length){var sort=sorts[0];1<sorts.length?(warn("Domains that should be unioned has conflicting sort properties. Sort will be set to true."),
sort=!0):vega.isObject(sort)&&"field"in sort&&uniqueDomains.field===sort.field&&(sort=sort.order?{order:sort.order}:!0);return Object.assign({},uniqueDomains,{sort})}return uniqueDomains}sorts=unique(sorts.map(s=>{if(isBoolean(s)||!("op"in s)||vega.isString(s.op)&&s.op in MULTIDOMAIN_SORT_OP_INDEX)return s;warn("Dropping sort property ".concat(stringify(s),' as unioned domains only support boolean or op "count", "min", and "max".'));return!0}),hash);1===sorts.length?sort=sorts[0]:1<sorts.length&&
(warn("Domains that should be unioned has conflicting sort properties. Sort will be set to true."),sort=!0);sorts=unique(domains.map(d=>isDataRefDomain(d)?d.data:null),x=>x);return 1===sorts.length&&null!==sorts[0]?Object.assign({},{data:sorts[0],fields:uniqueDomains.map(d=>d.field)},sort?{sort}:{}):Object.assign({},{fields:uniqueDomains},sort?{sort}:{})}}function getFieldFromDomain(domain){if(isDataRefDomain(domain)&&vega.isString(domain.field))return domain.field;var JSCompiler_inline_result=vega.isArray(domain)?
!1:"fields"in domain&&!("data"in domain);if(JSCompiler_inline_result){let field;for(const nonUnionDomain of domain.fields)if(isDataRefDomain(nonUnionDomain)&&vega.isString(nonUnionDomain.field))if(!field)field=nonUnionDomain.field;else if(field!==nonUnionDomain.field)return warn("Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect."),field;warn("Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.");
return field}JSCompiler_inline_result=vega.isArray(domain)?!1:"fields"in domain&&"data"in domain;if(JSCompiler_inline_result)return warn("Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect."),domain=domain.fields[0],vega.isString(domain)?domain:void 0}function assembleDomain(model,channel){channel=model.component.scales[channel].get("domains").map(domain=>{isDataRefDomain(domain)&&(domain.data=
model.lookupDataSource(domain.data));return domain});return mergeDomains(channel)}function assembleScales(model){return isLayerModel(model)||isConcatModel(model)?model.children.reduce((scales,child)=>scales.concat(assembleScales(child)),assembleScalesForModel(model)):assembleScalesForModel(model)}function assembleScalesForModel(model){return keys$jscomp$0(model.component.scales).reduce((scales,channel)=>{var scaleComponent=model.component.scales[channel];if(scaleComponent.merged)return scales;var scale=
scaleComponent.combine(),$jscomp$destructuring$var126=Object.assign({},scale);const name=scale.name,type=scale.type;var selectionExtent=scale.selectionExtent;const reverse=scale.reverse;$jscomp$destructuring$var126=(delete $jscomp$destructuring$var126.name,delete $jscomp$destructuring$var126.type,delete $jscomp$destructuring$var126.selectionExtent,delete $jscomp$destructuring$var126.domains,delete $jscomp$destructuring$var126.range,delete $jscomp$destructuring$var126.reverse,$jscomp$destructuring$var126);
scale=scale.range;isXorY(channel)?isVgRangeStep(scale)&&(scale={step:{signal:"".concat(name,"_step")}}):vega.isObject(scale)&&isDataRefDomain(scale)&&(scale=Object.assign({},scale,{data:model.lookupDataSource(scale.data)}));channel=assembleDomain(model,channel);selectionExtent?(selectionExtent=parseSelectionExtent(model,selectionExtent.param,selectionExtent),scaleComponent={signal:hasContinuousDomain(scaleComponent.get("type"))&&vega.isArray(channel)&&channel[0]>channel[1]?"isValid(".concat(selectionExtent,
") \x26\x26 reverse(").concat(selectionExtent,")"):selectionExtent}):scaleComponent=null;scales.push(Object.assign({},{name,type},channel?{domain:channel}:{},scaleComponent?{domainRaw:scaleComponent}:{},{range:scale},void 0!==reverse?{reverse}:{},$jscomp$destructuring$var126));return scales},[])}function getBinStepSignal(model,channel){var fieldDef=model.fieldDef(channel);if(null!==fieldDef&&void 0!==fieldDef&&fieldDef.bin){const {bin,field}=fieldDef;fieldDef=getSizeChannel(channel);const sizeSignal=
model.getName(fieldDef);if(vega.isObject(bin)&&bin.binned&&void 0!==bin.step)return new SignalRefWrapper(()=>{var scaleName=model.scaleName(channel);scaleName='(domain("'.concat(scaleName,'")[1] - domain("').concat(scaleName,'")[0]) / ').concat(bin.step);return"".concat(model.getSignalName(sizeSignal)," / (").concat(scaleName,")")});if(isBinning(bin)){const binSignal=getBinSignalName(model,field,bin);return new SignalRefWrapper(()=>{var updatedName=model.getSignalName(binSignal);updatedName="(".concat(updatedName,
".stop - ").concat(updatedName,".start) / ").concat(updatedName,".step");return"".concat(model.getSignalName(sizeSignal)," / (").concat(updatedName,")")})}}}function parseRangeForChannel(channel,model){const specifiedScale=model.specifiedScales[channel];var {size}=model,scaleType=model.getScaleComponent(channel).get("type");for(var property of RANGE_PROPERTIES)if(void 0!==specifiedScale[property]){const supportedByScaleType=scaleTypeSupportProperty(scaleType,property),channelIncompatability=channelScalePropertyIncompatability(channel,
property);if(supportedByScaleType)if(channelIncompatability)warn(channelIncompatability);else switch(property){case "range":scaleType=specifiedScale.range;if(vega.isArray(scaleType)){if(isXorY(channel))return makeExplicit(scaleType.map(v=>{if("width"===v||"height"===v){v=model.getName(v);const getSignalName=model.getSignalName.bind(model);return SignalRefWrapper.fromName(getSignalName,v)}return v}))}else if(vega.isObject(scaleType))return makeExplicit({data:model.requestDataName(DataSourceType.Main),
field:scaleType.field,sort:{op:"min",field:model.vgField(channel)}});return makeExplicit(scaleType);case "scheme":return makeExplicit(parseScheme(specifiedScale[property]))}else warn(scalePropertyNotWorkWithScaleType(scaleType,property,channel))}property="x"===channel||"xOffset"===channel?"width":"height";size=size[property];if(isStep(size))if(isXorY(channel))if(hasDiscreteDomain(scaleType)){if(size=getPositionStep(size,model,channel))return makeExplicit({step:size})}else warn(stepDropped(property));
else if(channel in OFFSET_SCALE_CHANNEL_INDEX&&"band"===model.getScaleComponent("xOffset"===channel?"x":"y").get("type")&&(size=getOffsetStep(size,scaleType)))return makeExplicit(size);const {rangeMin,rangeMax}=specifiedScale;channel=defaultRange(channel,model);return(void 0!==rangeMin||void 0!==rangeMax)&&scaleTypeSupportProperty(scaleType,"rangeMin")&&vega.isArray(channel)&&2===channel.length?makeExplicit([null!==rangeMin&&void 0!==rangeMin?rangeMin:channel[0],null!==rangeMax&&void 0!==rangeMax?
rangeMax:channel[1]]):makeImplicit(channel)}function parseScheme(scheme){return!vega.isString(scheme)&&scheme.name?Object.assign({},{scheme:scheme.name},omit(scheme,["name"])):{scheme}}function defaultRange(channel,model){const {size,config,mark,encoding}=model;var getSignalName=model.getSignalName.bind(model),{type}=getFieldOrDatumDef(encoding[channel]);const scaleType=model.getScaleComponent(channel).get("type"),{domain,domainMid}=model.specifiedScales[channel];switch(channel){case "x":case "y":if(contains(["point",
"band"],scaleType)&&(type=getDiscretePositionSize(channel,size,config.view),isStep(type)))return{step:getPositionStep(type,model,channel)};type=getSizeChannel(channel);type=model.getName(type);return"y"===channel&&hasContinuousDomain(scaleType)?[SignalRefWrapper.fromName(getSignalName,type),0]:[0,SignalRefWrapper.fromName(getSignalName,type)];case "xOffset":case "yOffset":return getOffsetRange(channel,model,scaleType);case "size":return getSignalName=model.component.scales[channel].get("zero"),getSignalName=
sizeRangeMin(mark,getSignalName,config),type=sizeRangeMax(mark,size,model,config),CONTINUOUS_TO_DISCRETE_SCALES.has(scaleType)?interpolateRange(getSignalName,type,defaultContinuousToDiscreteCount(scaleType,config,domain,channel)):[getSignalName,type];case "theta":return[0,2*Math.PI];case "angle":return[0,360];case "radius":return[0,new SignalRefWrapper(()=>{const w=model.getSignalName("width"),h=model.getSignalName("height");return"min(".concat(w,",").concat(h,")/2")})];case "strokeWidth":return[config.scale.minStrokeWidth,
config.scale.maxStrokeWidth];case "strokeDash":return[[1,0],[4,2],[2,1],[1,1],[1,2,4,2]];case "shape":return"symbol";case "color":case "fill":case "stroke":return"ordinal"===scaleType?"nominal"===type?"category":"ordinal":void 0!==domainMid?"diverging":"rect"===mark||"geoshape"===mark?"heatmap":"ramp";case "opacity":case "fillOpacity":case "strokeOpacity":return[config.scale.minOpacity,config.scale.maxOpacity]}}function getPositionStep(step,model,channel){var {encoding}=model,mergedScaleCmpt=model.getScaleComponent(channel);
channel=getOffsetScaleChannel(channel);const offsetDef=encoding[channel];if("offset"===getStepFor({step,offsetIsDiscrete:isFieldOrDatumDef(offsetDef)&&isDiscrete$1(offsetDef.type)})&&channelHasFieldOrDatum(encoding,channel)){var _mergedScaleCmpt$get;encoding=model.getScaleComponent(channel);model=model.scaleName(channel);model="domain('".concat(model,"').length");if("band"===encoding.get("type")){var _ref,_offsetScaleCmpt$get,_ref2,_offsetScaleCmpt$get2;channel=null!==(_ref=null!==(_offsetScaleCmpt$get=
encoding.get("paddingInner"))&&void 0!==_offsetScaleCmpt$get?_offsetScaleCmpt$get:encoding.get("padding"))&&void 0!==_ref?_ref:0;_ref=null!==(_ref2=null!==(_offsetScaleCmpt$get2=encoding.get("paddingOuter"))&&void 0!==_offsetScaleCmpt$get2?_offsetScaleCmpt$get2:encoding.get("padding"))&&void 0!==_ref2?_ref2:0;model="bandspace(".concat(model,", ").concat(channel,", ").concat(_ref,")")}_ref2=null!==(_mergedScaleCmpt$get=mergedScaleCmpt.get("paddingInner"))&&void 0!==_mergedScaleCmpt$get?_mergedScaleCmpt$get:
mergedScaleCmpt.get("padding");step="".concat(step.step," * ").concat(model," / (1-");mergedScaleCmpt=step.concat;_mergedScaleCmpt$get=_ref2;_mergedScaleCmpt$get=isSignalRef(_mergedScaleCmpt$get)?_mergedScaleCmpt$get.signal:vega.stringValue(_mergedScaleCmpt$get);return{signal:mergedScaleCmpt.call(step,_mergedScaleCmpt$get,")")}}return step.step}function getOffsetStep(step,offsetScaleType){if("offset"===getStepFor({step,offsetIsDiscrete:hasDiscreteDomain(offsetScaleType)}))return{step:step.step}}function getOffsetRange(channel,
model,offsetScaleType){const positionChannel="xOffset"===channel?"x":"y",positionScaleType=model.getScaleComponent(positionChannel).get("type"),positionScaleName=model.scaleName(positionChannel);return"band"===positionScaleType?(channel=getDiscretePositionSize(positionChannel,model.size,model.config.view),isStep(channel)&&(offsetScaleType=getOffsetStep(channel,offsetScaleType))?offsetScaleType:[0,{signal:"bandwidth('".concat(positionScaleName,"')")}]):never("Cannot use ".concat(channel," scale if ").concat(positionChannel,
" scale is not discrete."))}function getDiscretePositionSize(channel,size,viewConfig){channel="x"===channel?"width":"height";return(size=size[channel])?size:getViewConfigDiscreteSize(viewConfig,channel)}function defaultContinuousToDiscreteCount(scaleType,config,domain,channel){switch(scaleType){case "quantile":return config.scale.quantileCount;case "quantize":return config.scale.quantizeCount;case "threshold":if(void 0!==domain&&vega.isArray(domain))return domain.length+1;warn("Domain for ".concat(channel,
" is required for threshold scale."));return 3}}function interpolateRange(rangeMin,rangeMax,cardinality){const f=()=>{const rMax=signalOrStringValue(rangeMax),rMin=signalOrStringValue(rangeMin),step="(".concat(rMax," - ").concat(rMin,") / (").concat(cardinality," - 1)");return"sequence(".concat(rMin,", ").concat(rMax," + ").concat(step,", ").concat(step,")")};return isSignalRef(rangeMax)?new SignalRefWrapper(f):{signal:f()}}function sizeRangeMin(mark,zero,config){if(zero)return isSignalRef(zero)?
{signal:"".concat(zero.signal," ? 0 : ").concat(sizeRangeMin(mark,!1,config))}:0;switch(mark){case "bar":case "tick":return config.scale.minBandSize;case "line":case "trail":case "rule":return config.scale.minStrokeWidth;case "text":return config.scale.minFontSize;case "point":case "square":case "circle":return config.scale.minSize}throw Error(incompatibleChannel("size",mark));}function sizeRangeMax(mark,size,model,config){model={x:getBinStepSignal(model,"x"),y:getBinStepSignal(model,"y")};switch(mark){case "bar":case "tick":if(void 0!==
config.scale.maxBandSize)return config.scale.maxBandSize;const min=minXYStep(size,model,config.view);return vega.isNumber(min)?min-1:new SignalRefWrapper(()=>"".concat(min.signal," - 1"));case "line":case "trail":case "rule":return config.scale.maxStrokeWidth;case "text":return config.scale.maxFontSize;case "point":case "square":case "circle":if(config.scale.maxSize)return config.scale.maxSize;const pointStep=minXYStep(size,model,config.view);return vega.isNumber(pointStep)?Math.pow(.95*pointStep,
2):new SignalRefWrapper(()=>"pow(".concat(.95," * ").concat(pointStep.signal,", 2)"))}throw Error(incompatibleChannel("size",mark));}function minXYStep(size,xyStepSignals,viewConfig){const widthStep=isStep(size.width)?size.width.step:getViewConfigDiscreteStep(viewConfig,"width"),heightStep=isStep(size.height)?size.height.step:getViewConfigDiscreteStep(viewConfig,"height");return xyStepSignals.x||xyStepSignals.y?new SignalRefWrapper(()=>"min(".concat([xyStepSignals.x?xyStepSignals.x.signal:widthStep,
xyStepSignals.y?xyStepSignals.y.signal:heightStep].join(", "),")")):Math.min(widthStep,heightStep)}function parseScaleProperty(model,property){if(isUnitModel(model)){const localScaleComponents=model.component.scales,{config,encoding,markDef,specifiedScales}=model;for(const channel of keys$jscomp$0(localScaleComponents)){var specifiedScale=specifiedScales[channel];const localScaleCmpt=localScaleComponents[channel];var mergedScaleCmpt=model.getScaleComponent(channel),fieldOrDatumDef=getFieldOrDatumDef(encoding[channel]),
specifiedValue=specifiedScale[property];const scaleType=mergedScaleCmpt.get("type"),scalePadding=mergedScaleCmpt.get("padding");mergedScaleCmpt=mergedScaleCmpt.get("paddingInner");const supportedByScaleType=scaleTypeSupportProperty(scaleType,property),channelIncompatability=channelScalePropertyIncompatability(channel,property);void 0!==specifiedValue&&(supportedByScaleType?channelIncompatability&&warn(channelIncompatability):warn(scalePropertyNotWorkWithScaleType(scaleType,property,channel)));if(supportedByScaleType&&
void 0===channelIncompatability)if(void 0!==specifiedValue)switch(specifiedValue=fieldOrDatumDef.timeUnit,fieldOrDatumDef=fieldOrDatumDef.type,property){case "domainMax":case "domainMin":isDateTime(specifiedScale[property])||"temporal"===fieldOrDatumDef||specifiedValue?localScaleCmpt.set(property,{signal:valueExpr(specifiedScale[property],{type:fieldOrDatumDef,timeUnit:specifiedValue})},!0):localScaleCmpt.set(property,specifiedScale[property],!0);break;default:localScaleCmpt.copyKeyFromObject(property,
specifiedScale)}else specifiedScale=property in scaleRules?scaleRules[property]({model,channel,fieldOrDatumDef,scaleType,scalePadding,scalePaddingInner:mergedScaleCmpt,domain:specifiedScale.domain,domainMin:specifiedScale.domainMin,domainMax:specifiedScale.domainMax,markDef,config,hasNestedOffsetScale:channelHasNestedOffsetScale(encoding,channel)}):config.scale[property],void 0!==specifiedScale&&localScaleCmpt.set(property,specifiedScale,!1)}}else parseNonUnitScaleProperty(model,property)}function parseScaleRange(model){if(isUnitModel(model)){const localScaleComponents=
model.component.scales;for(const channel of SCALE_CHANNELS){const localScaleCmpt=localScaleComponents[channel];if(!localScaleCmpt)continue;const rangeWithExplicit=parseRangeForChannel(channel,model);localScaleCmpt.setWithExplicit("range",rangeWithExplicit)}}else parseNonUnitScaleProperty(model,"range")}function parseNonUnitScaleProperty(model,property){const localScaleComponents=model.component.scales;for(var child$jscomp$0 of model.children)"range"===property?parseScaleRange(child$jscomp$0):parseScaleProperty(child$jscomp$0,
property);for(const channel of keys$jscomp$0(localScaleComponents)){let valueWithExplicit;for(const child of model.children)if(child$jscomp$0=child.component.scales[channel])child$jscomp$0=child$jscomp$0.getWithExplicit(property),valueWithExplicit=mergeValuesWithExplicit(valueWithExplicit,child$jscomp$0,property,"scale",tieBreakByComparing((v1,v2)=>{switch(property){case "range":if(v1.step&&v2.step)return v1.step-v2.step}return 0}));localScaleComponents[channel].setWithExplicit(property,valueWithExplicit)}}
function bins$jscomp$1(model,fieldDef){const bin=fieldDef.bin;if(isBinning(bin)){const binSignal=getBinSignalName(model,fieldDef.field,bin);return new SignalRefWrapper(()=>model.getSignalName(binSignal))}if(isBinned(bin)&&vega.isObject(bin)&&void 0!==bin.step)return{step:bin.step}}function paddingInner(paddingValue,channel,mark,scaleType,scaleConfig){let hasNestedOffsetScale=5<arguments.length&&void 0!==arguments[5]?arguments[5]:!1;if(void 0===paddingValue){if(isXorY(channel)){const {bandPaddingInner,
barBandPaddingInner,rectBandPaddingInner,bandWithNestedOffsetPaddingInner}=scaleConfig;return hasNestedOffsetScale?bandWithNestedOffsetPaddingInner:getFirstDefined(bandPaddingInner,"bar"===mark?barBandPaddingInner:rectBandPaddingInner)}if(channel in OFFSET_SCALE_CHANNEL_INDEX&&scaleType===ScaleType.BAND)return scaleConfig.offsetBandPaddingInner}}function paddingOuter$jscomp$0(paddingValue,channel,scaleType,paddingInnerValue,scaleConfig){let hasNestedOffsetScale=5<arguments.length&&void 0!==arguments[5]?
arguments[5]:!1;if(void 0===paddingValue)if(isXorY(channel)){const {bandPaddingOuter,bandWithNestedOffsetPaddingOuter}=scaleConfig;if(hasNestedOffsetScale)return bandWithNestedOffsetPaddingOuter;if(scaleType===ScaleType.BAND)return getFirstDefined(bandPaddingOuter,isSignalRef(paddingInnerValue)?{signal:"".concat(paddingInnerValue.signal,"/2")}:paddingInnerValue/2)}else if(channel in OFFSET_SCALE_CHANNEL_INDEX){if(scaleType===ScaleType.POINT)return.5;if(scaleType===ScaleType.BAND)return scaleConfig.offsetBandPaddingOuter}}
function scaleType$jscomp$2(specifiedScale,channel,fieldDef,mark){const defaultScaleType=defaultType(channel,fieldDef,mark,4<arguments.length&&void 0!==arguments[4]?arguments[4]:!1);var {type}=specifiedScale;if(!SCALE_CHANNEL_INDEX[channel])return null;if(void 0!==type){if(!channelSupportScaleType(channel,type))return type='Channel "'.concat(channel,'" does not work with "').concat(type,'" scale. We are using "').concat(defaultScaleType,'" scale instead.'),warn(type),defaultScaleType;var JSCompiler_temp;
if(JSCompiler_temp=isFieldDef(fieldDef))JSCompiler_temp=fieldDef.type,JSCompiler_temp=!(contains(["ordinal","nominal"],JSCompiler_temp)?void 0===type||hasDiscreteDomain(type):"temporal"===JSCompiler_temp?contains([ScaleType.TIME,ScaleType.UTC,void 0],type):"quantitative"===JSCompiler_temp?QUANTITATIVE_SCALES.has(type)||CONTINUOUS_TO_DISCRETE_SCALES.has(type)||void 0===type:1);return JSCompiler_temp?(type='FieldDef does not work with "'.concat(type,'" scale. We are using "').concat(defaultScaleType,
'" scale instead.'),warn(type),defaultScaleType):type}return defaultScaleType}function defaultType(channel,fieldDef,mark,hasNestedOffsetScale){switch(fieldDef.type){case "nominal":case "ordinal":var _fieldDef$axis;if(isColorChannel(channel)||"discrete"===rangeType(channel))return"shape"===channel&&"ordinal"===fieldDef.type&&warn(discreteChannelCannotEncode(channel,"ordinal")),"ordinal";if(isXorY(channel)||channel in OFFSET_SCALE_CHANNEL_INDEX){if(contains(["rect","bar","image","rule"],mark.type)||
hasNestedOffsetScale)return"band"}else if("arc"===mark.type&&channel in POLAR_POSITION_SCALE_CHANNEL_INDEX)return"band";channel=mark[getSizeChannel(channel)];return isRelativeBandSize(channel)||isPositionFieldOrDatumDef(fieldDef)&&null!==(_fieldDef$axis=fieldDef.axis)&&void 0!==_fieldDef$axis&&_fieldDef$axis.tickBand?"band":"point";case "temporal":if(!isColorChannel(channel)){if("discrete"===rangeType(channel))return warn(discreteChannelCannotEncode(channel,"temporal")),"ordinal";if(isFieldDef(fieldDef)&&
fieldDef.timeUnit&&normalizeTimeUnit(fieldDef.timeUnit).utc)return"utc"}return"time";case "quantitative":if(isColorChannel(channel)){if(isFieldDef(fieldDef)&&isBinning(fieldDef.bin))return"bin-ordinal"}else if("discrete"===rangeType(channel))return warn(discreteChannelCannotEncode(channel,"quantitative")),"ordinal";return"linear";case "geojson":return}throw Error('Invalid field type "'.concat(fieldDef.type,'".'));}function parseScales(model){let {ignoreRange}=1<arguments.length&&void 0!==arguments[1]?
arguments[1]:{};parseScaleCore(model);isUnitModel(model)?parseUnitScaleDomain(model):parseNonUnitScaleDomain(model);for(const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES)parseScaleProperty(model,prop);ignoreRange||parseScaleRange(model)}function parseScaleCore(model){if(isUnitModel(model)){var JSCompiler_temp_const=model.component;const {encoding,mark,markDef}=model;var scaleComponents={};for(var channel$jscomp$0 of SCALE_CHANNELS){var fieldOrDatumDef=getFieldOrDatumDef(encoding[channel$jscomp$0]);
if(!fieldOrDatumDef||mark!==GEOSHAPE||"shape"!==channel$jscomp$0||"geojson"!==fieldOrDatumDef.type){var specifiedScale=fieldOrDatumDef&&fieldOrDatumDef.scale;if(channel$jscomp$0 in OFFSET_SCALE_CHANNEL_INDEX){var mainChannel=getMainChannelFromOffsetChannel(channel$jscomp$0);if(!channelHasNestedOffsetScale(encoding,mainChannel)){specifiedScale&&warn("".concat(channel$jscomp$0," encoding has no scale, so specified scale is ignored."));continue}}if(fieldOrDatumDef&&null!==specifiedScale&&!1!==specifiedScale){var _specifiedScale;
null!==(_specifiedScale=specifiedScale)&&void 0!==_specifiedScale?_specifiedScale:specifiedScale={};mainChannel=channelHasNestedOffsetScale(encoding,channel$jscomp$0);fieldOrDatumDef=scaleType$jscomp$2(specifiedScale,channel$jscomp$0,fieldOrDatumDef,markDef,mainChannel);scaleComponents[channel$jscomp$0]=new ScaleComponent(model.scaleName("".concat(channel$jscomp$0),!0),{value:fieldOrDatumDef,explicit:specifiedScale.type===fieldOrDatumDef})}}}JSCompiler_temp_const.scales=scaleComponents}else{_specifiedScale=
model.component;channel$jscomp$0=model.component.scales={};mainChannel={};const resolve=model.component.resolve;for(const child of model.children){parseScaleCore(child);for(const channel of keys$jscomp$0(child.component.scales))if(null!==(fieldOrDatumDef=(specifiedScale=resolve.scale)[channel])&&void 0!==fieldOrDatumDef?fieldOrDatumDef:specifiedScale[channel]=defaultScaleResolve(channel,model),"shared"===resolve.scale[channel]){const explicitScaleType=mainChannel[channel],childScaleType=child.component.scales[channel].getWithExplicit("type");
if(explicitScaleType){const scaleCategory1=SCALE_CATEGORY_INDEX[explicitScaleType.value],scaleCategory2=SCALE_CATEGORY_INDEX[childScaleType.value];scaleCategory1===scaleCategory2||"ordinal-position"===scaleCategory1&&"time"===scaleCategory2||"ordinal-position"===scaleCategory2&&"time"===scaleCategory1?mainChannel[channel]=mergeValuesWithExplicit(explicitScaleType,childScaleType,"type","scale",scaleTypeTieBreaker):(resolve.scale[channel]="independent",delete mainChannel[channel])}else mainChannel[channel]=
childScaleType}}for(JSCompiler_temp_const of keys$jscomp$0(mainChannel)){specifiedScale=model.scaleName(JSCompiler_temp_const,!0);channel$jscomp$0[JSCompiler_temp_const]=new ScaleComponent(specifiedScale,mainChannel[JSCompiler_temp_const]);for(scaleComponents of model.children)if(fieldOrDatumDef=scaleComponents.component.scales[JSCompiler_temp_const])scaleComponents.renameScale(fieldOrDatumDef.get("name"),specifiedScale),fieldOrDatumDef.merged=!0}_specifiedScale.scales=channel$jscomp$0}}function isUnitModel(model){return"unit"===
(null===model||void 0===model?void 0:model.type)}function isFacetModel(model){return"facet"===(null===model||void 0===model?void 0:model.type)}function isConcatModel(model){return"concat"===(null===model||void 0===model?void 0:model.type)}function isLayerModel(model){return"layer"===(null===model||void 0===model?void 0:model.type)}function makeWalkTree(data){function walkTree(node,dataSource){node instanceof SourceNode&&!(node.isGenerator||"url"in node.data)&&(data.push(dataSource),dataSource={name:null,
source:dataSource.name,transform:[]});if(node instanceof ParseNode)if(node.parent instanceof SourceNode&&!dataSource.source){var _dataSource$format;dataSource.format=Object.assign({},null!==(_dataSource$format=dataSource.format)&&void 0!==_dataSource$format?_dataSource$format:{},{parse:node.assembleFormatParse()});dataSource.transform.push(...node.assembleTransforms(!0))}else dataSource.transform.push(...node.assembleTransforms());if(node instanceof FacetNode)dataSource.name||(dataSource.name="data_".concat(datasetIndex++)),
!dataSource.source||0<dataSource.transform.length?(data.push(dataSource),node.data=dataSource.name):node.data=dataSource.source,data.push(...node.assemble());else switch((node instanceof GraticuleNode||node instanceof SequenceNode||node instanceof FilterInvalidNode||node instanceof FilterNode||node instanceof CalculateNode||node instanceof GeoPointNode||node instanceof AggregateNode||node instanceof LookupNode||node instanceof WindowTransformNode||node instanceof JoinAggregateTransformNode||node instanceof
FoldTransformNode||node instanceof FlattenTransformNode||node instanceof DensityTransformNode||node instanceof LoessTransformNode||node instanceof QuantileTransformNode||node instanceof RegressionTransformNode||node instanceof IdentifierNode||node instanceof SampleTransformNode||node instanceof PivotTransformNode)&&dataSource.transform.push(node.assemble()),(node instanceof BinNode||node instanceof TimeUnitNode||node instanceof ImputeNode||node instanceof StackNode||node instanceof GeoJSONNode)&&
dataSource.transform.push(...node.assemble()),node instanceof OutputNode&&(dataSource.source&&0===dataSource.transform.length?node.setSource(dataSource.source):node.parent instanceof OutputNode?node.setSource(dataSource.name):(dataSource.name||(dataSource.name="data_".concat(datasetIndex++)),node.setSource(dataSource.name),1===node.numChildren()&&(data.push(dataSource),dataSource={name:null,source:dataSource.name,transform:[]}))),node.numChildren()){case 0:node instanceof OutputNode&&(!dataSource.source||
0<dataSource.transform.length)&&data.push(dataSource);break;case 1:walkTree(node.children[0],dataSource);break;default:dataSource.name||(dataSource.name="data_".concat(datasetIndex++));_dataSource$format=dataSource.name;!dataSource.source||0<dataSource.transform.length?data.push(dataSource):_dataSource$format=dataSource.source;for(const child of node.children)walkTree(child,{name:null,source:_dataSource$format,transform:[]})}}let datasetIndex=0;return walkTree}function assembleFacetData(root){const data=
[],walkTree=makeWalkTree(data);for(const child of root.children)walkTree(child,{source:root.name,name:null,transform:[]});return data}function assembleRootData(dataComponent,datasets){const data=[];var walkTree=makeWalkTree(data);let sourceIndex=0;for(const root of dataComponent.sources){root.hasName()||(root.dataName="source_".concat(sourceIndex++));const newData=root.assemble();walkTree(root,newData)}for(const d of data)0===d.transform.length&&delete d.transform;walkTree=0;for(const $jscomp$destructuring$var141 of data.entries()){const [i,
d]=$jscomp$destructuring$var141;var _d$transform;0!==(null!==(_d$transform=d.transform)&&void 0!==_d$transform?_d$transform:[]).length||d.source||data.splice(walkTree++,0,data.splice(i,1)[0])}for(const d of data)for(const t of null!==(_d$transform2=d.transform)&&void 0!==_d$transform2?_d$transform2:[]){var _d$transform2;"lookup"===t.type&&(t.from=dataComponent.outputNodes[t.from].getSource())}for(const d of data)d.name in datasets&&(d.values=datasets[d.name]);return data}function makeHeaderComponent(model,
channel,labels){channel="row"===channel?"height":"width";return{labels,sizeSignal:model.child.component.layoutSize.get(channel)?model.child.getSizeSignalRef(channel):void 0,axes:[]}}function mergeChildAxis(model,channel){var {child}=model;if(child.component.axes[channel]){const {layoutHeaders,resolve}=model.component;resolve.axis[channel]=parseGuideResolve(resolve,channel);if("shared"===resolve.axis[channel]){const headerChannel="x"===channel?"column":"row",layoutHeader=layoutHeaders[headerChannel];
for(const axisComponent of child.component.axes[channel]){var _layoutHeader$headerT;channel=axisComponent.get("orient");channel="top"===channel||"left"===channel||isSignalRef(channel)?"header":"footer";null!==(_layoutHeader$headerT=layoutHeader[channel])&&void 0!==_layoutHeader$headerT?_layoutHeader$headerT:layoutHeader[channel]=[makeHeaderComponent(model,headerChannel,!1)];(child=assembleAxis(axisComponent,"main",model.config,{header:!0}))&&layoutHeader[channel][0].axes.push(child);axisComponent.mainExtracted=
!0}}}}function parseChildrenLayoutSize(model){for(const child of model.children)child.parseLayoutSize()}function parseNonUnitLayoutSizeForChannel(model,layoutSizeType){const sizeType=getSizeTypeFromLayoutSizeType(layoutSizeType),channel=getPositionScaleChannel(sizeType),resolve=model.component.resolve,layoutSizeCmpt=model.component.layoutSize;let mergedSize;for(const child of model.children){var _resolve$scale$channe;const childSize=child.component.layoutSize.getWithExplicit(sizeType),scaleResolve=
null!==(_resolve$scale$channe=resolve.scale[channel])&&void 0!==_resolve$scale$channe?_resolve$scale$channe:defaultScaleResolve(channel,model);if("independent"===scaleResolve&&"step"===childSize.value){mergedSize=void 0;break}if(mergedSize){if("independent"===scaleResolve&&mergedSize.value!==childSize.value){mergedSize=void 0;break}mergedSize=mergeValuesWithExplicit(mergedSize,childSize,sizeType,"")}else mergedSize=childSize}if(mergedSize){for(const child of model.children)model.renameSignal(child.getName(sizeType),
model.getName(layoutSizeType)),child.component.layoutSize.set(sizeType,"merged",!1);layoutSizeCmpt.setWithExplicit(layoutSizeType,mergedSize)}else layoutSizeCmpt.setWithExplicit(layoutSizeType,{explicit:!1,value:void 0})}function defaultUnitSize(model,sizeType){const config=model.config;var scaleComponent=model.getScaleComponent("width"===sizeType?"x":"y");if(scaleComponent)return model=scaleComponent.get("type"),scaleComponent=scaleComponent.get("range"),hasDiscreteDomain(model)?(sizeType=getViewConfigDiscreteSize(config.view,
sizeType),isVgRangeStep(scaleComponent)||isStep(sizeType)?"step":sizeType):getViewConfigContinuousSize(config.view,sizeType);if(model.hasProjection||"arc"===model.mark)return getViewConfigContinuousSize(config.view,sizeType);sizeType=getViewConfigDiscreteSize(config.view,sizeType);return isStep(sizeType)?sizeType.step:sizeType}function facetSortFieldName(fieldDef,sort,opt){return vgField(sort,Object.assign({},{suffix:"by_".concat(vgField(fieldDef))},null!==opt&&void 0!==opt?opt:{}))}function findSource(data,
sources){for(const other of sources){var _data$format,_otherData$format,_data$format2,_otherData$format2;sources=other.data;if(data.name&&other.hasName()&&data.name!==other.dataName)continue;const formatMesh=null===(_data$format=data.format)||void 0===_data$format?void 0:_data$format.mesh;var otherFeature=null===(_otherData$format=sources.format)||void 0===_otherData$format?void 0:_otherData$format.feature;if(formatMesh&&otherFeature)continue;const formatFeature=null===(_data$format2=data.format)||
void 0===_data$format2?void 0:_data$format2.feature;if(!formatFeature&&!otherFeature||formatFeature===otherFeature)if(otherFeature=null===(_otherData$format2=sources.format)||void 0===_otherData$format2?void 0:_otherData$format2.mesh,!formatMesh&&!otherFeature||formatMesh===otherFeature)if("values"in data&&"values"in sources){if(deepEqual(data.values,sources.values))return other}else if("url"in data&&"url"in sources){if(data.url===sources.url)return other}else if(isNamedData(data)&&data.name===other.dataName)return other}return null}
function parseRoot(model,sources){if(model.data||!model.parent){if(null===model.data)return model=new SourceNode({values:[]}),sources.push(model),model;const existingSource=findSource(model.data,sources);if(existingSource)return isGenerator(model.data)||(existingSource.data.format=mergeDeep({},model.data.format,existingSource.data.format)),!existingSource.hasName()&&model.data.name&&(existingSource.dataName=model.data.name),existingSource;model=new SourceNode(model.data);sources.push(model);return model}return model.parent.component.data.facetRoot?
model.parent.component.data.facetRoot:model.parent.component.data.main}function parseData(model){var _data$format3,_ParseNode$makeExplic,_ParseNode$makeWithAn2,head=parseRoot(model,model.component.data.sources);const {outputNodes,outputNodeRefCounts}=model.component.data,data=model.data,ancestorParse=data&&(isGenerator(data)||"url"in data||"values"in data)||!model.parent?new AncestorParse:model.parent.component.data.ancestorParse.clone();isGenerator(data)?("sequence"in data?head=new SequenceNode(head,
data.sequence):"graticule"in data&&(head=new GraticuleNode(head,data.graticule)),ancestorParse.parseNothing=!0):null===(null===data||void 0===data?void 0:null===(_data$format3=data.format)||void 0===_data$format3?void 0:_data$format3.parse)&&(ancestorParse.parseNothing=!0);head=null!==(_ParseNode$makeExplic=ParseNode.makeExplicit(head,model,ancestorParse))&&void 0!==_ParseNode$makeExplic?_ParseNode$makeExplic:head;head=new IdentifierNode(head);_data$format3=model.parent&&isLayerModel(model.parent);
if((isUnitModel(model)||isFacetModel(model))&&_data$format3){var _BinNode$makeFromEnco;head=null!==(_BinNode$makeFromEnco=BinNode.makeFromEncoding(head,model))&&void 0!==_BinNode$makeFromEnco?_BinNode$makeFromEnco:head}if(0<model.transforms.length){_BinNode$makeFromEnco=0;for(const t of model.transforms){var transformNode=_ParseNode$makeExplic=void 0;if("calculate"in t)transformNode=head=new CalculateNode(head,t),_ParseNode$makeExplic="derived";else if("filter"in t){var _ParseNode$makeWithAn;transformNode=
getImplicitFromFilterTransform(t);transformNode=head=null!==(_ParseNode$makeWithAn=ParseNode.makeWithAncestors(head,{},transformNode,ancestorParse))&&void 0!==_ParseNode$makeWithAn?_ParseNode$makeWithAn:head;head=new FilterNode(head,model,t.filter)}else if("bin"in t)transformNode=head=BinNode.makeFromTransform(head,t,model),_ParseNode$makeExplic="number";else if("timeUnit"in t)_ParseNode$makeExplic="date",void 0===ancestorParse.getWithExplicit(t.field).value&&(head=new ParseNode(head,{[t.field]:_ParseNode$makeExplic}),
ancestorParse.set(t.field,_ParseNode$makeExplic,!1)),transformNode=head=TimeUnitNode.makeFromTransform(head,t);else if("aggregate"in t)transformNode=head=AggregateNode.makeFromTransform(head,t),_ParseNode$makeExplic="number",requiresSelectionId(model)&&(head=new IdentifierNode(head));else if("lookup"in t)transformNode=head=LookupNode.make(head,model,t,_BinNode$makeFromEnco++),_ParseNode$makeExplic="derived";else if("window"in t)transformNode=head=new WindowTransformNode(head,t),_ParseNode$makeExplic=
"number";else if("joinaggregate"in t)transformNode=head=new JoinAggregateTransformNode(head,t),_ParseNode$makeExplic="number";else if("stack"in t)transformNode=head=StackNode.makeFromTransform(head,t),_ParseNode$makeExplic="derived";else if("fold"in t)transformNode=head=new FoldTransformNode(head,t),_ParseNode$makeExplic="derived";else if("flatten"in t)transformNode=head=new FlattenTransformNode(head,t),_ParseNode$makeExplic="derived";else if("pivot"in t)transformNode=head=new PivotTransformNode(head,
t),_ParseNode$makeExplic="derived";else if("sample"in t)head=new SampleTransformNode(head,t);else if("impute"in t)transformNode=head=ImputeNode.makeFromTransform(head,t),_ParseNode$makeExplic="derived";else if("density"in t)transformNode=head=new DensityTransformNode(head,t),_ParseNode$makeExplic="derived";else if("quantile"in t)transformNode=head=new QuantileTransformNode(head,t),_ParseNode$makeExplic="derived";else if("regression"in t)transformNode=head=new RegressionTransformNode(head,t),_ParseNode$makeExplic=
"derived";else if("loess"in t)transformNode=head=new LoessTransformNode(head,t),_ParseNode$makeExplic="derived";else{warn("Ignoring an invalid transform: ".concat(stringify(t),"."));continue}if(transformNode&&void 0!==_ParseNode$makeExplic)for(const field of null!==(_transformNode$produc=transformNode.producedFields())&&void 0!==_transformNode$produc?_transformNode$produc:[]){var _transformNode$produc;ancestorParse.set(field,_ParseNode$makeExplic,!1)}}}_ParseNode$makeWithAn={};if(isUnitModel(model)&&
model.component.selection)for(var name of keys$jscomp$0(model.component.selection)){_transformNode$produc=model.component.selection[name];for(const proj of _transformNode$produc.project.items)!proj.channel&&1<accessPathDepth(proj.field)&&(_ParseNode$makeWithAn[proj.field]="flatten")}name=getImplicitFromEncoding(model);head=null!==(_ParseNode$makeWithAn2=ParseNode.makeWithAncestors(head,{},Object.assign({},_ParseNode$makeWithAn,name),ancestorParse))&&void 0!==_ParseNode$makeWithAn2?_ParseNode$makeWithAn2:
head;isUnitModel(model)&&(head=GeoJSONNode.parseAll(head,model),head=GeoPointNode.parseAll(head,model));if(isUnitModel(model)||isFacetModel(model)){var _TimeUnitNode$makeFro;if(!_data$format3){var _BinNode$makeFromEnco2;head=null!==(_BinNode$makeFromEnco2=BinNode.makeFromEncoding(head,model))&&void 0!==_BinNode$makeFromEnco2?_BinNode$makeFromEnco2:head}head=null!==(_TimeUnitNode$makeFro=TimeUnitNode.makeFromEncoding(head,model))&&void 0!==_TimeUnitNode$makeFro?_TimeUnitNode$makeFro:head;head=CalculateNode.parseAllForSortIndex(head,
model)}_TimeUnitNode$makeFro=model.getDataName(DataSourceType.Raw);_ParseNode$makeWithAn2=new OutputNode(head,_TimeUnitNode$makeFro,DataSourceType.Raw,outputNodeRefCounts);head=outputNodes[_TimeUnitNode$makeFro]=_ParseNode$makeWithAn2;if(isUnitModel(model)){var _ImputeNode$makeFromE,_StackNode$makeFromEn;if(_TimeUnitNode$makeFro=AggregateNode.makeFromEncoding(head,model))head=_TimeUnitNode$makeFro,requiresSelectionId(model)&&(head=new IdentifierNode(head));head=null!==(_ImputeNode$makeFromE=ImputeNode.makeFromEncoding(head,
model))&&void 0!==_ImputeNode$makeFromE?_ImputeNode$makeFromE:head;head=null!==(_StackNode$makeFromEn=StackNode.makeFromEncoding(head,model))&&void 0!==_StackNode$makeFromEn?_StackNode$makeFromEn:head}if(isUnitModel(model)){var _FilterInvalidNode$ma;head=null!==(_FilterInvalidNode$ma=FilterInvalidNode.make(head,model))&&void 0!==_FilterInvalidNode$ma?_FilterInvalidNode$ma:head}_StackNode$makeFromEn=model.getDataName(DataSourceType.Main);_ImputeNode$makeFromE=new OutputNode(head,_StackNode$makeFromEn,
DataSourceType.Main,outputNodeRefCounts);head=outputNodes[_StackNode$makeFromEn]=_ImputeNode$makeFromE;if(isUnitModel(model))for(var $jscomp$inline_1830 of entries$1(null!==(_model$component$sele=model.component.selection)&&void 0!==_model$component$sele?_model$component$sele:{})){const [selection,selCmpt]=$jscomp$inline_1830;var _model$component$sele;_model$component$sele=model.getName("lookup_".concat(selection));model.component.data.outputNodes[_model$component$sele]=selCmpt.materialized=new OutputNode(new FilterNode(_ImputeNode$makeFromE,
model,{param:selection}),_model$component$sele,DataSourceType.Lookup,model.component.data.outputNodeRefCounts)}_model$component$sele=null;if(isFacetModel(model)){var _makeJoinAggregateFro;$jscomp$inline_1830=model.getName("facet");{_model$component$sele=head;const {row,column}=model.facet;if(row&&column){_StackNode$makeFromEn=null;for(JSCompiler_inline_result of[row,column])if(isSortField(JSCompiler_inline_result.sort)){const {field,op="min"}=JSCompiler_inline_result.sort;_model$component$sele=_StackNode$makeFromEn=
new JoinAggregateTransformNode(_model$component$sele,{joinaggregate:[{op,field,as:facetSortFieldName(JSCompiler_inline_result,JSCompiler_inline_result.sort,{forAs:!0})}],groupby:[vgField(JSCompiler_inline_result)]})}var JSCompiler_inline_result=_StackNode$makeFromEn}else JSCompiler_inline_result=null}head=null!==(_makeJoinAggregateFro=JSCompiler_inline_result)&&void 0!==_makeJoinAggregateFro?_makeJoinAggregateFro:head;_model$component$sele=new FacetNode(head,model,$jscomp$inline_1830,_ImputeNode$makeFromE.getSource());
outputNodes[$jscomp$inline_1830]=_model$component$sele}return Object.assign({},model.component.data,{outputNodes,outputNodeRefCounts,raw:_ParseNode$makeWithAn2,main:_ImputeNode$makeFromE,facetRoot:_model$component$sele,ancestorParse})}function parseUnitAxes(model){return POSITION_SCALE_CHANNELS.reduce((axis,channel)=>{model.component.scales[channel]&&(axis[channel]=[parseAxis(channel,model)]);return axis},{})}function mergeAxisComponents(mergedAxisCmpts,childAxisCmpts){if(mergedAxisCmpts){if(mergedAxisCmpts.length!==
childAxisCmpts.length)return;const length=mergedAxisCmpts.length;for(let i=0;i<length;i++){const merged=mergedAxisCmpts[i],child=childAxisCmpts[i];if(!!merged!==!!child)return;if(merged&&child){const mergedOrient=merged.getWithExplicit("orient"),childOrient=child.getWithExplicit("orient");if(mergedOrient.explicit&&childOrient.explicit&&mergedOrient.value!==childOrient.value)return;mergedAxisCmpts[i]=mergeAxisComponent(merged,child)}}}else return childAxisCmpts.map(axisComponent=>axisComponent.clone());
return mergedAxisCmpts}function mergeAxisComponent(merged,child){for(const prop of AXIS_COMPONENT_PROPERTIES){const mergedValueWithExplicit=mergeValuesWithExplicit(merged.getWithExplicit(prop),child.getWithExplicit(prop),prop,"axis",(v1,v2)=>{switch(prop){case "title":return mergeTitleComponent(v1,v2);case "gridScale":return{explicit:v1.explicit,value:getFirstDefined(v1.value,v2.value)}}return defaultTieBreaker(v1,v2,prop,"axis")});merged.setWithExplicit(prop,mergedValueWithExplicit)}return merged}
function isExplicit(value,property,axis,model,channel){if("disable"===property)return void 0!==axis;axis=axis||{};switch(property){case "titleAngle":case "labelAngle":return value===(isSignalRef(axis.labelAngle)?axis.labelAngle:normalizeAngle(axis.labelAngle));case "values":return!!axis.values;case "encode":return!!axis.encoding||!!axis.labelAngle;case "title":if(value===getFieldDefTitle(model,channel))return!0}return value===axis[property]}function parseAxis(channel,model){var _axis,_config,_config$axis,
_axis2,_axis$encoding;let axis=model.axis(channel);const axisComponent=new AxisComponent;var fieldOrDatumDef=getFieldOrDatumDef(model.encoding[channel]);const {mark,config:config$jscomp$0}=model;var orient=(null===(_axis=axis)||void 0===_axis?void 0:_axis.orient)||(null===(_config=config$jscomp$0["x"===channel?"axisX":"axisY"])||void 0===_config?void 0:_config.orient)||(null===(_config$axis=config$jscomp$0.axis)||void 0===_config$axis?void 0:_config$axis.orient)||("x"===channel?"bottom":"left");_config=
model.getScaleComponent(channel).get("type");_axis=getAxisConfigs(channel,_config,orient,model.config);_config$axis=void 0!==axis?!axis:getAxisConfig("disable",config$jscomp$0.style,null===(_axis2=axis)||void 0===_axis2?void 0:_axis2.style,_axis).configValue;axisComponent.set("disable",_config$axis,void 0!==axis);if(_config$axis)return axisComponent;axis=axis||{};_axis2=getLabelAngle(fieldOrDatumDef,axis,channel,config$jscomp$0.style,_axis);fieldOrDatumDef={fieldOrDatumDef,axis,channel,model,scaleType:_config,
orient,labelAngle:_axis2,mark,config:config$jscomp$0};for(const property of AXIS_COMPONENT_PROPERTIES)if(orient=property in axisRules?axisRules[property](fieldOrDatumDef):AXIS_PROPERTIES_INDEX[property]?axis[property]:void 0,_axis2=void 0!==orient,_config=isExplicit(orient,property,axis,model,channel),_axis2&&_config)axisComponent.set(property,orient,_config);else{const {configValue,configFrom}=AXIS_PROPERTIES_INDEX[property]&&"values"!==property?getAxisConfig(property,config$jscomp$0.style,axis.style,
_axis):{};_config$axis=void 0!==configValue;_axis2&&!_config$axis?axisComponent.set(property,orient,_config):("vgAxisConfig"!==configFrom||propsToAlwaysIncludeConfig.has(property)&&_config$axis||isConditionalAxisValue(configValue)||isSignalRef(configValue))&&axisComponent.set(property,configValue,!1)}const axisEncoding=null!==(_axis$encoding=axis.encoding)&&void 0!==_axis$encoding?_axis$encoding:{};_axis$encoding=AXIS_PARTS.reduce((e,part)=>{var _axisEncoding$part;if(!axisComponent.hasAxisPart(part))return e;
var axisEncodingPart=guideEncodeEntry(null!==(_axisEncoding$part=axisEncoding[part])&&void 0!==_axisEncoding$part?_axisEncoding$part:{},model);if("labels"===part){{var _getFieldOrDatumDef;const {encoding,config}=model;_axisEncoding$part=null!==(_getFieldOrDatumDef=getFieldOrDatumDef(encoding[channel]))&&void 0!==_getFieldOrDatumDef?_getFieldOrDatumDef:getFieldOrDatumDef(encoding[getSecondaryRangeChannel(channel)]);_getFieldOrDatumDef=model.axis(channel)||{};const {format,formatType}=_getFieldOrDatumDef;
axisEncodingPart=isCustomFormatType(formatType)?Object.assign({},{text:formatCustomType({fieldOrDatumDef:_axisEncoding$part,field:"datum.value",format,formatType,config})},axisEncodingPart):axisEncodingPart}}void 0===axisEncodingPart||isEmpty(axisEncodingPart)||(e[part]={update:axisEncodingPart});return e},{});isEmpty(_axis$encoding)||axisComponent.set("encode",_axis$encoding,!!axis.encoding||void 0!==axis.labelAngle);return axisComponent}function initLayoutSize(_ref){let {encoding,size}=_ref;for(const channel of POSITION_SCALE_CHANNELS)_ref=
getSizeChannel(channel),isStep(size[_ref])&&isContinuousFieldOrDatumDef(encoding[channel])&&(delete size[_ref],warn(stepDropped(_ref)));return size}function initMarkdef(originalMarkDef,encoding,config){originalMarkDef=replaceExprRef(originalMarkDef);var specifiedOrient=getMarkPropOrConfig("orient",originalMarkDef,config);originalMarkDef.orient=orient$jscomp$1(originalMarkDef.type,encoding,specifiedOrient);void 0!==specifiedOrient&&specifiedOrient!==originalMarkDef.orient&&(specifiedOrient='Specified orient "'.concat(originalMarkDef.orient,
'" overridden with "').concat(specifiedOrient,'".'),warn(specifiedOrient));if("bar"===originalMarkDef.type&&originalMarkDef.orient&&(specifiedOrient=getMarkPropOrConfig("cornerRadiusEnd",originalMarkDef,config),void 0!==specifiedOrient)){const newProps="horizontal"===originalMarkDef.orient&&encoding.x2||"vertical"===originalMarkDef.orient&&encoding.y2?["cornerRadius"]:BAR_CORNER_RADIUS_INDEX[originalMarkDef.orient];for(var newProp of newProps)originalMarkDef[newProp]=specifiedOrient;void 0!==originalMarkDef.cornerRadiusEnd&&
delete originalMarkDef.cornerRadiusEnd}void 0===getMarkPropOrConfig("opacity",originalMarkDef,config)&&(newProp=contains([POINT,TICK,CIRCLE,SQUARE],originalMarkDef.type)&&!isAggregate$1(encoding)?.7:void 0,originalMarkDef.opacity=newProp);void 0===getMarkPropOrConfig("cursor",originalMarkDef,config)&&(encoding=encoding.href||originalMarkDef.href||getMarkPropOrConfig("href",originalMarkDef,config)?"pointer":originalMarkDef.cursor,originalMarkDef.cursor=encoding);return originalMarkDef}function defaultFilled(markDef,
config,_ref){({graticule:_ref}=_ref);if(_ref)return!1;config=getMarkConfig("filled",markDef,config);markDef=markDef.type;return getFirstDefined(config,markDef!==POINT&&markDef!==LINE&&markDef!==RULE)}function orient$jscomp$1(mark,encoding,specifiedOrient){switch(mark){case POINT:case CIRCLE:case SQUARE:case TEXT:case RECT:case IMAGE:return}const {x,y,x2,y2}=encoding;switch(mark){case BAR:if(isFieldDef(x)&&(isBinned(x.bin)||isFieldDef(y)&&y.aggregate&&!x.aggregate))break;if(isFieldDef(y)&&(isBinned(y.bin)||
isFieldDef(x)&&x.aggregate&&!y.aggregate))return"horizontal";if(y2||x2){if(specifiedOrient)return specifiedOrient;if(!x2&&(isFieldDef(x)&&"quantitative"===x.type&&!isBinning(x.bin)||isNumericDataDef(x)))return"horizontal";if(!y2&&(isFieldDef(y)&&"quantitative"===y.type&&!isBinning(y.bin)||isNumericDataDef(y)))break}case RULE:if(!(!x2||isFieldDef(x)&&isBinned(x.bin)||!y2||isFieldDef(y)&&isBinned(y.bin)))return;case AREA:if(y2){if(isFieldDef(y)&&isBinned(y.bin))return"horizontal";break}else if(x2)if(isFieldDef(x)&&
isBinned(x.bin))break;else return"horizontal";else if(mark===RULE)if(x&&!y)break;else if(y&&!x)return"horizontal";case LINE:case TICK:encoding=isContinuousFieldOrDatumDef(x);const yIsContinuous=isContinuousFieldOrDatumDef(y);if(specifiedOrient)return specifiedOrient;if(encoding&&!yIsContinuous)return"tick"!==mark?"horizontal":"vertical";if(!encoding&&yIsContinuous)return"tick"!==mark?"vertical":"horizontal";if(encoding&&yIsContinuous){specifiedOrient="temporal"===x.type;encoding="temporal"===y.type;
if(specifiedOrient&&!encoding)return"tick"!==mark?"vertical":"horizontal";if(!specifiedOrient&&encoding)return"tick"!==mark?"horizontal":"vertical";if(!x.aggregate&&y.aggregate)return"tick"!==mark?"vertical":"horizontal";if(x.aggregate&&!y.aggregate)return"tick"!==mark?"horizontal":"vertical"}else return}return"vertical"}function encodeEntry(model,fixedShape){var JSCompiler_temp_const=Object,JSCompiler_temp_const$jscomp$0=JSCompiler_temp_const.assign,JSCompiler_temp_const$jscomp$1=baseEncodeEntry(model,
{align:"ignore",baseline:"ignore",color:"include",size:"include",orient:"ignore",theta:"ignore"}),JSCompiler_temp_const$jscomp$2=pointPosition("x",model,{defaultPos:"mid"}),JSCompiler_temp_const$jscomp$3=pointPosition("y",model,{defaultPos:"mid"}),JSCompiler_temp_const$jscomp$4=nonPosition("size",model),JSCompiler_temp_const$jscomp$5=nonPosition("angle",model);model=fixedShape?{shape:{value:fixedShape}}:nonPosition("shape",model);return JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const,{},
JSCompiler_temp_const$jscomp$1,JSCompiler_temp_const$jscomp$2,JSCompiler_temp_const$jscomp$3,JSCompiler_temp_const$jscomp$4,JSCompiler_temp_const$jscomp$5,model)}function parseMarkGroups(model){if(contains([LINE,AREA,TRAIL],model.mark)){var details=pathGroupingFields(model.mark,model.encoding);if(0<details.length)return getPathGroups(model,details)}else if(model.mark===BAR&&(details=VG_CORNERRADIUS_CHANNELS.some(prop=>getMarkPropOrConfig(prop,model.markDef,model.config)),model.stack&&!model.fieldDef("size")&&
details))return getGroupsForStackedBarWithCornerRadius(model);return getMarkGroup(model)}function getPathGroups(model,details){return[{name:model.getName("pathgroup"),type:"group",from:{facet:{name:"faceted_path_"+model.requestDataName(DataSourceType.Main),data:model.requestDataName(DataSourceType.Main),groupby:details}},encode:{update:{width:{field:{group:"width"}},height:{field:{group:"height"}}}},marks:getMarkGroup(model,{fromPrefix:"faceted_path_"})}]}function getGroupsForStackedBarWithCornerRadius(model){var _model$stack$groupbyC;
const [mark]=getMarkGroup(model,{fromPrefix:"stack_group_"}),fieldScale=model.scaleName(model.stack.fieldChannel),stackField=function(){return model.vgField(model.stack.fieldChannel,0<arguments.length&&void 0!==arguments[0]?arguments[0]:{})};var stackFieldGroup=(func,expr)=>{expr=[stackField({prefix:"min",suffix:"start",expr}),stackField({prefix:"max",suffix:"start",expr}),stackField({prefix:"min",suffix:"end",expr}),stackField({prefix:"max",suffix:"end",expr})];return"".concat(func,"(").concat(expr.map(field=>
"scale('".concat(fieldScale,"',").concat(field,")")).join(","),")")};let innerGroupUpdate;"x"===model.stack.fieldChannel?(stackFieldGroup=Object.assign({},pick(mark.encode.update,["y","yc","y2","height",...VG_CORNERRADIUS_CHANNELS]),{x:{signal:stackFieldGroup("min","datum")},x2:{signal:stackFieldGroup("max","datum")},clip:{value:!0}}),innerGroupUpdate={x:{field:{group:"x"},mult:-1},height:{field:{group:"height"}}},mark.encode.update=Object.assign({},omit(mark.encode.update,["y","yc","y2"]),{height:{field:{group:"height"}}})):
(stackFieldGroup=Object.assign({},pick(mark.encode.update,["x","xc","x2","width"]),{y:{signal:stackFieldGroup("min","datum")},y2:{signal:stackFieldGroup("max","datum")},clip:{value:!0}}),innerGroupUpdate={y:{field:{group:"y"},mult:-1},width:{field:{group:"width"}}},mark.encode.update=Object.assign({},omit(mark.encode.update,["x","xc","x2"]),{width:{field:{group:"width"}}}));for(var key of VG_CORNERRADIUS_CHANNELS){var configValue$jscomp$0=getMarkConfig(key,model.markDef,model.config);mark.encode.update[key]?
(stackFieldGroup[key]=mark.encode.update[key],delete mark.encode.update[key]):configValue$jscomp$0&&(stackFieldGroup[key]=signalOrValueRef(configValue$jscomp$0));configValue$jscomp$0&&(mark.encode.update[key]={value:0})}key=[];if(0<(null===(_model$stack$groupbyC=model.stack.groupbyChannels)||void 0===_model$stack$groupbyC?void 0:_model$stack$groupbyC.length))for(const groupbyChannel of model.stack.groupbyChannels)_model$stack$groupbyC=model.fieldDef(groupbyChannel),(configValue$jscomp$0=vgField(_model$stack$groupbyC))&&
key.push(configValue$jscomp$0),(null!==_model$stack$groupbyC&&void 0!==_model$stack$groupbyC&&_model$stack$groupbyC.bin||null!==_model$stack$groupbyC&&void 0!==_model$stack$groupbyC&&_model$stack$groupbyC.timeUnit)&&key.push(vgField(_model$stack$groupbyC,{binSuffix:"end"}));stackFieldGroup="stroke strokeWidth strokeJoin strokeCap strokeDash strokeDashOffset strokeMiterLimit strokeOpacity".split(" ").reduce((encode,prop)=>{if(mark.encode.update[prop])return Object.assign({},encode,{[prop]:mark.encode.update[prop]});
const configValue=getMarkConfig(prop,model.markDef,model.config);return void 0!==configValue?Object.assign({},encode,{[prop]:signalOrValueRef(configValue)}):encode},stackFieldGroup);stackFieldGroup.stroke&&(stackFieldGroup.strokeForeground={value:!0},stackFieldGroup.strokeOffset={value:0});return[{type:"group",from:{facet:{data:model.requestDataName(DataSourceType.Main),name:"stack_group_"+model.requestDataName(DataSourceType.Main),groupby:key,aggregate:{fields:[stackField({suffix:"start"}),stackField({suffix:"start"}),
stackField({suffix:"end"}),stackField({suffix:"end"})],ops:["min","max","min","max"]}}},encode:{update:stackFieldGroup},marks:[{type:"group",encode:{update:innerGroupUpdate},marks:[mark]}]}]}function getSort(model){const {encoding,stack,mark,markDef,config}=model;var order=encoding.order;if(!(!vega.isArray(order)&&isValueDef(order)&&isNullOrFalse(order.value)||!order&&isNullOrFalse(getMarkPropOrConfig("order",markDef,config)))){if((vega.isArray(order)||isFieldDef(order))&&!stack)return sortParams(order,
{expr:"datum"});if(isPathMark(mark)){const dimensionChannel="horizontal"===markDef.orient?"y":"x",dimensionChannelDef=encoding[dimensionChannel];if(isFieldDef(dimensionChannelDef)){order=dimensionChannelDef.sort;if(vega.isArray(order))return{field:vgField(dimensionChannelDef,{prefix:dimensionChannel,suffix:"sort_index",expr:"datum"})};if(isSortField(order))return{field:vgField({aggregate:isAggregate$1(model.encoding)?order.op:void 0,field:order.field},{expr:"datum"})};if(order&&order.encoding)return model=
model.fieldDef(order.encoding),{field:vgField(model,{expr:"datum"}),order:order.order};if(null!==order){var _model$stack;return{field:vgField(dimensionChannelDef,{binSuffix:null!==(_model$stack=model.stack)&&void 0!==_model$stack&&_model$stack.impute?"mid":void 0,expr:"datum"})}}}}}}function getMarkGroup(model){let opt=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{fromPrefix:""};const {mark,markDef,encoding,config}=model;var JSCompiler_temp_const=markDef.clip;var JSCompiler_inline_result=
model.getScaleComponent("x");var yScale=model.getScaleComponent("y");JSCompiler_inline_result=null!==JSCompiler_inline_result&&void 0!==JSCompiler_inline_result&&JSCompiler_inline_result.get("selectionExtent")||null!==yScale&&void 0!==yScale&&yScale.get("selectionExtent")?!0:void 0;yScale=model.component.projection;JSCompiler_temp_const=getFirstDefined(JSCompiler_temp_const,JSCompiler_inline_result,yScale&&!yScale.isFit?!0:void 0);JSCompiler_inline_result=getStyles(markDef);yScale=encoding.key;const sort=
getSort(model);var JSCompiler_inline_result$jscomp$0;if(model.component.selection){for(var parentCount=JSCompiler_inline_result$jscomp$0=keys$jscomp$0(model.component.selection).length,parent=model.parent;parent&&0===parentCount;)parentCount=keys$jscomp$0(parent.component.selection).length,parent=parent.parent;JSCompiler_inline_result$jscomp$0=parentCount?{interactive:0<JSCompiler_inline_result$jscomp$0||!!model.encoding.tooltip}:null}else JSCompiler_inline_result$jscomp$0=null;parentCount=getMarkPropOrConfig("aria",
markDef,config);parent=markCompiler[mark].postEncodingTransform?markCompiler[mark].postEncodingTransform(model):null;return[Object.assign({},{name:model.getName("marks"),type:markCompiler[mark].vgMark},JSCompiler_temp_const?{clip:!0}:{},JSCompiler_inline_result?{style:JSCompiler_inline_result}:{},yScale?{key:yScale.field}:{},sort?{sort}:{},JSCompiler_inline_result$jscomp$0?JSCompiler_inline_result$jscomp$0:{},!1===parentCount?{aria:parentCount}:{},{from:{data:opt.fromPrefix+model.requestDataName(DataSourceType.Main)},
encode:{update:markCompiler[mark].encodeEntry(model)}},parent?{transform:parent}:{})]}function buildModel(spec,parent,parentGivenName,unitSize,config){if("facet"in spec)return new FacetModel(spec,parent,parentGivenName,config);if("layer"in spec)return new LayerModel(spec,parent,parentGivenName,unitSize,config);if(isUnitSpec(spec))return new UnitModel(spec,parent,parentGivenName,unitSize,config);if("vconcat"in spec||"hconcat"in spec||"concat"in spec)return new ConcatModel(spec,parent,parentGivenName,
config);throw Error(invalidSpec(spec));}function assembleTopLevelModel(model,topLevelProperties){var datasets=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};let usermeta=3<arguments.length?arguments[3]:void 0;const vgConfig=model.config?stripAndRedirectConfig(model.config):void 0;datasets=[].concat(model.assembleSelectionData([]),assembleRootData(model.component.data,datasets));const projections=model.assembleProjections(),title=model.assembleTitle(),style=model.assembleGroupStyle(),encodeEntry=
model.assembleGroupEncodeEntry(!0);let layoutSignals=model.assembleLayoutSignals();layoutSignals=layoutSignals.filter(signal=>"width"!==signal.name&&"height"!==signal.name||void 0===signal.value?!0:(topLevelProperties[signal.name]=+signal.value,!1));var $jscomp$destructuring$var143=Object.assign({},topLevelProperties);const params=topLevelProperties.params;$jscomp$destructuring$var143=(delete $jscomp$destructuring$var143.params,$jscomp$destructuring$var143);return Object.assign({},{$schema:"https://vega.github.io/schema/vega/v5.json"},
model.description?{description:model.description}:{},$jscomp$destructuring$var143,title?{title}:{},style?{style}:{},encodeEntry?{encode:{update:encodeEntry}}:{},{data:datasets},0<projections.length?{projections}:{},model.assembleGroup([...layoutSignals,...model.assembleSelectionTopLevelSignals([]),...assembleParameterSignals(params)]),vgConfig?{config:vgConfig}:{},usermeta?{usermeta}:{})}Array.prototype.flat||Object.defineProperty(Array.prototype,"flat",{configurable:!0,value:function r(JSCompiler_OptimizeArgumentsArray_p0){var t=
isNaN(JSCompiler_OptimizeArgumentsArray_p0)?1:Number(JSCompiler_OptimizeArgumentsArray_p0);return t?Array.prototype.reduce.call(this,function(a,e){return Array.isArray(e)?a.push.apply(a,r.call(e,t-1)):a.push(e),a},[]):Array.prototype.slice.call(this)},writable:!0});Array.prototype.flatMap||Object.defineProperty(Array.prototype,"flatMap",{configurable:!0,value:function(r){return Array.prototype.map.apply(this,arguments).flat()},writable:!0});var clone={exports:{}};(function(module){var clone$jscomp$0=
function(){function _instanceof(obj,type){return null!=type&&obj instanceof type}function clone(parent$jscomp$0,circular,depth$jscomp$0,prototype,includeNonEnumerable){function _clone(parent,depth){if(null===parent)return null;if(0===depth||"object"!=typeof parent)return parent;if(_instanceof(parent,nativeMap))var child=new nativeMap;else if(_instanceof(parent,nativeSet))child=new nativeSet;else if(_instanceof(parent,nativePromise))child=new nativePromise(function(resolve,reject){parent.then(function(value){resolve(_clone(value,
depth-1))},function(err){reject(_clone(err,depth-1))})});else if(clone.__isArray(parent))child=[];else if(clone.__isRegExp(parent))child=new RegExp(parent.source,__getRegExpFlags(parent)),parent.lastIndex&&(child.lastIndex=parent.lastIndex);else if(clone.__isDate(parent))child=new Date(parent.getTime());else{if(useBuffer&&Buffer.isBuffer(parent))return child=Buffer.allocUnsafe?Buffer.allocUnsafe(parent.length):new Buffer(parent.length),parent.copy(child),child;if(_instanceof(parent,Error))child=Object.create(parent);
else if("undefined"==typeof prototype){var proto=Object.getPrototypeOf(parent);child=Object.create(proto)}else child=Object.create(prototype),proto=prototype}if(circular){var index=allParents.indexOf(parent);if(-1!=index)return allChildren[index];allParents.push(parent);allChildren.push(child)}_instanceof(parent,nativeMap)&&parent.forEach(function(value,key){key=_clone(key,depth-1);value=_clone(value,depth-1);child.set(key,value)});_instanceof(parent,nativeSet)&&parent.forEach(function(value){value=
_clone(value,depth-1);child.add(value)});for(var i in parent){var attrs;proto&&(attrs=Object.getOwnPropertyDescriptor(proto,i));attrs&&null==attrs.set||(child[i]=_clone(parent[i],depth-1))}if(Object.getOwnPropertySymbols)for(index=Object.getOwnPropertySymbols(parent),i=0;i<index.length;i++)if(attrs=index[i],proto=Object.getOwnPropertyDescriptor(parent,attrs),!proto||proto.enumerable||includeNonEnumerable)child[attrs]=_clone(parent[attrs],depth-1),proto.enumerable||Object.defineProperty(child,attrs,
{enumerable:!1});if(includeNonEnumerable)for(index=Object.getOwnPropertyNames(parent),i=0;i<index.length;i++)attrs=index[i],proto=Object.getOwnPropertyDescriptor(parent,attrs),proto&&proto.enumerable||(child[attrs]=_clone(parent[attrs],depth-1),Object.defineProperty(child,attrs,{enumerable:!1}));return child}"object"===typeof circular&&(depth$jscomp$0=circular.depth,prototype=circular.prototype,includeNonEnumerable=circular.includeNonEnumerable,circular=circular.circular);var allParents=[],allChildren=
[],useBuffer="undefined"!=typeof Buffer;"undefined"==typeof circular&&(circular=!0);"undefined"==typeof depth$jscomp$0&&(depth$jscomp$0=Infinity);return _clone(parent$jscomp$0,depth$jscomp$0)}function __objToStr(o){return Object.prototype.toString.call(o)}function __getRegExpFlags(re){var flags="";re.global&&(flags+="g");re.ignoreCase&&(flags+="i");re.multiline&&(flags+="m");return flags}try{var nativeMap=Map}catch(_){nativeMap=function(){}}try{var nativeSet=Set}catch(_){nativeSet=function(){}}try{var nativePromise=
Promise}catch(_){nativePromise=function(){}}clone.clonePrototype=function(parent){if(null===parent)return null;var c=function(){};c.prototype=parent;return new c};clone.__objToStr=__objToStr;clone.__isDate=function(o){return"object"===typeof o&&"[object Date]"===__objToStr(o)};clone.__isArray=function(o){return"object"===typeof o&&"[object Array]"===__objToStr(o)};clone.__isRegExp=function(o){return"object"===typeof o&&"[object RegExp]"===__objToStr(o)};clone.__getRegExpFlags=__getRegExpFlags;return clone}();
module.exports&&(module.exports=clone$jscomp$0)})(clone);var fastJsonStableStringify=function(data,opts){opts||(opts={});"function"===typeof opts&&(opts={cmp:opts});var cycles="boolean"===typeof opts.cycles?opts.cycles:!1,cmp=opts.cmp&&function(f){return function(node){return function(a,b){return f({key:a,value:node[a]},{key:b,value:node[b]})}}}(opts.cmp),seen=[];return function stringify(node){node&&node.toJSON&&"function"===typeof node.toJSON&&(node=node.toJSON());if(void 0!==node){if("number"==
typeof node)return isFinite(node)?""+node:"null";if("object"!==typeof node)return JSON.stringify(node);var i;if(Array.isArray(node)){var out="[";for(i=0;i<node.length;i++)i&&(out+=","),out+=stringify(node[i])||"null";return out+"]"}if(null===node)return"null";if(-1!==seen.indexOf(node)){if(cycles)return JSON.stringify("__cycle__");throw new TypeError("Converting circular structure to JSON");}var seenIndex=seen.push(node)-1,keys=Object.keys(node).sort(cmp&&cmp(node));out="";for(i=0;i<keys.length;i++){var key=
keys[i],value=stringify(node[key]);value&&(out&&(out+=","),out+=JSON.stringify(key)+":"+value)}seen.splice(seenIndex,1);return"{"+out+"}"}}(data)};const deepEqual=function equal(a,b){if(a===b)return!0;if(a&&b&&"object"==typeof a&&"object"==typeof b){if(a.constructor!==b.constructor)return!1;var i;if(Array.isArray(a)){var length=a.length;if(length!=b.length)return!1;for(i=length;0!==i--;)if(!equal(a[i],b[i]))return!1;return!0}if(a.constructor===RegExp)return a.source===b.source&&a.flags===b.flags;
if(a.valueOf!==Object.prototype.valueOf)return a.valueOf()===b.valueOf();if(a.toString!==Object.prototype.toString)return a.toString()===b.toString();var keys=Object.keys(a);length=keys.length;if(length!==Object.keys(b).length)return!1;for(i=length;0!==i--;)if(!Object.prototype.hasOwnProperty.call(b,keys[i]))return!1;for(i=length;0!==i--;)if(length=keys[i],!equal(a[length],b[length]))return!1;return!0}return a!==a&&b!==b},duplicate=clone.exports;Set.prototype.toJSON=function(){return"Set(".concat([...this].map(x=>
fastJsonStableStringify(x)).join(","),")")};const stringify=fastJsonStableStringify,keys$jscomp$0=Object.keys,vals$jscomp$0=Object.values,entries$1=Object.entries;let idCounter=42;const POLAR_POSITION_CHANNEL_INDEX={theta:1,theta2:1,radius:1,radius2:1},GEO_POSIITON_CHANNEL_INDEX={longitude:1,longitude2:1,latitude:1,latitude2:1},GEOPOSITION_CHANNELS=keys$jscomp$0(GEO_POSIITON_CHANNEL_INDEX),UNIT_CHANNEL_INDEX=Object.assign({},{x:1,y:1,x2:1,y2:1},POLAR_POSITION_CHANNEL_INDEX,GEO_POSIITON_CHANNEL_INDEX,
{xOffset:1,yOffset:1,color:1,fill:1,stroke:1,opacity:1,fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeDash:1,size:1,angle:1,shape:1,order:1,text:1,detail:1,key:1,tooltip:1,href:1,url:1,description:1}),FACET_CHANNEL_INDEX={row:1,column:1,facet:1},FACET_CHANNELS=keys$jscomp$0(FACET_CHANNEL_INDEX),CHANNEL_INDEX=Object.assign({},UNIT_CHANNEL_INDEX,FACET_CHANNEL_INDEX),CHANNELS=keys$jscomp$0(CHANNEL_INDEX);var $jscomp$destructuring$var3=Object.assign({},CHANNEL_INDEX),$jscomp$destructuring$var4=(delete $jscomp$destructuring$var3.order,
delete $jscomp$destructuring$var3.detail,delete $jscomp$destructuring$var3.tooltip,$jscomp$destructuring$var3),$jscomp$destructuring$var5=Object.assign({},$jscomp$destructuring$var4);const SINGLE_DEF_UNIT_CHANNEL_INDEX=(delete $jscomp$destructuring$var5.row,delete $jscomp$destructuring$var5.column,delete $jscomp$destructuring$var5.facet,$jscomp$destructuring$var5),SECONDARY_RANGE_CHANNEL="x2 y2 latitude2 longitude2 theta2 radius2".split(" "),UNIT_CHANNELS=keys$jscomp$0(UNIT_CHANNEL_INDEX);var $jscomp$destructuring$var7=
Object.assign({},UNIT_CHANNEL_INDEX);const NONPOSITION_CHANNEL_INDEX=(delete $jscomp$destructuring$var7.x,delete $jscomp$destructuring$var7.y,delete $jscomp$destructuring$var7.x2,delete $jscomp$destructuring$var7.y2,delete $jscomp$destructuring$var7.xOffset,delete $jscomp$destructuring$var7.yOffset,delete $jscomp$destructuring$var7.latitude,delete $jscomp$destructuring$var7.longitude,delete $jscomp$destructuring$var7.latitude2,delete $jscomp$destructuring$var7.longitude2,delete $jscomp$destructuring$var7.theta,
delete $jscomp$destructuring$var7.theta2,delete $jscomp$destructuring$var7.radius,delete $jscomp$destructuring$var7.radius2,$jscomp$destructuring$var7),NONPOSITION_CHANNELS=keys$jscomp$0(NONPOSITION_CHANNEL_INDEX),POSITION_SCALE_CHANNEL_INDEX={x:1,y:1},POSITION_SCALE_CHANNELS=keys$jscomp$0(POSITION_SCALE_CHANNEL_INDEX),POLAR_POSITION_SCALE_CHANNEL_INDEX={theta:1,radius:1},POLAR_POSITION_SCALE_CHANNELS=keys$jscomp$0(POLAR_POSITION_SCALE_CHANNEL_INDEX),OFFSET_SCALE_CHANNEL_INDEX={xOffset:1,yOffset:1};
var $jscomp$destructuring$var9=Object.assign({},NONPOSITION_CHANNEL_INDEX);const NONPOSITION_SCALE_CHANNEL_INDEX=(delete $jscomp$destructuring$var9.text,delete $jscomp$destructuring$var9.tooltip,delete $jscomp$destructuring$var9.href,delete $jscomp$destructuring$var9.url,delete $jscomp$destructuring$var9.description,delete $jscomp$destructuring$var9.detail,delete $jscomp$destructuring$var9.key,delete $jscomp$destructuring$var9.order,$jscomp$destructuring$var9),NONPOSITION_SCALE_CHANNELS=keys$jscomp$0(NONPOSITION_SCALE_CHANNEL_INDEX),
SCALE_CHANNEL_INDEX=Object.assign({},POSITION_SCALE_CHANNEL_INDEX,POLAR_POSITION_SCALE_CHANNEL_INDEX,OFFSET_SCALE_CHANNEL_INDEX,NONPOSITION_SCALE_CHANNEL_INDEX),SCALE_CHANNELS=keys$jscomp$0(SCALE_CHANNEL_INDEX),ALL_MARKS={arc:"always",area:"always",bar:"always",circle:"always",geoshape:"always",image:"always",line:"always",rule:"always",point:"always",rect:"always",square:"always",trail:"always",text:"always",tick:"always"};var $jscomp$destructuring$var11=Object.assign({},ALL_MARKS);const ALL_MARKS_EXCEPT_GEOSHAPE=
(delete $jscomp$destructuring$var11.geoshape,$jscomp$destructuring$var11),AGGREGATE_OP_INDEX={argmax:1,argmin:1,average:1,count:1,distinct:1,product:1,max:1,mean:1,median:1,min:1,missing:1,q1:1,q3:1,ci0:1,ci1:1,stderr:1,stdev:1,stdevp:1,sum:1,valid:1,values:1,variance:1,variancep:1},MULTIDOMAIN_SORT_OP_INDEX={count:1,min:1,max:1},COUNTING_OPS=new Set(["count","valid","missing","distinct"]),SUM_OPS=new Set(["count","sum","distinct","valid","missing"]),SHARED_DOMAIN_OPS=new Set("mean average median q1 q3 min max".split(" ")),
VG_MARK_CONFIGS=keys$jscomp$0({aria:1,description:1,ariaRole:1,ariaRoleDescription:1,blend:1,opacity:1,fill:1,fillOpacity:1,stroke:1,strokeCap:1,strokeWidth:1,strokeOpacity:1,strokeDash:1,strokeDashOffset:1,strokeJoin:1,strokeOffset:1,strokeMiterLimit:1,startAngle:1,endAngle:1,padAngle:1,innerRadius:1,outerRadius:1,size:1,shape:1,interpolate:1,tension:1,orient:1,align:1,baseline:1,text:1,dir:1,dx:1,dy:1,ellipsis:1,limit:1,radius:1,theta:1,angle:1,font:1,fontSize:1,fontWeight:1,fontStyle:1,lineBreak:1,
lineHeight:1,cursor:1,href:1,tooltip:1,cornerRadius:1,cornerRadiusTopLeft:1,cornerRadiusTopRight:1,cornerRadiusBottomLeft:1,cornerRadiusBottomRight:1,aspect:1,width:1,height:1,url:1,smooth:1}),VG_MARK_INDEX={arc:1,area:1,group:1,image:1,line:1,path:1,rect:1,rule:1,shape:1,symbol:1,text:1,trail:1},VG_CORNERRADIUS_CHANNELS=["cornerRadius","cornerRadiusTopLeft","cornerRadiusTopRight","cornerRadiusBottomLeft","cornerRadiusBottomRight"],main=vega.logger(vega.Warn);let current=main;const MONTHS="january february march april may june july august september october november december".split(" "),
SHORT_MONTHS=MONTHS.map(m=>m.substr(0,3)),DAYS="sunday monday tuesday wednesday thursday friday saturday".split(" "),SHORT_DAYS=DAYS.map(d=>d.substr(0,3)),LOCAL_SINGLE_TIMEUNIT_INDEX={year:1,quarter:1,month:1,week:1,day:1,dayofyear:1,date:1,hours:1,minutes:1,seconds:1,milliseconds:1},TIMEUNIT_PARTS=keys$jscomp$0(LOCAL_SINGLE_TIMEUNIT_INDEX),VEGALITE_TIMEFORMAT={"year-month":"%b %Y ","year-month-date":"%b %d, %Y "},ScaleType={LINEAR:"linear",LOG:"log",POW:"pow",SQRT:"sqrt",SYMLOG:"symlog",IDENTITY:"identity",
SEQUENTIAL:"sequential",TIME:"time",UTC:"utc",QUANTILE:"quantile",QUANTIZE:"quantize",THRESHOLD:"threshold",BIN_ORDINAL:"bin-ordinal",ORDINAL:"ordinal",POINT:"point",BAND:"band"},SCALE_CATEGORY_INDEX={linear:"numeric",log:"numeric",pow:"numeric",sqrt:"numeric",symlog:"numeric",identity:"numeric",sequential:"numeric",time:"time",utc:"time",ordinal:"ordinal","bin-ordinal":"bin-ordinal",point:"ordinal-position",band:"ordinal-position",quantile:"discretizing",quantize:"discretizing",threshold:"discretizing"},
SCALE_PRECEDENCE_INDEX={linear:0,log:1,pow:1,sqrt:1,symlog:1,identity:1,sequential:1,time:0,utc:0,point:10,band:11,ordinal:0,"bin-ordinal":0,quantile:0,quantize:0,threshold:0},QUANTITATIVE_SCALES=new Set(["linear","log","pow","sqrt","symlog"]),CONTINUOUS_TO_CONTINUOUS_SCALES=new Set([...QUANTITATIVE_SCALES,"time","utc"]),CONTINUOUS_TO_DISCRETE_SCALES=new Set(["quantile","quantize","threshold"]),CONTINUOUS_DOMAIN_SCALES=new Set([...CONTINUOUS_TO_CONTINUOUS_SCALES,...CONTINUOUS_TO_DISCRETE_SCALES,"sequential",
"identity"]),DISCRETE_DOMAIN_SCALES=new Set(["ordinal","bin-ordinal","point","band"]);var $jscomp$destructuring$var23=Object.assign({},{type:1,domain:1,domainMax:1,domainMin:1,domainMid:1,align:1,range:1,rangeMax:1,rangeMin:1,scheme:1,bins:1,reverse:1,round:1,clamp:1,nice:1,base:1,exponent:1,constant:1,interpolate:1,zero:1,padding:1,paddingInner:1,paddingOuter:1});const NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX=(delete $jscomp$destructuring$var23.type,delete $jscomp$destructuring$var23.domain,
delete $jscomp$destructuring$var23.range,delete $jscomp$destructuring$var23.rangeMax,delete $jscomp$destructuring$var23.rangeMin,delete $jscomp$destructuring$var23.scheme,$jscomp$destructuring$var23),NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES=keys$jscomp$0(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX),Mark={arc:"arc",area:"area",bar:"bar",image:"image",line:"line",point:"point",rect:"rect",rule:"rule",text:"text",tick:"tick",trail:"trail",circle:"circle",square:"square",geoshape:"geoshape"},ARC=
Mark.arc,AREA=Mark.area,BAR=Mark.bar,IMAGE=Mark.image,LINE=Mark.line,POINT=Mark.point,RECT=Mark.rect,RULE=Mark.rule,TEXT=Mark.text,TICK=Mark.tick,TRAIL=Mark.trail,CIRCLE=Mark.circle,SQUARE=Mark.square,GEOSHAPE=Mark.geoshape,PRIMITIVE_MARKS=new Set(keys$jscomp$0(Mark)),FILL_STROKE_CONFIG="stroke strokeWidth strokeDash strokeDashOffset strokeOpacity strokeJoin strokeMiterLimit fill fillOpacity".split(" "),VL_ONLY_MARK_CONFIG_PROPERTIES=keys$jscomp$0({color:1,filled:1,invalid:1,order:1,radius2:1,theta2:1,
timeUnitBandSize:1,timeUnitBandPosition:1}),MARK_CONFIGS=keys$jscomp$0({mark:1,arc:1,area:1,bar:1,circle:1,image:1,line:1,point:1,rect:1,rule:1,square:1,text:1,tick:1,trail:1,geoshape:1}),BAR_CORNER_RADIUS_INDEX={horizontal:["cornerRadiusTopRight","cornerRadiusBottomRight"],vertical:["cornerRadiusTopLeft","cornerRadiusTopRight"]},SORT_BY_CHANNEL_INDEX={x:1,y:1,color:1,fill:1,stroke:1,strokeWidth:1,size:1,shape:1,fillOpacity:1,strokeOpacity:1,opacity:1,text:1},defaultTitleFormatter=(fieldDef,config)=>
{switch(config.fieldTitle){case "plain":return fieldDef.field;case "functional":{const {aggregate,bin,timeUnit,field}=fieldDef;isArgmaxDef(aggregate)?fieldDef="".concat(field," for argmax(").concat(aggregate.argmax,")"):isArgminDef(aggregate)?fieldDef="".concat(field," for argmin(").concat(aggregate.argmin,")"):(fieldDef=normalizeTimeUnit(timeUnit),fieldDef=(fieldDef=aggregate||(null===fieldDef||void 0===fieldDef?void 0:fieldDef.unit)||(null===fieldDef||void 0===fieldDef?void 0:fieldDef.maxbins)&&
"timeunit"||isBinning(bin)&&"bin")?"".concat(fieldDef.toUpperCase(),"(").concat(field,")"):field)}return fieldDef;default:return verbalTitleFormatter(fieldDef,config)}};let titleFormatter=defaultTitleFormatter;const COMPATIBLE={compatible:!0},CONDITIONAL_AXIS_PROP_INDEX={labelAlign:{part:"labels",vgProp:"align"},labelBaseline:{part:"labels",vgProp:"baseline"},labelColor:{part:"labels",vgProp:"fill"},labelFont:{part:"labels",vgProp:"font"},labelFontSize:{part:"labels",vgProp:"fontSize"},labelFontStyle:{part:"labels",
vgProp:"fontStyle"},labelFontWeight:{part:"labels",vgProp:"fontWeight"},labelOpacity:{part:"labels",vgProp:"opacity"},labelOffset:null,labelPadding:null,gridColor:{part:"grid",vgProp:"stroke"},gridDash:{part:"grid",vgProp:"strokeDash"},gridDashOffset:{part:"grid",vgProp:"strokeDashOffset"},gridOpacity:{part:"grid",vgProp:"opacity"},gridWidth:{part:"grid",vgProp:"strokeWidth"},tickColor:{part:"ticks",vgProp:"stroke"},tickDash:{part:"ticks",vgProp:"strokeDash"},tickDashOffset:{part:"ticks",vgProp:"strokeDashOffset"},
tickOpacity:{part:"ticks",vgProp:"opacity"},tickSize:null,tickWidth:{part:"ticks",vgProp:"strokeWidth"}},AXIS_PARTS=["domain","grid","labels","ticks","title"],AXIS_PROPERTY_TYPE={grid:"grid",gridCap:"grid",gridColor:"grid",gridDash:"grid",gridDashOffset:"grid",gridOpacity:"grid",gridScale:"grid",gridWidth:"grid",orient:"main",bandPosition:"both",aria:"main",description:"main",domain:"main",domainCap:"main",domainColor:"main",domainDash:"main",domainDashOffset:"main",domainOpacity:"main",domainWidth:"main",
format:"main",formatType:"main",labelAlign:"main",labelAngle:"main",labelBaseline:"main",labelBound:"main",labelColor:"main",labelFlush:"main",labelFlushOffset:"main",labelFont:"main",labelFontSize:"main",labelFontStyle:"main",labelFontWeight:"main",labelLimit:"main",labelLineHeight:"main",labelOffset:"main",labelOpacity:"main",labelOverlap:"main",labelPadding:"main",labels:"main",labelSeparation:"main",maxExtent:"main",minExtent:"main",offset:"both",position:"main",tickCap:"main",tickColor:"main",
tickDash:"main",tickDashOffset:"main",tickMinStep:"both",tickOffset:"both",tickOpacity:"main",tickRound:"both",ticks:"main",tickSize:"main",tickWidth:"both",title:"main",titleAlign:"main",titleAnchor:"main",titleAngle:"main",titleBaseline:"main",titleColor:"main",titleFont:"main",titleFontSize:"main",titleFontStyle:"main",titleFontWeight:"main",titleLimit:"main",titleLineHeight:"main",titleOpacity:"main",titlePadding:"main",titleX:"main",titleY:"main",encode:"both",scale:"both",tickBand:"both",tickCount:"both",
tickExtra:"both",translate:"both",values:"both",zindex:"both"},COMMON_AXIS_PROPERTIES_INDEX={orient:1,aria:1,bandPosition:1,description:1,domain:1,domainCap:1,domainColor:1,domainDash:1,domainDashOffset:1,domainOpacity:1,domainWidth:1,format:1,formatType:1,grid:1,gridCap:1,gridColor:1,gridDash:1,gridDashOffset:1,gridOpacity:1,gridWidth:1,labelAlign:1,labelAngle:1,labelBaseline:1,labelBound:1,labelColor:1,labelFlush:1,labelFlushOffset:1,labelFont:1,labelFontSize:1,labelFontStyle:1,labelFontWeight:1,
labelLimit:1,labelLineHeight:1,labelOffset:1,labelOpacity:1,labelOverlap:1,labelPadding:1,labels:1,labelSeparation:1,maxExtent:1,minExtent:1,offset:1,position:1,tickBand:1,tickCap:1,tickColor:1,tickCount:1,tickDash:1,tickDashOffset:1,tickExtra:1,tickMinStep:1,tickOffset:1,tickOpacity:1,tickRound:1,ticks:1,tickSize:1,tickWidth:1,title:1,titleAlign:1,titleAnchor:1,titleAngle:1,titleBaseline:1,titleColor:1,titleFont:1,titleFontSize:1,titleFontStyle:1,titleFontWeight:1,titleLimit:1,titleLineHeight:1,
titleOpacity:1,titlePadding:1,titleX:1,titleY:1,translate:1,values:1,zindex:1},AXIS_PROPERTIES_INDEX=Object.assign({},COMMON_AXIS_PROPERTIES_INDEX,{style:1,labelExpr:1,encoding:1}),AXIS_CONFIGS=keys$jscomp$0({axis:1,axisBand:1,axisBottom:1,axisDiscrete:1,axisLeft:1,axisPoint:1,axisQuantitative:1,axisRight:1,axisTemporal:1,axisTop:1,axisX:1,axisXBand:1,axisXDiscrete:1,axisXPoint:1,axisXQuantitative:1,axisXTemporal:1,axisY:1,axisYBand:1,axisYDiscrete:1,axisYPoint:1,axisYQuantitative:1,axisYTemporal:1});
class CompositeMarkNormalizer{constructor(name,run){this.name=name;this.run=run}hasMatchingType(spec){return isUnitSpec(spec)?(spec=spec.mark,(isMarkDef(spec)?spec.type:spec)===this.name):!1}}const boxPlotNormalizer=new CompositeMarkNormalizer("boxplot",normalizeBoxPlot),errorBarNormalizer=new CompositeMarkNormalizer("errorbar",normalizeErrorBar),errorBandNormalizer=new CompositeMarkNormalizer("errorband",normalizeErrorBand),compositeMarkRegistry={};add$jscomp$0("boxplot",normalizeBoxPlot,["box",
"median","outliers","rule","ticks"]);add$jscomp$0("errorbar",normalizeErrorBar,["ticks","rule"]);add$jscomp$0("errorband",normalizeErrorBand,["band","borders"]);const VL_ONLY_LEGEND_CONFIG=["gradientHorizontalMaxLength","gradientHorizontalMinLength","gradientVerticalMaxLength","gradientVerticalMinLength","unselectedOpacity"],HEADER_TITLE_PROPERTIES_MAP={titleAlign:"align",titleAnchor:"anchor",titleAngle:"angle",titleBaseline:"baseline",titleColor:"color",titleFont:"font",titleFontSize:"fontSize",
titleFontStyle:"fontStyle",titleFontWeight:"fontWeight",titleLimit:"limit",titleLineHeight:"lineHeight",titleOrient:"orient",titlePadding:"offset"},HEADER_LABEL_PROPERTIES_MAP={labelAlign:"align",labelAnchor:"anchor",labelAngle:"angle",labelBaseline:"baseline",labelColor:"color",labelFont:"font",labelFontSize:"fontSize",labelFontStyle:"fontStyle",labelFontWeight:"fontWeight",labelLimit:"limit",labelLineHeight:"lineHeight",labelOrient:"orient",labelPadding:"offset"},HEADER_TITLE_PROPERTIES=keys$jscomp$0(HEADER_TITLE_PROPERTIES_MAP),
HEADER_LABEL_PROPERTIES=keys$jscomp$0(HEADER_LABEL_PROPERTIES_MAP),HEADER_CONFIGS=keys$jscomp$0({header:1,headerRow:1,headerColumn:1,headerFacet:1}),LEGEND_SCALE_CHANNELS="size shape fill stroke strokeDash strokeWidth opacity".split(" "),TOP_LEVEL_PROPERTIES=["background","padding"],COMPOSITION_LAYOUT_PROPERTIES=keys$jscomp$0({align:1,bounds:1,center:1,columns:1,spacing:1}),defaultConfig={background:"white",padding:5,timeFormat:"%b %d, %Y",countTitle:"Count of Records",view:{continuousWidth:200,continuousHeight:200,
step:20},mark:{color:"#4c78a8",invalid:"filter",timeUnitBandSize:1},arc:{},area:{},bar:{binSpacing:1,continuousBandSize:5,timeUnitBandPosition:.5},circle:{},geoshape:{},image:{},line:{},point:{},rect:{binSpacing:0,continuousBandSize:5,timeUnitBandPosition:.5},rule:{color:"black"},square:{},text:{color:"black"},tick:{thickness:1},trail:{},boxplot:{size:14,extent:1.5,box:{},median:{color:"white"},outliers:{},rule:{},ticks:null},errorbar:{center:"mean",rule:!0,ticks:!1},errorband:{band:{opacity:.3},
borders:!1},scale:{pointPadding:.5,barBandPaddingInner:.1,rectBandPaddingInner:0,bandWithNestedOffsetPaddingInner:.2,bandWithNestedOffsetPaddingOuter:.2,minBandSize:2,minFontSize:8,maxFontSize:40,minOpacity:.3,maxOpacity:.8,minSize:9,minStrokeWidth:1,maxStrokeWidth:4,quantileCount:4,quantizeCount:4},projection:{},legend:{gradientHorizontalMaxLength:200,gradientHorizontalMinLength:100,gradientVerticalMaxLength:200,gradientVerticalMinLength:64,unselectedOpacity:.35},header:{titlePadding:10,labelPadding:10},
headerColumn:{},headerRow:{},headerFacet:{},selection:{point:{on:"click",fields:["_vgsid_"],toggle:"event.shiftKey",resolve:"global",clear:"dblclick"},interval:{on:"[mousedown, window:mouseup] \x3e window:mousemove!",encodings:["x","y"],translate:"[mousedown, window:mouseup] \x3e window:mousemove!",zoom:"wheel!",mark:{fill:"#333",fillOpacity:.125,stroke:"white"},resolve:"global",clear:"dblclick"}},style:{},title:{},facet:{spacing:20},concat:{spacing:20}},tab10="#4c78a8 #f58518 #e45756 #72b7b2 #54a24b #eeca3b #b279a2 #ff9da6 #9d755d #bab0ac".split(" "),
DEFAULT_FONT_SIZE={text:11,guideLabel:10,guideTitle:11,groupTitle:13,groupSubtitle:12},DEFAULT_COLOR={blue:tab10[0],orange:tab10[1],red:tab10[2],teal:tab10[3],green:tab10[4],yellow:tab10[5],purple:tab10[6],pink:tab10[7],brown:tab10[8],gray0:"#000",gray1:"#111",gray2:"#222",gray3:"#333",gray4:"#444",gray5:"#555",gray6:"#666",gray7:"#777",gray8:"#888",gray9:"#999",gray10:"#aaa",gray11:"#bbb",gray12:"#ccc",gray13:"#ddd",gray14:"#eee",gray15:"#fff"},configPropsWithExpr=[...MARK_CONFIGS,...AXIS_CONFIGS,
...HEADER_CONFIGS,"background","padding","legend","lineBreak","scale","style","title","view"],MARK_STYLES=new Set(["view",...PRIMITIVE_MARKS]),VL_ONLY_CONFIG_PROPERTIES="color fontSize background padding facet concat numberFormat timeFormat countTitle header axisQuantitative axisTemporal axisDiscrete axisPoint axisXBand axisXPoint axisXDiscrete axisXQuantitative axisXTemporal axisYBand axisYPoint axisYDiscrete axisYQuantitative axisYTemporal scale selection overlay".split(" "),VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX=
Object.assign({},{view:["continuousWidth","continuousHeight","discreteWidth","discreteHeight","step"]},{area:["line","point"],bar:["binSpacing","continuousBandSize","discreteBandSize"],rect:["binSpacing","continuousBandSize","discreteBandSize"],line:["point"],tick:["bandSize","thickness"]});class SpecMapper{map(spec,params){return"facet"in spec?this.mapFacet(spec,params):"repeat"in spec?this.mapRepeat(spec,params):"hconcat"in spec?this.mapHConcat(spec,params):"vconcat"in spec?this.mapVConcat(spec,
params):"concat"in spec?this.mapConcat(spec,params):this.mapLayerOrUnit(spec,params)}mapLayerOrUnit(spec,params){if("layer"in spec)return this.mapLayer(spec,params);if(isUnitSpec(spec))return this.mapUnit(spec,params);throw Error(invalidSpec(spec));}mapLayer(spec,params){return Object.assign({},spec,{layer:spec.layer.map(subspec=>this.mapLayerOrUnit(subspec,params))})}mapHConcat(spec,params){return Object.assign({},spec,{hconcat:spec.hconcat.map(subspec=>this.map(subspec,params))})}mapVConcat(spec,
params){return Object.assign({},spec,{vconcat:spec.vconcat.map(subspec=>this.map(subspec,params))})}mapConcat(spec,params){var $jscomp$destructuring$var58=Object.assign({},spec);spec=spec.concat;$jscomp$destructuring$var58=(delete $jscomp$destructuring$var58.concat,$jscomp$destructuring$var58);return Object.assign({},$jscomp$destructuring$var58,{concat:spec.map(subspec=>this.map(subspec,params))})}mapFacet(spec,params){return Object.assign({},spec,{spec:this.map(spec.spec,params)})}mapRepeat(spec,
params){return Object.assign({},spec,{spec:this.map(spec.spec,params)})}}const STACK_OFFSET_INDEX={zero:1,center:1,normalize:1},STACKABLE_MARKS=new Set([ARC,BAR,AREA,RULE,POINT,CIRCLE,SQUARE,LINE,TEXT,TICK]),STACK_BY_DEFAULT_MARKS=new Set([BAR,AREA,ARC]);class PathOverlayNormalizer{constructor(){_defineProperty(this,"name","path-overlay")}hasMatchingType(spec,config){if(isUnitSpec(spec)){const {mark,encoding}=spec;spec=isMarkDef(mark)?mark:{type:mark};switch(spec.type){case "line":case "rule":case "trail":return!!getPointOverlay(spec,
config[spec.type],encoding);case "area":return!!getPointOverlay(spec,config[spec.type],encoding)||!!getLineOverlay(spec,config[spec.type])}}return!1}run(spec,normParams,normalize){var {config}=normParams,$jscomp$destructuring$var62=Object.assign({},spec),params=spec.params,projection=spec.projection,mark$jscomp$0=spec.mark;spec=spec.encoding;$jscomp$destructuring$var62=(delete $jscomp$destructuring$var62.params,delete $jscomp$destructuring$var62.projection,delete $jscomp$destructuring$var62.mark,
delete $jscomp$destructuring$var62.encoding,$jscomp$destructuring$var62);spec=normalizeEncoding(spec,config);mark$jscomp$0=isMarkDef(mark$jscomp$0)?mark$jscomp$0:{type:mark$jscomp$0};const pointOverlay=getPointOverlay(mark$jscomp$0,config[mark$jscomp$0.type],spec),lineOverlay="area"===mark$jscomp$0.type&&getLineOverlay(mark$jscomp$0,config[mark$jscomp$0.type]);var JSCompiler_temp_const=Object,JSCompiler_temp_const$jscomp$0=JSCompiler_temp_const.assign;var JSCompiler_inline_result=Object.assign({},
"area"===mark$jscomp$0.type&&void 0===mark$jscomp$0.opacity&&void 0===mark$jscomp$0.fillOpacity?{opacity:.7}:{},mark$jscomp$0);JSCompiler_inline_result=Object.assign({},JSCompiler_inline_result);JSCompiler_inline_result=(delete JSCompiler_inline_result.point,delete JSCompiler_inline_result.line,JSCompiler_inline_result);JSCompiler_inline_result=1<keys$jscomp$0(JSCompiler_inline_result).length?JSCompiler_inline_result:JSCompiler_inline_result.type;params=[JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const,
{},params?{params}:{},{mark:JSCompiler_inline_result,encoding:omit(spec,["shape"])})];JSCompiler_temp_const=stack$jscomp$1(mark$jscomp$0,spec);JSCompiler_temp_const$jscomp$0=spec;if(JSCompiler_temp_const){const {fieldChannel:stackFieldChannel,offset}=JSCompiler_temp_const;JSCompiler_temp_const$jscomp$0=Object.assign({},spec,{[stackFieldChannel]:Object.assign({},spec[stackFieldChannel],offset?{stack:offset}:{})})}lineOverlay&&params.push(Object.assign({},projection?{projection}:{},{mark:Object.assign({},
{type:"line"},pick(mark$jscomp$0,["clip","interpolate","tension","tooltip"]),lineOverlay),encoding:JSCompiler_temp_const$jscomp$0}));pointOverlay&&params.push(Object.assign({},projection?{projection}:{},{mark:Object.assign({},{type:"point",opacity:1,filled:!0},pick(mark$jscomp$0,["clip","tooltip"]),pointOverlay),encoding:JSCompiler_temp_const$jscomp$0}));projection=Object.assign({},$jscomp$destructuring$var62,{layer:params});$jscomp$destructuring$var62=Object;params=$jscomp$destructuring$var62.assign;
for(const mark of["line","area","rule","trail"])config[mark]&&(config=Object.assign({},config,{[mark]:omit(config[mark],["point","line"])}));return normalize(projection,params.call($jscomp$destructuring$var62,{},normParams,{config}))}}class RuleForRangedLineNormalizer{constructor(){_defineProperty(this,"name","RuleForRangedLine")}hasMatchingType(spec){if(isUnitSpec(spec)){const {encoding,mark}=spec;if("line"===mark||isMarkDef(mark)&&"line"===mark.type)for(const channel of SECONDARY_RANGE_CHANNEL)if(spec=
getMainRangeChannel(channel),spec=encoding[spec],encoding[channel]&&(isFieldDef(spec)&&!isBinned(spec.bin)||isDatumDef(spec)))return!0}return!1}run(spec,params,normalize){const {encoding,mark}=spec;var JSCompiler_inline_result=!!encoding.x2;JSCompiler_inline_result="Line mark is for continuous lines and thus cannot be used with ".concat(JSCompiler_inline_result&&encoding.y2?"x2 and y2":JSCompiler_inline_result?"x2":"y2",". We will use the rule mark (line segments) instead.");warn(JSCompiler_inline_result);
return normalize(Object.assign({},spec,{mark:vega.isObject(mark)?Object.assign({},mark,{type:"rule"}):"rule"}),params)}}class CoreNormalizer extends SpecMapper{constructor(){super(...arguments);_defineProperty(this,"nonFacetUnitNormalizers",[boxPlotNormalizer,errorBarNormalizer,errorBandNormalizer,new PathOverlayNormalizer,new RuleForRangedLineNormalizer])}map(spec,params){if(isUnitSpec(spec)){const hasRow=channelHasField(spec.encoding,"row"),hasColumn=channelHasField(spec.encoding,"column"),hasFacet=
channelHasField(spec.encoding,"facet");if(hasRow||hasColumn||hasFacet)return this.mapFacetedUnit(spec,params)}return super.map(spec,params)}mapUnit(spec,params){const {parentEncoding,parentProjection}=params;var encoding=replaceRepeaterInEncoding(spec.encoding,params.repeater);spec=Object.assign({},spec,encoding?{encoding}:{});if(parentEncoding||parentProjection)return this.mapUnitWithParentEncodingOrProjection(spec,params);encoding=this.mapLayerOrUnit.bind(this);for(const unitNormalizer of this.nonFacetUnitNormalizers)if(unitNormalizer.hasMatchingType(spec,
params.config))return unitNormalizer.run(spec,params,encoding);return spec}mapRepeat(spec,params){return!vega.isArray(spec.repeat)&&spec.repeat.layer?this.mapLayerRepeat(spec,params):this.mapNonLayerRepeat(spec,params)}mapLayerRepeat(spec,params){var $jscomp$destructuring$var66=Object.assign({},spec);const repeat=spec.repeat,childSpec=spec.spec;$jscomp$destructuring$var66=(delete $jscomp$destructuring$var66.repeat,delete $jscomp$destructuring$var66.spec,$jscomp$destructuring$var66);const {row,column,
layer}=repeat,{repeater={},repeaterPrefix=""}=params;return row||column?this.mapRepeat(Object.assign({},spec,{repeat:Object.assign({},row?{row}:{},column?{column}:{}),spec:{repeat:{layer},spec:childSpec}}),params):Object.assign({},$jscomp$destructuring$var66,{layer:layer.map(layerValue=>{var childRepeater=Object.assign({},repeater,{layer:layerValue});layerValue="".concat((childSpec.name||"")+repeaterPrefix,"child__layer_").concat(varName(layerValue));childRepeater=this.mapLayerOrUnit(childSpec,Object.assign({},
params,{repeater:childRepeater,repeaterPrefix:layerValue}));childRepeater.name=layerValue;return childRepeater})})}mapNonLayerRepeat(spec,params){var _childSpec$data,$jscomp$destructuring$var67=spec,$jscomp$destructuring$var68=Object.assign({},$jscomp$destructuring$var67);const repeat=$jscomp$destructuring$var67.repeat,childSpec=$jscomp$destructuring$var67.spec;$jscomp$destructuring$var67=$jscomp$destructuring$var67.data;$jscomp$destructuring$var68=(delete $jscomp$destructuring$var68.repeat,delete $jscomp$destructuring$var68.spec,
delete $jscomp$destructuring$var68.data,$jscomp$destructuring$var68);!vega.isArray(repeat)&&spec.columns&&(spec=omit(spec,["columns"]),warn(columnsNotSupportByRowCol("repeat")));const concat=[],{repeater={},repeaterPrefix=""}=params,row=!vega.isArray(repeat)&&repeat.row||[repeater?repeater.row:null],column=!vega.isArray(repeat)&&repeat.column||[repeater?repeater.column:null];var repeatValues=vega.isArray(repeat)&&repeat||[repeater?repeater.repeat:null];for(const repeatValue of repeatValues)for(const rowValue of row)for(const columnValue of column){var childRepeater=
{repeat:repeatValue,row:rowValue,column:columnValue,layer:repeater.layer};repeatValues=(childSpec.name||"")+repeaterPrefix+"child__"+(vega.isArray(repeat)?"".concat(varName(repeatValue)):(repeat.row?"row_".concat(varName(rowValue)):"")+(repeat.column?"column_".concat(varName(columnValue)):""));childRepeater=this.map(childSpec,Object.assign({},params,{repeater:childRepeater,repeaterPrefix:repeatValues}));childRepeater.name=repeatValues;concat.push(omit(childRepeater,["data"]))}spec=vega.isArray(repeat)?
spec.columns:repeat.column?repeat.column.length:1;return Object.assign({},{data:null!==(_childSpec$data=childSpec.data)&&void 0!==_childSpec$data?_childSpec$data:$jscomp$destructuring$var67,align:"all"},$jscomp$destructuring$var68,{columns:spec,concat})}mapFacet(spec,params){const {facet}=spec;isFacetMapping(facet)&&spec.columns&&(spec=omit(spec,["columns"]),warn(columnsNotSupportByRowCol("facet")));return super.mapFacet(spec,params)}mapUnitWithParentEncodingOrProjection(spec,params){const {encoding,
projection}=spec,{parentEncoding,parentProjection,config}=params,mergedProjection=mergeProjection({parentProjection,projection});params=mergeEncoding({parentEncoding,encoding:replaceRepeaterInEncoding(encoding,params.repeater)});return this.mapUnit(Object.assign({},spec,mergedProjection?{projection:mergedProjection}:{},params?{encoding:params}:{}),{config})}mapFacetedUnit(spec,normParams){var $jscomp$destructuring$var69=spec.encoding,$jscomp$destructuring$var70=Object.assign({},$jscomp$destructuring$var69),
row=$jscomp$destructuring$var69.row;const column=$jscomp$destructuring$var69.column;$jscomp$destructuring$var69=$jscomp$destructuring$var69.facet;const encoding=(delete $jscomp$destructuring$var70.row,delete $jscomp$destructuring$var70.column,delete $jscomp$destructuring$var70.facet,$jscomp$destructuring$var70);var $jscomp$destructuring$var72=Object.assign({},spec);$jscomp$destructuring$var70=spec.mark;const width=spec.width,projection=spec.projection,height=spec.height,view=spec.view;spec=spec.params;
$jscomp$destructuring$var72=(delete $jscomp$destructuring$var72.mark,delete $jscomp$destructuring$var72.width,delete $jscomp$destructuring$var72.projection,delete $jscomp$destructuring$var72.height,delete $jscomp$destructuring$var72.view,delete $jscomp$destructuring$var72.params,delete $jscomp$destructuring$var72.encoding,$jscomp$destructuring$var72);const {facetMapping,layout}=this.getFacetMappingAndLayout({row,column,facet:$jscomp$destructuring$var69},normParams);row=replaceRepeaterInEncoding(encoding,
normParams.repeater);return this.mapFacet(Object.assign({},$jscomp$destructuring$var72,layout,{facet:facetMapping,spec:Object.assign({},width?{width}:{},height?{height}:{},view?{view}:{},projection?{projection}:{},{mark:$jscomp$destructuring$var70,encoding:row},spec?{params:spec}:{})}),normParams)}getFacetMappingAndLayout(facets,params){const {row,column,facet}=facets;if(row||column){facet&&(params=[...(row?["row"]:[]),...(column?["column"]:[])],params="Facet encoding dropped as ".concat(params.join(" and "),
" ").concat(1<params.length?"are":"is"," also specified."),warn(params));params={};var layout={};for(var channel of["row","column"]){const def=facets[channel];if(def){var $jscomp$destructuring$var74=Object.assign({},def);$jscomp$destructuring$var74=(delete $jscomp$destructuring$var74.align,delete $jscomp$destructuring$var74.center,delete $jscomp$destructuring$var74.spacing,delete $jscomp$destructuring$var74.columns,$jscomp$destructuring$var74);params[channel]=$jscomp$destructuring$var74;for(var prop of["align",
"center","spacing"])if(void 0!==def[prop]){var _layout$prop;null!==(_layout$prop=layout[prop])&&void 0!==_layout$prop?_layout$prop:layout[prop]={};layout[prop][channel]=def[prop]}}}return{facetMapping:params,layout}}layout=Object.assign({},facet);facets=facet.align;_layout$prop=facet.center;channel=facet.spacing;prop=facet.columns;layout=(delete layout.align,delete layout.center,delete layout.spacing,delete layout.columns,layout);params=(params=params.repeater)?isFacetMapping(layout)?replaceRepeaterInMapping(layout,
params):replaceRepeaterInFieldDef(layout,params):layout;return{facetMapping:params,layout:Object.assign({},facets?{align:facets}:{},_layout$prop?{center:_layout$prop}:{},channel?{spacing:channel}:{},prop?{columns:prop}:{})}}mapLayer(spec,_ref){var $jscomp$destructuring$var78=Object.assign({},_ref),parentEncoding=_ref.parentEncoding;_ref=_ref.parentProjection;$jscomp$destructuring$var78=(delete $jscomp$destructuring$var78.parentEncoding,delete $jscomp$destructuring$var78.parentProjection,$jscomp$destructuring$var78);
var $jscomp$destructuring$var80=Object.assign({},spec);const encoding=spec.encoding;spec=spec.projection;$jscomp$destructuring$var80=(delete $jscomp$destructuring$var80.encoding,delete $jscomp$destructuring$var80.projection,$jscomp$destructuring$var80);parentEncoding=Object.assign({},$jscomp$destructuring$var78,{parentEncoding:mergeEncoding({parentEncoding,encoding,layer:!0}),parentProjection:mergeProjection({parentProjection:_ref,projection:spec})});return super.mapLayer($jscomp$destructuring$var80,
parentEncoding)}}class SelectionCompatibilityNormalizer extends SpecMapper{map(spec,normParams){var _normParams$emptySele,_normParams$selection;null!==(_normParams$emptySele=normParams.emptySelections)&&void 0!==_normParams$emptySele?_normParams$emptySele:normParams.emptySelections={};null!==(_normParams$selection=normParams.selectionPredicates)&&void 0!==_normParams$selection?_normParams$selection:normParams.selectionPredicates={};spec=normalizeTransforms(spec,normParams);return super.map(spec,normParams)}mapLayerOrUnit(spec,
normParams){spec=normalizeTransforms(spec,normParams);if(spec.encoding){const encoding={};for(const $jscomp$destructuring$var81 of entries$1(spec.encoding)){const [channel,enc]=$jscomp$destructuring$var81;encoding[channel]=normalizeChannelDef(enc,normParams)}spec=Object.assign({},spec,{encoding})}return super.mapLayerOrUnit(spec,normParams)}mapUnit(spec,normParams){var $jscomp$destructuring$var83=Object.assign({},spec);const selection=spec.selection;$jscomp$destructuring$var83=(delete $jscomp$destructuring$var83.selection,
$jscomp$destructuring$var83);return selection?Object.assign({},$jscomp$destructuring$var83,{params:entries$1(selection).map(_ref=>{let [name,selDef]=_ref;var $jscomp$destructuring$var85=Object.assign({},selDef);_ref=selDef.init;const bind=selDef.bind,empty=selDef.empty;$jscomp$destructuring$var85=(delete $jscomp$destructuring$var85.init,delete $jscomp$destructuring$var85.bind,delete $jscomp$destructuring$var85.empty,$jscomp$destructuring$var85);"single"===$jscomp$destructuring$var85.type?($jscomp$destructuring$var85.type=
"point",$jscomp$destructuring$var85.toggle=!1):"multi"===$jscomp$destructuring$var85.type&&($jscomp$destructuring$var85.type="point");normParams.emptySelections[name]="none"!==empty;for(const pred of vals$jscomp$0(null!==(_normParams$selection2=normParams.selectionPredicates[name])&&void 0!==_normParams$selection2?_normParams$selection2:{})){var _normParams$selection2;pred.empty="none"!==empty}return{name,value:_ref,select:$jscomp$destructuring$var85,bind}})}):spec}}class TopLevelSelectionsNormalizer extends SpecMapper{map(spec,
normParams){var _normParams$selection;const selections=null!==(_normParams$selection=normParams.selections)&&void 0!==_normParams$selection?_normParams$selection:[];if(spec.params&&!isUnitSpec(spec)){_normParams$selection=[];for(const param of spec.params)param.select?selections.push(param):_normParams$selection.push(param);spec.params=_normParams$selection}normParams.selections=selections;return super.map(spec,addSpecNameToParams(spec,normParams))}mapUnit(spec,normParams){var _normParams$path;const selections=
normParams.selections;if(!selections||!selections.length)return spec;const path=(null!==(_normParams$path=normParams.path)&&void 0!==_normParams$path?_normParams$path:[]).concat(spec.name);normParams=[];for(const selection of selections)if(selection.views&&selection.views.length)for(const view of selection.views)(vega.isString(view)&&(view===spec.name||0<=path.indexOf(view))||vega.isArray(view)&&view.map(v=>path.indexOf(v)).every((v,i,arr)=>-1!==v&&(0===i||v>arr[i-1])))&&normParams.push(selection);
else normParams.push(selection);normParams.length&&(spec.params=normParams);return spec}}for(const method of["mapFacet","mapRepeat","mapHConcat","mapVConcat","mapLayer"]){const proto=TopLevelSelectionsNormalizer.prototype[method];TopLevelSelectionsNormalizer.prototype[method]=function(spec,params){return proto.call(this,spec,addSpecNameToParams(spec,params))}}const coreNormalizer=new CoreNormalizer,selectionCompatNormalizer=new SelectionCompatibilityNormalizer,topLevelSelectionNormalizer=new TopLevelSelectionsNormalizer;
class Split{constructor(){let implicit=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};this.explicit=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};this.implicit=implicit}clone(){return new Split(duplicate(this.explicit),duplicate(this.implicit))}combine(){return Object.assign({},this.explicit,this.implicit)}get(key){return getFirstDefined(this.explicit[key],this.implicit[key])}getWithExplicit(key){return void 0!==this.explicit[key]?{explicit:!0,value:this.explicit[key]}:void 0!==
this.implicit[key]?{explicit:!1,value:this.implicit[key]}:{explicit:!1,value:void 0}}setWithExplicit(key,_ref){let {value,explicit}=_ref;void 0!==value&&this.set(key,value,explicit)}set(key,value,explicit){delete this[explicit?"implicit":"explicit"][key];this[explicit?"explicit":"implicit"][key]=value;return this}copyKeyFromSplit(key,_ref2){let {explicit,implicit}=_ref2;void 0!==explicit[key]?this.set(key,explicit[key],!0):void 0!==implicit[key]&&this.set(key,implicit[key],!1)}copyKeyFromObject(key,
s){void 0!==s[key]&&this.set(key,s[key],!0)}copyAll(other){for(const key of keys$jscomp$0(other.combine())){const val=other.getWithExplicit(key);this.setWithExplicit(key,val)}}}class AncestorParse extends Split{constructor(){let explicit=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},implicit=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},parseNothing=2<arguments.length&&void 0!==arguments[2]?arguments[2]:!1;super(explicit,implicit);this.explicit=explicit;this.implicit=implicit;
this.parseNothing=parseNothing}clone(){const clone=super.clone();clone.parseNothing=this.parseNothing;return clone}}let DataSourceType;(function(DataSourceType){DataSourceType[DataSourceType.Raw=0]="Raw";DataSourceType[DataSourceType.Main=1]="Main";DataSourceType[DataSourceType.Row=2]="Row";DataSourceType[DataSourceType.Column=3]="Column";DataSourceType[DataSourceType.Lookup=4]="Lookup"})(DataSourceType||(DataSourceType={}));class DataFlowNode{constructor(parent,debugName){this.debugName=debugName;
_defineProperty(this,"_children",[]);_defineProperty(this,"_parent",null);_defineProperty(this,"_hash",void 0);parent&&(this.parent=parent)}clone(){throw Error("Cannot clone node");}get parent(){return this._parent}set parent(parent){(this._parent=parent)&&parent.addChild(this)}get children(){return this._children}numChildren(){return this._children.length}addChild(child,loc){this._children.includes(child)?warn("Attempt to add the same child twice."):void 0!==loc?this._children.splice(loc,0,child):
this._children.push(child)}removeChild(oldChild){oldChild=this._children.indexOf(oldChild);this._children.splice(oldChild,1);return oldChild}remove(){let loc=this._parent.removeChild(this);for(const child of this._children)child._parent=this._parent,this._parent.addChild(child,loc++)}insertAsParentOf(other){const parent=other.parent;parent.removeChild(this);this.parent=parent;other.parent=this}swapWithParent(){const parent=this._parent,newParent=parent.parent;for(const child of this._children)child.parent=
parent;this._children=[];parent.removeChild(this);parent.parent.removeChild(parent);this.parent=newParent;parent.parent=this}}class OutputNode extends DataFlowNode{clone(){const cloneObj=new this.constructor;cloneObj.debugName="clone_".concat(this.debugName);cloneObj._source=this._source;cloneObj._name="clone_".concat(this._name);cloneObj.type=this.type;cloneObj.refCounts=this.refCounts;cloneObj.refCounts[cloneObj._name]=0;return cloneObj}constructor(parent,source,type,refCounts){super(parent,source);
this.type=type;this.refCounts=refCounts;_defineProperty(this,"_source",void 0);_defineProperty(this,"_name",void 0);this._source=this._name=source;!this.refCounts||this._name in this.refCounts||(this.refCounts[this._name]=0)}dependentFields(){return new Set}producedFields(){return new Set}hash(){void 0===this._hash&&(this._hash="Output ".concat(uniqueId()));return this._hash}getSource(){this.refCounts[this._name]++;return this._source}isRequired(){return!!this.refCounts[this._name]}setSource(source){this._source=
source}}class TimeUnitNode extends DataFlowNode{clone(){return new TimeUnitNode(null,duplicate(this.formula))}constructor(parent,formula){super(parent);this.formula=formula}static makeFromEncoding(parent,model){model=model.reduceFieldDef((timeUnitComponent,fieldDef)=>{const {field,timeUnit}=fieldDef;timeUnit&&(fieldDef=vgField(fieldDef,{forAs:!0}),timeUnitComponent[hash({as:fieldDef,field,timeUnit})]={as:fieldDef,field,timeUnit});return timeUnitComponent},{});return isEmpty(model)?null:new TimeUnitNode(parent,
model)}static makeFromTransform(parent,t){var $jscomp$destructuring$var100=Object.assign({},t);t=Object.assign({},$jscomp$destructuring$var100);$jscomp$destructuring$var100=$jscomp$destructuring$var100.timeUnit;t=(delete t.timeUnit,t);$jscomp$destructuring$var100=normalizeTimeUnit($jscomp$destructuring$var100);t=Object.assign({},t,{timeUnit:$jscomp$destructuring$var100});return new TimeUnitNode(parent,{[hash(t)]:t})}merge(other){this.formula=Object.assign({},this.formula);for(const key in other.formula)this.formula[key]||
(this.formula[key]=other.formula[key]);for(const child of other.children)other.removeChild(child),child.parent=this;other.remove()}removeFormulas(fields){const newFormula={};for(const $jscomp$destructuring$var102 of entries$1(this.formula)){const [key,timeUnit]=$jscomp$destructuring$var102;fields.has(timeUnit.as)||(newFormula[key]=timeUnit)}this.formula=newFormula}producedFields(){return new Set(vals$jscomp$0(this.formula).map(f=>f.as))}dependentFields(){return new Set(vals$jscomp$0(this.formula).map(f=>
f.field))}hash(){return"TimeUnit ".concat(hash(this.formula))}assemble(){const transforms=[];for(const f of vals$jscomp$0(this.formula)){const {field,as,timeUnit}=f;var $jscomp$destructuring$var103=normalizeTimeUnit(timeUnit),$jscomp$destructuring$var104=Object.assign({},$jscomp$destructuring$var103);const unit=$jscomp$destructuring$var103.unit;$jscomp$destructuring$var103=$jscomp$destructuring$var103.utc;$jscomp$destructuring$var104=(delete $jscomp$destructuring$var104.unit,delete $jscomp$destructuring$var104.utc,
$jscomp$destructuring$var104);transforms.push(Object.assign({},{field:replacePathInField(field),type:"timeunit"},unit?{units:getTimeUnitParts(unit)}:{},$jscomp$destructuring$var103?{timezone:"utc"}:{},$jscomp$destructuring$var104,{as:[as,"".concat(as,"_end")]}))}return transforms}}class SelectionProjectionComponent{constructor(){_defineProperty(this,"hasChannel",void 0);_defineProperty(this,"hasField",void 0);_defineProperty(this,"timeUnit",void 0);_defineProperty(this,"items",void 0);for(var _len=
arguments.length,items=Array(_len),_key=0;_key<_len;_key++)items[_key]=arguments[_key];this.items=items;this.hasChannel={};this.hasField={}}}const scaleBindings={defined:selCmpt=>"interval"===selCmpt.type&&"global"===selCmpt.resolve&&selCmpt.bind&&"scales"===selCmpt.bind,parse:(model,selCmpt)=>{const bound=selCmpt.scales=[];for(const proj of selCmpt.project.items){var channel=proj.channel;if(!SCALE_CHANNEL_INDEX[channel])continue;const scaleType=(channel=model.getScaleComponent(channel))?channel.get("type"):
void 0;channel&&hasContinuousDomain(scaleType)?(channel.set("selectionExtent",{param:selCmpt.name,field:proj.field},!0),bound.push(proj)):warn("Scale bindings are currently only supported for scales with unbinned, continuous domains.")}},topLevelSignals:(model,selCmpt,signals)=>{const bound=selCmpt.scales.filter(proj=>0===signals.filter(s=>s.name===proj.signals.data).length);if(!model.parent||isTopLevelLayer(model)||0===bound.length)return signals;model=signals.filter(s=>s.name===selCmpt.name)[0];
let update=model.update;if(0<=update.indexOf("vlSelectionResolve"))model.update="{".concat(bound.map(proj=>"".concat(vega.stringValue(replacePathInField(proj.field)),": ").concat(proj.signals.data)).join(", "),"}");else{for(const proj of bound){const mapping="".concat(vega.stringValue(replacePathInField(proj.field)),": ").concat(proj.signals.data);update.includes(mapping)||(update="".concat(update.substring(0,update.length-1),", ").concat(mapping,"}"))}model.update=update}return signals.concat(bound.map(proj=>
({name:proj.signals.data})))},signals:(model,selCmpt,signals)=>{if(model.parent&&!isTopLevelLayer(model))for(const proj of selCmpt.scales)model=signals.filter(s=>s.name===proj.signals.data)[0],model.push="outer",delete model.value,delete model.update;return signals}},ALIGNED_X_CHANNEL={left:"x",center:"xc",right:"x2"},BASELINED_Y_CHANNEL={top:"y",middle:"yc",bottom:"y2"},ALWAYS_IGNORE=new Set(["aria","width","height"]),nearest={defined:selCmpt=>"point"===selCmpt.type&&selCmpt.nearest,parse:(model,
selCmpt)=>{if(selCmpt.events)for(const s of selCmpt.events)s.markname=model.getName("voronoi")},marks:(model,selCmpt,marks)=>{const {x,y}=selCmpt.project.hasChannel;selCmpt=model.mark;if(isPathMark(selCmpt))return warn('The "nearest" transform is not supported for '.concat(selCmpt," marks.")),marks;selCmpt={name:model.getName("voronoi"),type:"path",interactive:!0,from:{data:model.getName("marks")},encode:{update:Object.assign({},{fill:{value:"transparent"},strokeWidth:{value:.35},stroke:{value:"transparent"},
isVoronoi:{value:!0}},tooltip(model,{reactiveGeom:!0}))},transform:[{type:"voronoi",x:{expr:x||!y?"datum.datum.x || 0":"0"},y:{expr:y||!x?"datum.datum.y || 0":"0"},size:[model.getSizeSignalRef("width"),model.getSizeSignalRef("height")]}]};let index=0,exists=!1;marks.forEach((mark,i)=>{var _mark$name;mark=null!==(_mark$name=mark.name)&&void 0!==_mark$name?_mark$name:"";mark===model.component.mark[0].name?index=i:0<=mark.indexOf("voronoi")&&(exists=!0)});exists||marks.splice(index+1,0,selCmpt);return marks}},
inputBindings={defined:selCmpt=>"point"===selCmpt.type&&"global"===selCmpt.resolve&&selCmpt.bind&&"scales"!==selCmpt.bind&&!isLegendBinding(selCmpt.bind),parse:(model,selCmpt,selDef)=>disableDirectManipulation(selCmpt,selDef),topLevelSignals:(model,selCmpt,signals)=>{const name=selCmpt.name;model=selCmpt.project;const bind=selCmpt.bind,init=selCmpt.init&&selCmpt.init[0],datum=nearest.defined(selCmpt)?"(item().isVoronoi ? datum.datum : datum)":"datum";model.items.forEach((p,i)=>{const sgname=varName("".concat(name,
"_").concat(p.field));if(!signals.filter(s=>s.name===sgname).length){var _ref,_bind$p$field;signals.unshift(Object.assign({},{name:sgname},init?{init:assembleInit(init[i])}:{value:null},{on:selCmpt.events?[{events:selCmpt.events,update:"datum \x26\x26 item().mark.marktype !\x3d\x3d 'group' ? ".concat(datum,"[").concat(vega.stringValue(p.field),"] : null")}]:[],bind:null!==(_ref=null!==(_bind$p$field=bind[p.field])&&void 0!==_bind$p$field?_bind$p$field:bind[p.channel])&&void 0!==_ref?_ref:bind}))}});
return signals},signals:(model,selCmpt,signals)=>{const name=selCmpt.name;var proj=selCmpt.project;model=signals.filter(s=>s.name===name+"_tuple")[0];selCmpt=name+"_tuple_fields";proj=proj.items.map(p=>varName("".concat(name,"_").concat(p.field)));const valid=proj.map(v=>"".concat(v," !\x3d\x3d null")).join(" \x26\x26 ");proj.length&&(model.update="".concat(valid," ? {fields: ").concat(selCmpt,", values: [").concat(proj.join(", "),"]} : null"));delete model.value;delete model.on;return signals}},
toggle={defined:selCmpt=>"point"===selCmpt.type&&!!selCmpt.toggle,signals:(model,selCmpt,signals)=>signals.concat({name:selCmpt.name+"_toggle",value:!1,on:[{events:selCmpt.events,update:selCmpt.toggle}]}),modifyExpr:(model,selCmpt)=>{const tpl=selCmpt.name+"_tuple",signal=selCmpt.name+"_toggle";return"".concat(signal," ? null : ").concat(tpl,", ")+("global"===selCmpt.resolve?"".concat(signal," ? null : true, "):"".concat(signal," ? null : {unit: ").concat(unitName(model),"}, "))+"".concat(signal,
" ? ").concat(tpl," : null")}},legendBindings={defined:selCmpt=>{const spec="global"===selCmpt.resolve&&selCmpt.bind&&isLegendBinding(selCmpt.bind);selCmpt=1===selCmpt.project.items.length&&"_vgsid_"!==selCmpt.project.items[0].field;spec&&!selCmpt&&warn("Legend bindings are only supported for selections over an individual field or encoding channel.");return spec&&selCmpt},parse:(model,selCmpt,selDef)=>{model=duplicate(selDef);model.select=vega.isString(model.select)?{type:model.select,toggle:selCmpt.toggle}:
Object.assign({},model.select,{toggle:selCmpt.toggle});disableDirectManipulation(selCmpt,model);if(vega.isObject(selDef.select)&&(selDef.select.on||selDef.select.clear))for(const evt of selCmpt.events){var _evt$filter;evt.filter=vega.array(null!==(_evt$filter=evt.filter)&&void 0!==_evt$filter?_evt$filter:[]);evt.filter.includes('event.item \x26\x26 indexof(event.item.mark.role, "legend") \x3c 0')||evt.filter.push('event.item \x26\x26 indexof(event.item.mark.role, "legend") \x3c 0')}selDef=isLegendStreamBinding(selCmpt.bind)?
selCmpt.bind.legend:"click";selDef=vega.isString(selDef)?vega.parseSelector(selDef,"view"):vega.array(selDef);selCmpt.bind={legend:{merge:selDef}}},topLevelSignals:(model,selCmpt,signals)=>{model=selCmpt.name;const stream=isLegendStreamBinding(selCmpt.bind)&&selCmpt.bind.legend,markName=name=>s=>{s=duplicate(s);s.markname=name;return s};for(const proj of selCmpt.project.items){if(!proj.hasLegend)continue;var prefix="".concat(varName(proj.field),"_legend");const sgName="".concat(model,"_").concat(prefix);
0===signals.filter(s=>s.name===sgName).length&&(prefix=stream.merge.map(markName("".concat(prefix,"_symbols"))).concat(stream.merge.map(markName("".concat(prefix,"_labels")))).concat(stream.merge.map(markName("".concat(prefix,"_entries")))),signals.unshift(Object.assign({},{name:sgName},selCmpt.init?{}:{value:null},{on:[{events:prefix,update:"datum.value || item().items[0].items[0].datum.value",force:!0},{events:stream.merge,update:"!event.item || !datum ? null : ".concat(sgName),force:!0}]})))}return signals},
signals:(model,selCmpt,signals)=>{const name=selCmpt.name;var proj=selCmpt.project;model=signals.find(s=>s.name===name+"_tuple");var fields=name+"_tuple_fields";proj=proj.items.filter(p=>p.hasLegend).map(p=>varName("".concat(name,"_").concat(varName(p.field),"_legend")));const valid=proj.map(v=>"".concat(v," !\x3d\x3d null")).join(" \x26\x26 ");fields="".concat(valid," ? {fields: ").concat(fields,", values: [").concat(proj.join(", "),"]} : null");selCmpt.events&&0<proj.length?model.on.push({events:proj.map(signal=>
({signal})),update:fields}):0<proj.length&&(model.update=fields,delete model.value,delete model.on);model=signals.find(s=>s.name===name+"_toggle");fields=isLegendStreamBinding(selCmpt.bind)&&selCmpt.bind.legend;model&&(selCmpt.events?model.on.push(Object.assign({},model.on[0],{events:fields})):model.on[0].events=fields);return signals}},selectionCompilers=[{defined:selCmpt=>"point"===selCmpt.type,signals:(model,selCmpt,signals)=>{var _model$component$sele;const name=selCmpt.name;var fieldsSg=name+
"_tuple_fields";const values=selCmpt.project.items.map(p=>{const fieldDef=model.fieldDef(p.channel);return null!==fieldDef&&void 0!==fieldDef&&fieldDef.bin?"[".concat("(item().isVoronoi ? datum.datum : datum)","[").concat(vega.stringValue(model.vgField(p.channel,{})),"], ")+"".concat("(item().isVoronoi ? datum.datum : datum)","[").concat(vega.stringValue(model.vgField(p.channel,{binSuffix:"end"})),"]]"):"".concat("(item().isVoronoi ? datum.datum : datum)","[").concat(vega.stringValue(p.field),"]")}).join(", ");
fieldsSg="unit: ".concat(unitName(model),", fields: ").concat(fieldsSg,", values");selCmpt=selCmpt.events;const brushes=vals$jscomp$0(null!==(_model$component$sele=model.component.selection)&&void 0!==_model$component$sele?_model$component$sele:{}).reduce((acc,cmpt)=>"interval"===cmpt.type?acc.concat(cmpt.name+"_brush"):acc,[]).map(b=>"indexof(item().mark.name, '".concat(b,"') \x3c 0")).join(" \x26\x26 ");_model$component$sele="datum \x26\x26 item().mark.marktype !\x3d\x3d 'group'".concat(brushes?
" \x26\x26 ".concat(brushes):"");return signals.concat([{name:name+"_tuple",on:selCmpt?[{events:selCmpt,update:"".concat(_model$component$sele," ? {").concat(fieldsSg,": [").concat(values,"]} : null"),force:!0}]:[]}])}},{defined:selCmpt=>"interval"===selCmpt.type,signals:(model,selCmpt,signals)=>{const name=selCmpt.name;var fieldsSg=name+"_tuple_fields";const hasScales=scaleBindings.defined(selCmpt),init=selCmpt.init?selCmpt.init[0]:null,dataSignals=[],scaleTriggers=[];if(selCmpt.translate&&!hasScales){const filterExpr=
"!event.item || event.item.mark.name !\x3d\x3d ".concat(vega.stringValue(name+"_brush"));events$jscomp$0(selCmpt,(on,evt)=>{var _evt$between$,_evt$between$$filter;evt=vega.array(null!==(_evt$between$$filter=(_evt$between$=evt.between[0]).filter)&&void 0!==_evt$between$$filter?_evt$between$$filter:_evt$between$.filter=[]);evt.includes(filterExpr)||evt.push(filterExpr);return on})}selCmpt.project.items.forEach((proj,i)=>{const channel=proj.channel;if("x"!==channel&&"y"!==channel)warn("Interval selections only support x and y encoding channels.");
else{i=channelSignals(model,selCmpt,proj,init?init[i]:null);var dname=proj.signals.data;proj=proj.signals.visual;var scaleName=vega.stringValue(model.scaleName(channel)),scaleType=model.getScaleComponent(channel).get("type");scaleType=hasContinuousDomain(scaleType)?"+":"";signals.push(...i);dataSignals.push(dname);scaleTriggers.push({scaleName:model.scaleName(channel),expr:"(!isArray(".concat(dname,") || ")+"(".concat(scaleType,"invert(").concat(scaleName,", ").concat(proj,")[0] \x3d\x3d\x3d ").concat(scaleType).concat(dname,
"[0] \x26\x26 ")+"".concat(scaleType,"invert(").concat(scaleName,", ").concat(proj,")[1] \x3d\x3d\x3d ").concat(scaleType).concat(dname,"[1]))")})}});!hasScales&&scaleTriggers.length&&signals.push({name:name+"_scale_trigger",value:{},on:[{events:scaleTriggers.map(t=>({scale:t.scaleName})),update:"".concat(scaleTriggers.map(t=>t.expr).join(" \x26\x26 ")," ? ").concat(name+"_scale_trigger"," : {}")}]});fieldsSg="unit: ".concat(unitName(model),", fields: ").concat(fieldsSg,", values");return signals.concat(Object.assign({},
{name:name+"_tuple"},init?{init:"{".concat(fieldsSg,": ").concat(assembleInit(init),"}")}:{},dataSignals.length?{on:[{events:[{signal:dataSignals.join(" || ")}],update:"".concat(dataSignals.join(" \x26\x26 ")," ? {").concat(fieldsSg,": [").concat(dataSignals,"]} : null")}]}:{}))},marks:(model,selCmpt,marks)=>{const name=selCmpt.name,{x,y}=selCmpt.project.hasChannel,xvname=null===x||void 0===x?void 0:x.signals.visual,yvname=null===y||void 0===y?void 0:y.signals.visual;var store="data(".concat(vega.stringValue(selCmpt.name+
"_store"),")");if(scaleBindings.defined(selCmpt)||!x&&!y)return marks;const update={x:void 0!==x?{signal:"".concat(xvname,"[0]")}:{value:0},y:void 0!==y?{signal:"".concat(yvname,"[0]")}:{value:0},x2:void 0!==x?{signal:"".concat(xvname,"[1]")}:{field:{group:"width"}},y2:void 0!==y?{signal:"".concat(yvname,"[1]")}:{field:{group:"height"}}};if("global"===selCmpt.resolve)for(var key of keys$jscomp$0(update))update[key]=[Object.assign({},{test:"".concat(store,".length \x26\x26 ").concat(store,"[0].unit \x3d\x3d\x3d ").concat(unitName(model))},
update[key]),{value:0}];key=selCmpt.mark;store=Object.assign({},key);model=key.fill;selCmpt=key.fillOpacity;key=key.cursor;const stroke=(delete store.fill,delete store.fillOpacity,delete store.cursor,store);store=keys$jscomp$0(stroke).reduce((def,k)=>{def[k]=[{test:[void 0!==x&&"".concat(xvname,"[0] !\x3d\x3d ").concat(xvname,"[1]"),void 0!==y&&"".concat(yvname,"[0] !\x3d\x3d ").concat(yvname,"[1]")].filter(t=>t).join(" \x26\x26 "),value:stroke[k]},{value:null}];return def},{});return[{name:"".concat(name+
"_brush","_bg"),type:"rect",clip:!0,encode:{enter:{fill:{value:model},fillOpacity:{value:selCmpt}},update}},...marks,{name:name+"_brush",type:"rect",clip:!0,encode:{enter:Object.assign({},key?{cursor:{value:key}}:{},{fill:{value:"transparent"}}),update:Object.assign({},update,store)}}]}},{defined:()=>!0,parse:(model,selCmpt,selDef)=>{var _selCmpt$project;const name=selCmpt.name,proj=null!==(_selCmpt$project=selCmpt.project)&&void 0!==_selCmpt$project?_selCmpt$project:selCmpt.project=new SelectionProjectionComponent,
parsed={};_selCmpt$project={};const signals=new Set,signalName=(p,range)=>{p="visual"===range?p.channel:p.field;let sg=varName("".concat(name,"_").concat(p));for(let counter=1;signals.has(sg);counter++)sg=varName("".concat(name,"_").concat(p,"_").concat(counter));signals.add(sg);return{[range]:sg}},type=selCmpt.type,cfg=model.config.selection[type],init=void 0!==selDef.value?vega.array(selDef.value):null;let {fields,encodings}=vega.isObject(selDef.select)?selDef.select:{};if(!fields&&!encodings&&
init)for(var initVal of init)if(vega.isObject(initVal))for(const key of keys$jscomp$0(initVal))SINGLE_DEF_UNIT_CHANNEL_INDEX[key]?(encodings||(encodings=[])).push(key):"interval"===type?(warn('Interval selections should be initialized using "x" and/or "y" keys.'),encodings=cfg.encodings):(fields||(fields=[])).push(key);fields||encodings||(encodings=cfg.encodings,"fields"in cfg&&(fields=cfg.fields));for(const channel of null!==(_encodings=encodings)&&void 0!==_encodings?_encodings:[]){var _encodings;
(_encodings=model.fieldDef(channel))?(selDef=_encodings.field,_encodings.aggregate?warn(cannotProjectAggregate(channel,_encodings.aggregate)):selDef?(_encodings.timeUnit&&(selDef=model.vgField(channel),initVal={timeUnit:_encodings.timeUnit,as:selDef,field:_encodings.field},_selCmpt$project[hash(initVal)]=initVal),parsed[selDef]||(initVal="E","interval"===type?(_encodings=model.getScaleComponent(channel).get("type"),hasContinuousDomain(_encodings)&&(initVal="R")):_encodings.bin&&(initVal="R-RE"),_encodings=
{field:selDef,channel,type:initVal},_encodings.signals=Object.assign({},signalName(_encodings,"data"),signalName(_encodings,"visual")),proj.items.push(parsed[selDef]=_encodings),proj.hasField[selDef]=proj.hasChannel[channel]=parsed[selDef])):warn(cannotProjectOnChannelWithoutField(channel))):warn(cannotProjectOnChannelWithoutField(channel))}for(const field of null!==(_fields=fields)&&void 0!==_fields?_fields:[]){var _fields;proj.hasField[field]||(model={type:"E",field},model.signals=Object.assign({},
signalName(model,"data")),proj.items.push(model),proj.hasField[field]=model)}init&&(selCmpt.init=init.map(v=>proj.items.map(p=>vega.isObject(v)?void 0!==v[p.channel]?v[p.channel]:v[p.field]:v)));isEmpty(_selCmpt$project)||(proj.timeUnit=new TimeUnitNode(null,_selCmpt$project))},signals:(model,selCmpt,allSignals)=>{const name=selCmpt.name+"_tuple_fields";return 0<allSignals.filter(s=>s.name===name).length?allSignals:allSignals.concat({name,value:selCmpt.project.items.map(proj=>{proj=Object.assign({},
proj);proj=(delete proj.signals,delete proj.hasLegend,proj);proj.field=replacePathInField(proj.field);return proj})})}},toggle,inputBindings,scaleBindings,legendBindings,{defined:selCmpt=>void 0!==selCmpt.clear&&!1!==selCmpt.clear,parse:(model,selCmpt)=>{selCmpt.clear&&(selCmpt.clear=vega.isString(selCmpt.clear)?vega.parseSelector(selCmpt.clear,"view"):selCmpt.clear)},topLevelSignals:(model,selCmpt,signals)=>{if(inputBindings.defined(selCmpt))for(const proj of selCmpt.project.items)model=signals.findIndex(n=>
n.name===varName("".concat(selCmpt.name,"_").concat(proj.field))),-1!==model&&signals[model].on.push({events:selCmpt.clear,update:"null"});return signals},signals:(model,selCmpt,signals)=>{function addClear(idx,update){-1!==idx&&signals[idx].on&&signals[idx].on.push({events:selCmpt.clear,update})}if("interval"===selCmpt.type)for(const proj of selCmpt.project.items)model=signals.findIndex(n=>n.name===proj.signals.visual),addClear(model,"[0, 0]"),-1===model&&(model=signals.findIndex(n=>n.name===proj.signals.data),
addClear(model,"null"));else model=signals.findIndex(n=>n.name===selCmpt.name+"_tuple"),addClear(model,"null"),toggle.defined(selCmpt)&&(model=signals.findIndex(n=>n.name===selCmpt.name+"_toggle"),addClear(model,"false"));return signals}},{defined:selCmpt=>"interval"===selCmpt.type&&selCmpt.translate,signals:(model,selCmpt,signals)=>{const name=selCmpt.name,hasScales=scaleBindings.defined(selCmpt),anchor=name+"_translate_anchor",{x,y}=selCmpt.project.hasChannel;let events=vega.parseSelector(selCmpt.translate,
"scope");hasScales||(events=events.map(e=>(e.between[0].markname=name+"_brush",e)));signals.push({name:anchor,value:{},on:[{events:events.map(e=>e.between[0]),update:"{x: x(unit), y: y(unit)"+(void 0!==x?", extent_x: ".concat(hasScales?domain$jscomp$0(model,"x"):"slice(".concat(x.signals.visual,")")):"")+(void 0!==y?", extent_y: ".concat(hasScales?domain$jscomp$0(model,"y"):"slice(".concat(y.signals.visual,")")):"")+"}"}]},{name:name+"_translate_delta",value:{},on:[{events,update:"{x: ".concat(anchor,
".x - x(unit), y: ").concat(anchor,".y - y(unit)}")}]});void 0!==x&&onDelta$1(model,selCmpt,x,"width",signals);void 0!==y&&onDelta$1(model,selCmpt,y,"height",signals);return signals}},{defined:selCmpt=>"interval"===selCmpt.type&&selCmpt.zoom,signals:(model,selCmpt,signals)=>{const name=selCmpt.name,hasScales=scaleBindings.defined(selCmpt),delta=name+"_zoom_delta",{x,y}=selCmpt.project.hasChannel,sx=vega.stringValue(model.scaleName("x")),sy=vega.stringValue(model.scaleName("y"));let events=vega.parseSelector(selCmpt.zoom,
"scope");hasScales||(events=events.map(e=>(e.markname=name+"_brush",e)));signals.push({name:name+"_zoom_anchor",on:[{events,update:hasScales?"{"+[sx?"x: invert(".concat(sx,", x(unit))"):"",sy?"y: invert(".concat(sy,", y(unit))"):""].filter(expr=>!!expr).join(", ")+"}":"{x: x(unit), y: y(unit)}"}]},{name:delta,on:[{events,force:!0,update:"pow(1.001, event.deltaY * pow(16, event.deltaMode))"}]});void 0!==x&&onDelta(model,selCmpt,x,"width",signals);void 0!==y&&onDelta(model,selCmpt,y,"height",signals);
return signals}},nearest];class FilterNode extends DataFlowNode{clone(){return new FilterNode(null,this.model,duplicate(this.filter))}constructor(parent,model,filter){super(parent);this.model=model;this.filter=filter;_defineProperty(this,"expr",void 0);_defineProperty(this,"_dependentFields",void 0);this.expr=expression$jscomp$0(this.model,this.filter,this);this._dependentFields=getDependentFields(this.expr)}dependentFields(){return this._dependentFields}producedFields(){return new Set}assemble(){return{type:"filter",
expr:this.expr}}hash(){return"Filter ".concat(this.expr)}}const axisRules={scale:_ref=>{let {model,channel}=_ref;return model.scaleName(channel)},format:_ref2=>{let {fieldOrDatumDef,config,axis}=_ref2;const {format,formatType}=axis;return guideFormat(fieldOrDatumDef,fieldOrDatumDef.type,format,formatType,config,!0)},formatType:_ref3=>{let {axis,fieldOrDatumDef,scaleType}=_ref3;({formatType:_ref3}=axis);return guideFormatType(_ref3,fieldOrDatumDef,scaleType)},grid:_ref4=>{var _axis$grid;let {fieldOrDatumDef,
axis,scaleType}=_ref4;return null!==(_axis$grid=axis.grid)&&void 0!==_axis$grid?_axis$grid:!hasDiscreteDomain(scaleType)&&isFieldDef(fieldOrDatumDef)&&!isBinning(null===fieldOrDatumDef||void 0===fieldOrDatumDef?void 0:fieldOrDatumDef.bin)&&!isBinned(null===fieldOrDatumDef||void 0===fieldOrDatumDef?void 0:fieldOrDatumDef.bin)},gridScale:_ref5=>{let {model,channel}=_ref5;_ref5="x"===channel?"y":"x";_ref5=model.getScaleComponent(_ref5)?model.scaleName(_ref5):void 0;return _ref5},labelAlign:_ref6=>{let {axis,
labelAngle,orient,channel}=_ref6;return axis.labelAlign||defaultLabelAlign(labelAngle,orient,channel)},labelAngle:_ref7=>{({labelAngle:_ref7}=_ref7);return _ref7},labelBaseline:_ref8=>{let {axis,labelAngle,orient,channel}=_ref8;return axis.labelBaseline||defaultLabelBaseline(labelAngle,orient,channel)},labelFlush:_ref9=>{var _axis$labelFlush;let {axis,fieldOrDatumDef,channel}=_ref9;_ref9=null!==(_axis$labelFlush=axis.labelFlush)&&void 0!==_axis$labelFlush?_axis$labelFlush:"x"===channel&&contains(["quantitative",
"temporal"],fieldOrDatumDef.type)?!0:void 0;return _ref9},labelOverlap:_ref10=>{var _axis$labelOverlap;let {axis,fieldOrDatumDef,scaleType}=_ref10;if(null!==(_axis$labelOverlap=axis.labelOverlap)&&void 0!==_axis$labelOverlap)_ref10=_axis$labelOverlap;else{_ref10=fieldOrDatumDef.type;_axis$labelOverlap=isFieldDef(fieldOrDatumDef)&&!!fieldOrDatumDef.timeUnit;var sort=isFieldDef(fieldOrDatumDef)?fieldOrDatumDef.sort:void 0;_ref10=_axis$labelOverlap&&!vega.isObject(sort)||"nominal"!==_ref10&&"ordinal"!==
_ref10?"log"===scaleType||"symlog"===scaleType?"greedy":!0:void 0}return _ref10},orient:_ref11=>{({orient:_ref11}=_ref11);return _ref11},tickCount:_ref12=>{var _axis$tickCount;let {channel,model,axis,fieldOrDatumDef:fieldOrDatumDef$jscomp$0,scaleType:scaleType$jscomp$0}=_ref12;_ref12=(_ref12="x"===channel?"width":"y"===channel?"height":void 0)?model.getSizeSignalRef(_ref12):void 0;if(null===(_axis$tickCount=axis.tickCount)||void 0===_axis$tickCount)a:{let {fieldOrDatumDef,scaleType,size,values:vals}=
{fieldOrDatumDef:fieldOrDatumDef$jscomp$0,scaleType:scaleType$jscomp$0,size:_ref12,values:axis.values};if(vals||hasDiscreteDomain(scaleType)||"log"===scaleType)_axis$tickCount=void 0;else{if(isFieldDef(fieldOrDatumDef)){var _normalizeTimeUnit;if(isBinning(fieldOrDatumDef.bin)){_axis$tickCount={signal:"ceil(".concat(size.signal,"/10)")};break a}if(fieldOrDatumDef.timeUnit&&contains(["month","hours","day","quarter"],null===(_normalizeTimeUnit=normalizeTimeUnit(fieldOrDatumDef.timeUnit))||void 0===_normalizeTimeUnit?
void 0:_normalizeTimeUnit.unit)){_axis$tickCount=void 0;break a}}_axis$tickCount={signal:"ceil(".concat(size.signal,"/40)")}}}return _axis$tickCount},title:_ref13=>{let {axis,model,channel}=_ref13;if(void 0!==axis.title)return axis.title;_ref13=getFieldDefTitle(model,channel);if(void 0!==_ref13)return _ref13;_ref13=model.typedFieldDef(channel);const fieldDef2=model.fieldDef("x"===channel?"x2":"y2");return mergeTitleFieldDefs(_ref13?[toFieldDefBase(_ref13)]:[],isFieldDef(fieldDef2)?[toFieldDefBase(fieldDef2)]:
[])},values:_ref14=>{let {axis,fieldOrDatumDef}=_ref14;_ref14=axis.values;_ref14=vega.isArray(_ref14)?valueArray(fieldOrDatumDef,_ref14):isSignalRef(_ref14)?_ref14:void 0;return _ref14},zindex:_ref15=>{var _axis$zindex;let {axis,fieldOrDatumDef,mark}=_ref15;_ref15=null!==(_axis$zindex=axis.zindex)&&void 0!==_axis$zindex?_axis$zindex:"rect"===mark&&isDiscrete(fieldOrDatumDef)?1:0;return _ref15}};class CalculateNode extends DataFlowNode{clone(){return new CalculateNode(null,duplicate(this.transform))}constructor(parent,
transform){super(parent);this.transform=transform;_defineProperty(this,"_dependentFields",void 0);this._dependentFields=getDependentFields(this.transform.calculate)}static parseAllForSortIndex(parent,model){model.forEachFieldDef((fieldDef,channel)=>{if(isScaleFieldDef(fieldDef)&&isSortArray(fieldDef.sort)){const {field,timeUnit}=fieldDef;var sort=fieldDef.sort;sort=sort.map((sortValue,i)=>"".concat(fieldFilterExpression({field,timeUnit,equal:sortValue})," ? ").concat(i," : ")).join("")+sort.length;
parent=new CalculateNode(parent,{calculate:sort,as:sortArrayIndexField(fieldDef,channel,{forAs:!0})})}});return parent}producedFields(){return new Set([this.transform.as])}dependentFields(){return this._dependentFields}assemble(){return{type:"formula",expr:this.transform.calculate,as:this.transform.as}}hash(){return"Calculate ".concat(hash(this.transform))}}const HEADER_CHANNELS=["row","column"],HEADER_TYPES=["header","footer"],LAYOUT_TITLE_BAND={column:{start:0,end:1},row:{start:1,end:0}},LEGEND_COMPONENT_PROPERTY_INDEX=
Object.assign({},{aria:1,clipHeight:1,columnPadding:1,columns:1,cornerRadius:1,description:1,direction:1,fillColor:1,format:1,formatType:1,gradientLength:1,gradientOpacity:1,gradientStrokeColor:1,gradientStrokeWidth:1,gradientThickness:1,gridAlign:1,labelAlign:1,labelBaseline:1,labelColor:1,labelFont:1,labelFontSize:1,labelFontStyle:1,labelFontWeight:1,labelLimit:1,labelOffset:1,labelOpacity:1,labelOverlap:1,labelPadding:1,labelSeparation:1,legendX:1,legendY:1,offset:1,orient:1,padding:1,rowPadding:1,
strokeColor:1,symbolDash:1,symbolDashOffset:1,symbolFillColor:1,symbolLimit:1,symbolOffset:1,symbolOpacity:1,symbolSize:1,symbolStrokeColor:1,symbolStrokeWidth:1,symbolType:1,tickCount:1,tickMinStep:1,title:1,titleAlign:1,titleAnchor:1,titleBaseline:1,titleColor:1,titleFont:1,titleFontSize:1,titleFontStyle:1,titleFontWeight:1,titleLimit:1,titleLineHeight:1,titleOpacity:1,titleOrient:1,titlePadding:1,type:1,values:1,zindex:1},{disable:1,labelExpr:1,selections:1,opacity:1,shape:1,stroke:1,fill:1,size:1,
strokeWidth:1,strokeDash:1,encode:1}),LEGEND_COMPONENT_PROPERTIES=keys$jscomp$0(LEGEND_COMPONENT_PROPERTY_INDEX);class LegendComponent extends Split{}const legendEncodeRules={symbols:function(symbolsSpec,_ref){var _legendCmpt$get,_legendCmpt$get2,_legendCmpt$get3,_getMaxValue;let {fieldOrDatumDef,model,channel,legendCmpt,legendType}=_ref;if("symbol"===legendType){var {markDef,encoding,config,mark}=model;_ref=markDef.filled&&"trail"!==mark;var JSCompiler_temp_const=Object,JSCompiler_temp_const$jscomp$0=
JSCompiler_temp_const.assign,e={};for(var property of FILL_STROKE_CONFIG){const value=getMarkConfig(property,model.markDef,model.config);void 0!==value&&(e[property]=signalOrValueRef(value))}property=JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const,{},e,color$jscomp$0(model,{filled:_ref}));JSCompiler_temp_const=null!==(_legendCmpt$get=legendCmpt.get("symbolOpacity"))&&void 0!==_legendCmpt$get?_legendCmpt$get:config.legend.symbolOpacity;_legendCmpt$get=null!==(_legendCmpt$get2=legendCmpt.get("symbolFillColor"))&&
void 0!==_legendCmpt$get2?_legendCmpt$get2:config.legend.symbolFillColor;_legendCmpt$get2=null!==(_legendCmpt$get3=legendCmpt.get("symbolStrokeColor"))&&void 0!==_legendCmpt$get3?_legendCmpt$get3:config.legend.symbolStrokeColor;_legendCmpt$get3=void 0===JSCompiler_temp_const?null!==(_getMaxValue=getMaxValue(encoding.opacity))&&void 0!==_getMaxValue?_getMaxValue:markDef.opacity:void 0;if(property.fill)if("fill"===channel||_ref&&"color"===channel)delete property.fill;else if(property.fill.field)if(_legendCmpt$get)delete property.fill;
else{var _config$legend$symbol;property.fill=signalOrValueRef(null!==(_config$legend$symbol=config.legend.symbolBaseFillColor)&&void 0!==_config$legend$symbol?_config$legend$symbol:"black");property.fillOpacity=signalOrValueRef(null!==_legendCmpt$get3&&void 0!==_legendCmpt$get3?_legendCmpt$get3:1)}else if(vega.isArray(property.fill)){var _ref2,_getFirstConditionVal,_encoding$fill;if(_getMaxValue=null!==(_ref2=null!==(_getFirstConditionVal=getFirstConditionValue(null!==(_encoding$fill=encoding.fill)&&
void 0!==_encoding$fill?_encoding$fill:encoding.color))&&void 0!==_getFirstConditionVal?_getFirstConditionVal:markDef.fill)&&void 0!==_ref2?_ref2:_ref&&markDef.color)property.fill=signalOrValueRef(_getMaxValue)}property.stroke&&("stroke"===channel||!_ref&&"color"===channel?delete property.stroke:property.stroke.field||_legendCmpt$get2?delete property.stroke:vega.isArray(property.stroke)&&(_ref2=getFirstDefined(getFirstConditionValue(encoding.stroke||encoding.color),markDef.stroke,_ref?markDef.color:
void 0))&&(property.stroke={value:_ref2}));"opacity"!==channel&&((_ref2=isFieldDef(fieldOrDatumDef)&&selectedCondition(model,legendCmpt,fieldOrDatumDef))?property.opacity=[Object.assign({},{test:_ref2},signalOrValueRef(null!==_legendCmpt$get3&&void 0!==_legendCmpt$get3?_legendCmpt$get3:1)),signalOrValueRef(config.legend.unselectedOpacity)]:_legendCmpt$get3&&(property.opacity=signalOrValueRef(_legendCmpt$get3)));property=Object.assign({},property,symbolsSpec);return isEmpty(property)?void 0:property}},
gradient:function(gradientSpec,_ref3){var _legendCmpt$get4;let {model,legendType,legendCmpt}=_ref3;if("gradient"===legendType){var {config,markDef,encoding}=model;_ref3={};var opacity=void 0===(null!==(_legendCmpt$get4=legendCmpt.get("gradientOpacity"))&&void 0!==_legendCmpt$get4?_legendCmpt$get4:config.legend.gradientOpacity)?getMaxValue(encoding.opacity)||markDef.opacity:void 0;opacity&&(_ref3.opacity=signalOrValueRef(opacity));_ref3=Object.assign({},_ref3,gradientSpec);return isEmpty(_ref3)?void 0:
_ref3}},labels:function(specifiedlabelsSpec,_ref4){let {fieldOrDatumDef,model,channel,legendCmpt}=_ref4;_ref4=model.legend(channel)||{};const config=model.config;var condition=isFieldDef(fieldOrDatumDef)?selectedCondition(model,legendCmpt,fieldOrDatumDef):void 0;condition=condition?[{test:condition,value:1},{value:config.legend.unselectedOpacity}]:void 0;const {format,formatType}=_ref4;_ref4=isCustomFormatType(formatType)?formatCustomType({fieldOrDatumDef,field:"datum.value",format,formatType,config}):
void 0;specifiedlabelsSpec=Object.assign({},condition?{opacity:condition}:{},_ref4?{text:_ref4}:{},specifiedlabelsSpec);return isEmpty(specifiedlabelsSpec)?void 0:specifiedlabelsSpec},entries:function(entriesSpec,_ref5){({legendCmpt:_ref5}=_ref5);_ref5=_ref5.get("selections");return null!==_ref5&&void 0!==_ref5&&_ref5.length?Object.assign({},entriesSpec,{fill:{value:"transparent"}}):entriesSpec}},legendRules={direction:_ref=>{({direction:_ref}=_ref);return _ref},format:_ref2=>{let {fieldOrDatumDef,
legend,config}=_ref2;const {format,formatType}=legend;return guideFormat(fieldOrDatumDef,fieldOrDatumDef.type,format,formatType,config,!1)},formatType:_ref3=>{let {legend,fieldOrDatumDef,scaleType}=_ref3;({formatType:_ref3}=legend);return guideFormatType(_ref3,fieldOrDatumDef,scaleType)},gradientLength:params=>{var _ref4,_legend$gradientLengt;const {legend,legendConfig}=params;if(null!==(_ref4=null!==(_legend$gradientLengt=legend.gradientLength)&&void 0!==_legend$gradientLengt?_legend$gradientLengt:
legendConfig.gradientLength)&&void 0!==_ref4)params=_ref4;else{{let {legendConfig,model,direction,orient,scaleType}=params;const {gradientHorizontalMaxLength,gradientHorizontalMinLength,gradientVerticalMaxLength,gradientVerticalMinLength}=legendConfig;params=CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)?"horizontal"===direction?"top"===orient||"bottom"===orient?gradientLengthSignal(model,"width",gradientHorizontalMinLength,gradientHorizontalMaxLength):gradientHorizontalMinLength:gradientLengthSignal(model,
"height",gradientVerticalMinLength,gradientVerticalMaxLength):void 0}}return params},labelOverlap:_ref5=>{var _ref6,_legend$labelOverlap;let {legend,legendConfig,scaleType}=_ref5;_ref5=null!==(_ref6=null!==(_legend$labelOverlap=legend.labelOverlap)&&void 0!==_legend$labelOverlap?_legend$labelOverlap:legendConfig.labelOverlap)&&void 0!==_ref6?_ref6:contains(["quantile","threshold","log","symlog"],scaleType)?"greedy":void 0;return _ref5},symbolType:_ref7=>{var _legend$symbolType;let {legend,markDef,
channel,encoding}=_ref7;if(null!==(_legend$symbolType=legend.symbolType)&&void 0!==_legend$symbolType)var JSCompiler_temp=_legend$symbolType;else a:{_ref7=markDef.type;_legend$symbolType=markDef.shape;if("shape"!==channel){const shape=null!==(JSCompiler_temp=getFirstConditionValue(encoding.shape))&&void 0!==JSCompiler_temp?JSCompiler_temp:_legend$symbolType;if(shape){JSCompiler_temp=shape;break a}}switch(_ref7){case "bar":case "rect":case "image":case "square":JSCompiler_temp="square";break a;case "line":case "trail":case "rule":JSCompiler_temp=
"stroke";break a;case "arc":case "point":case "circle":case "tick":case "geoshape":case "area":case "text":JSCompiler_temp="circle";break a}JSCompiler_temp=void 0}return JSCompiler_temp},title:_ref8=>{let {fieldOrDatumDef,config}=_ref8;return title$jscomp$0(fieldOrDatumDef,config,{allowDisabling:!0})},type:_ref9=>{let {legendType,scaleType,channel}=_ref9;if(isColorChannel(channel)&&CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)){if("gradient"===legendType)return}else if("symbol"===legendType)return;
return legendType},values:_ref10=>{let {fieldOrDatumDef,legend}=_ref10;_ref10=legend.values;_ref10=vega.isArray(_ref10)?valueArray(fieldOrDatumDef,_ref10):isSignalRef(_ref10)?_ref10:void 0;return _ref10}},PROJECTION_PROPERTIES="type clipAngle clipExtent center rotate precision reflectX reflectY coefficient distance fraction lobes parallel radius ratio spacing tilt".split(" ");class ProjectionComponent extends Split{constructor(name,specifiedProjection,size,data){super(Object.assign({},specifiedProjection),
{name});this.specifiedProjection=specifiedProjection;this.size=size;this.data=data;_defineProperty(this,"merged",!1)}get isFit(){return!!this.data}}class BinNode extends DataFlowNode{clone(){return new BinNode(null,duplicate(this.bins))}constructor(parent,bins){super(parent);this.bins=bins}static makeFromEncoding(parent,model){const bins=model.reduceFieldDef((binComponentIndex,fieldDef,channel)=>{if(isTypedFieldDef(fieldDef)&&isBinning(fieldDef.bin)){const {key,binComponent}=createBinComponent(fieldDef,
fieldDef.bin,model);var JSCompiler_temp_const=Object,JSCompiler_temp_const$jscomp$0=JSCompiler_temp_const.assign,JSCompiler_temp_const$jscomp$1=binComponentIndex[key];var config=model.config;if(binRequiresRange(fieldDef,channel)){var _ref,_model$axis;const guide=isUnitModel(model)?null!==(_ref=null!==(_model$axis=model.axis(channel))&&void 0!==_model$axis?_model$axis:model.legend(channel))&&void 0!==_ref?_ref:{}:{};channel=vgField(fieldDef,{expr:"datum"});_ref=vgField(fieldDef,{expr:"datum",binSuffix:"end"});
fieldDef={formulaAs:vgField(fieldDef,{binSuffix:"range",forAs:!0}),formula:binFormatExpression(channel,_ref,guide.format,guide.formatType,config)}}else fieldDef={};binComponentIndex[key]=JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const,{},binComponent,JSCompiler_temp_const$jscomp$1,fieldDef)}return binComponentIndex},{});return isEmpty(bins)?null:new BinNode(parent,bins)}static makeFromTransform(parent,t,model){const {key,binComponent}=createBinComponent(t,t.bin,model);return new BinNode(parent,
{[key]:binComponent})}merge(other,renameSignal){for(const key of keys$jscomp$0(other.bins))key in this.bins?(renameSignal(other.bins[key].signal,this.bins[key].signal),this.bins[key].as=unique([...this.bins[key].as,...other.bins[key].as],hash)):this.bins[key]=other.bins[key];for(const child of other.children)other.removeChild(child),child.parent=this;other.remove()}producedFields(){return new Set(vals$jscomp$0(this.bins).map(c=>c.as).flat(2))}dependentFields(){return new Set(vals$jscomp$0(this.bins).map(c=>
c.field))}hash(){return"Bin ".concat(hash(this.bins))}assemble(){return vals$jscomp$0(this.bins).flatMap(bin=>{const transform=[],[binAs,...remainingAs]=bin.as;var $jscomp$destructuring$var121=bin.bin,$jscomp$destructuring$var122=Object.assign({},$jscomp$destructuring$var121);$jscomp$destructuring$var121=$jscomp$destructuring$var121.extent;$jscomp$destructuring$var122=(delete $jscomp$destructuring$var122.extent,$jscomp$destructuring$var122);$jscomp$destructuring$var122=Object.assign({},{type:"bin",
field:replacePathInField(bin.field),as:binAs,signal:bin.signal},isParameterExtent($jscomp$destructuring$var121)?{extent:null}:{extent:$jscomp$destructuring$var121},bin.span?{span:{signal:"span(".concat(bin.span,")")}}:{},$jscomp$destructuring$var122);!$jscomp$destructuring$var121&&bin.extentSignal&&(transform.push({type:"extent",field:replacePathInField(bin.field),signal:bin.extentSignal}),$jscomp$destructuring$var122.extent={signal:bin.extentSignal});transform.push($jscomp$destructuring$var122);
for(const as of remainingAs)for($jscomp$destructuring$var121=0;2>$jscomp$destructuring$var121;$jscomp$destructuring$var121++)transform.push({type:"formula",expr:vgField({field:binAs[$jscomp$destructuring$var121]},{expr:"datum"}),as:as[$jscomp$destructuring$var121]});bin.formula&&transform.push({type:"formula",expr:bin.formula,as:bin.formulaAs});return transform})}}class AggregateNode extends DataFlowNode{clone(){return new AggregateNode(null,new Set(this.dimensions),duplicate(this.measures))}constructor(parent,
dimensions,measures){super(parent);this.dimensions=dimensions;this.measures=measures}get groupBy(){return this.dimensions}static makeFromEncoding(parent,model){let isAggregate=!1;model.forEachFieldDef(fd=>{fd.aggregate&&(isAggregate=!0)});const meas={},dims=new Set;if(!isAggregate)return null;model.forEachFieldDef((fieldDef,channel)=>{const {aggregate,field}=fieldDef;if(aggregate)if("count"===aggregate){var _meas$_;null!==(_meas$_=meas["*"])&&void 0!==_meas$_?_meas$_:meas["*"]={};meas["*"].count=
new Set([vgField(fieldDef,{forAs:!0})])}else{if(isArgminDef(aggregate)||isArgmaxDef(aggregate)){var _meas$argField;fieldDef=isArgminDef(aggregate)?"argmin":"argmax";var argField=aggregate[fieldDef];null!==(_meas$argField=meas[argField])&&void 0!==_meas$argField?_meas$argField:meas[argField]={};meas[argField][fieldDef]=new Set([vgField({op:fieldDef,field:argField},{forAs:!0})])}else{var _meas$field;null!==(_meas$field=meas[field])&&void 0!==_meas$field?_meas$field:meas[field]={};meas[field][aggregate]=
new Set([vgField(fieldDef,{forAs:!0})])}if(SCALE_CHANNEL_INDEX[channel]&&"unaggregated"===model.scaleDomain(channel)){var _meas$field2;null!==(_meas$field2=meas[field])&&void 0!==_meas$field2?_meas$field2:meas[field]={};meas[field].min=new Set([vgField({field,aggregate:"min"},{forAs:!0})]);meas[field].max=new Set([vgField({field,aggregate:"max"},{forAs:!0})])}}else{_meas$argField=isUnitModel(model)?model.encoding[getSecondaryRangeChannel(channel)]:void 0;isTypedFieldDef(fieldDef)&&isUnitModel(model)&&
hasBandEnd(fieldDef,_meas$argField,model.markDef,model.config)?(dims.add(vgField(fieldDef,{})),dims.add(vgField(fieldDef,{suffix:"end"})),fieldDef.bin&&binRequiresRange(fieldDef,channel)&&dims.add(vgField(fieldDef,{binSuffix:"range"}))):channel in GEO_POSIITON_CHANNEL_INDEX?(channel=getPositionChannelFromLatLong(channel),dims.add(model.getName(channel))):dims.add(vgField(fieldDef));if(channel=isScaleFieldDef(fieldDef))channel=null===(argField=fieldDef.scale)||void 0===argField?void 0:argField.range,
channel=vega.isObject(channel)&&"field"in channel;channel&&dims.add(fieldDef.scale.range.field)}});return 0===dims.size+keys$jscomp$0(meas).length?null:new AggregateNode(parent,dims,meas)}static makeFromTransform(parent,t){const dims=new Set,meas={};for(const s of t.aggregate){const {op,field,as}=s;if(op)if("count"===op){var _meas$_2;null!==(_meas$_2=meas["*"])&&void 0!==_meas$_2?_meas$_2:meas["*"]={};meas["*"].count=new Set([as?as:vgField(s,{forAs:!0})])}else{var _meas$field3;null!==(_meas$field3=
meas[field])&&void 0!==_meas$field3?_meas$field3:meas[field]={};meas[field][op]=new Set([as?as:vgField(s,{forAs:!0})])}}for(const s of null!==(_t$groupby=t.groupby)&&void 0!==_t$groupby?_t$groupby:[]){var _t$groupby;dims.add(s)}return 0===dims.size+keys$jscomp$0(meas).length?null:new AggregateNode(parent,dims,meas)}merge(other){if(setEqual(this.dimensions,other.dimensions)){var parentMeasures=this.measures;other=other.measures;for(const field of keys$jscomp$0(other)){const ops=other[field];for(const op of keys$jscomp$0(ops))if(field in
parentMeasures){var _parentMeasures$field;parentMeasures[field][op]=new Set([...(null!==(_parentMeasures$field=parentMeasures[field][op])&&void 0!==_parentMeasures$field?_parentMeasures$field:[]),...ops[op]])}else parentMeasures[field]={[op]:ops[op]}}return!0}debug("different dimensions, cannot merge");return!1}addDimensions(fields){fields.forEach(this.dimensions.add,this.dimensions)}dependentFields(){return new Set([...this.dimensions,...keys$jscomp$0(this.measures)])}producedFields(){const out=
new Set;for(const field of keys$jscomp$0(this.measures))for(const op of keys$jscomp$0(this.measures[field])){const m=this.measures[field][op];0===m.size?out.add("".concat(op,"_").concat(field)):m.forEach(out.add,out)}return out}hash(){return"Aggregate ".concat(hash({dimensions:this.dimensions,measures:this.measures}))}assemble(){const ops=[],fields=[],as=[];for(const field of keys$jscomp$0(this.measures))for(const op of keys$jscomp$0(this.measures[field]))for(const alias of this.measures[field][op])as.push(alias),
ops.push(op),fields.push("*"===field?null:replacePathInField(field));return{type:"aggregate",groupby:[...this.dimensions].map(replacePathInField),ops,fields,as}}}class FacetNode extends DataFlowNode{constructor(parent,model,name,data){super(parent);this.model=model;this.name=name;this.data=data;_defineProperty(this,"column",void 0);_defineProperty(this,"row",void 0);_defineProperty(this,"facet",void 0);_defineProperty(this,"childModel",void 0);for(const channel of FACET_CHANNELS)if(parent=model.facet[channel]){const {bin,
sort}=parent;this[channel]=Object.assign({},{name:model.getName("".concat(channel,"_domain")),fields:[vgField(parent),...(isBinning(bin)?[vgField(parent,{binSuffix:"end"})]:[])]},isSortField(sort)?{sortField:sort}:vega.isArray(sort)?{sortIndexField:sortArrayIndexField(parent,channel)}:{})}this.childModel=model.child}hash(){let out="Facet";for(const channel of FACET_CHANNELS)this[channel]&&(out+=" ".concat(channel.charAt(0),":").concat(hash(this[channel])));return out}get fields(){const f=[];for(const channel of FACET_CHANNELS){var _this$channel;
null!==(_this$channel=this[channel])&&void 0!==_this$channel&&_this$channel.fields&&f.push(...this[channel].fields)}return f}dependentFields(){const depFields=new Set(this.fields);for(const channel of FACET_CHANNELS)this[channel]&&(this[channel].sortField&&depFields.add(this[channel].sortField.field),this[channel].sortIndexField&&depFields.add(this[channel].sortIndexField));return depFields}producedFields(){return new Set}getSource(){return this.name}getChildIndependentFieldsWithStep(){const childIndependentFieldsWithStep=
{};for(const channel of POSITION_SCALE_CHANNELS){var childScaleComponent=this.childModel.component.scales[channel];if(childScaleComponent&&!childScaleComponent.merged){var type=childScaleComponent.get("type");childScaleComponent=childScaleComponent.get("range");hasDiscreteDomain(type)&&isVgRangeStep(childScaleComponent)&&(type=assembleDomain(this.childModel,channel),(type=getFieldFromDomain(type))?childIndependentFieldsWithStep[channel]=type:warn(unknownField(channel)))}}return childIndependentFieldsWithStep}assembleRowColumnHeaderData(channel,
crossedDataName,childIndependentFieldsWithStep){const childChannel={row:"y",column:"x",facet:void 0}[channel],fields=[],ops=[],as=[];childChannel&&childIndependentFieldsWithStep&&childIndependentFieldsWithStep[childChannel]&&(crossedDataName?(fields.push("distinct_".concat(childIndependentFieldsWithStep[childChannel])),ops.push("max")):(fields.push(childIndependentFieldsWithStep[childChannel]),ops.push("distinct")),as.push("distinct_".concat(childIndependentFieldsWithStep[childChannel])));const {sortField,
sortIndexField}=this[channel];if(sortField){const {op="min",field}=sortField;fields.push(field);ops.push(op);as.push(vgField(sortField,{forAs:!0}))}else sortIndexField&&(fields.push(sortIndexField),ops.push("max"),as.push(sortIndexField));return{name:this[channel].name,source:null!==crossedDataName&&void 0!==crossedDataName?crossedDataName:this.data,transform:[Object.assign({},{type:"aggregate",groupby:this[channel].fields},fields.length?{fields,ops,as}:{})]}}assembleFacetHeaderData(childIndependentFieldsWithStep){const {columns}=
this.model.layout,{layoutHeaders}=this.model.component,data=[],hasSharedAxis={};for(const headerChannel of HEADER_CHANNELS){for(const headerType of HEADER_TYPES){var _ref,headers=null!==(_ref=layoutHeaders[headerChannel]&&layoutHeaders[headerChannel][headerType])&&void 0!==_ref?_ref:[];for(const header of headers){var _header$axes;if(0<(null===(_header$axes=header.axes)||void 0===_header$axes?void 0:_header$axes.length)){hasSharedAxis[headerChannel]=!0;break}}}hasSharedAxis[headerChannel]&&(headers=
'length(data("'.concat(this.facet.name,'"))'),headers="row"===headerChannel?columns?{signal:"ceil(".concat(headers," / ").concat(columns,")")}:1:columns?{signal:"min(".concat(headers,", ").concat(columns,")")}:{signal:headers},data.push({name:"".concat(this.facet.name,"_").concat(headerChannel),transform:[{type:"sequence",start:0,stop:headers}]}))}const {row,column}=hasSharedAxis;(row||column)&&data.unshift(this.assembleRowColumnHeaderData("facet",null,childIndependentFieldsWithStep));return data}assemble(){const data=
[];var crossedDataName=null;const childIndependentFieldsWithStep=this.getChildIndependentFieldsWithStep(),{column,row,facet}=this;if(column&&row&&(childIndependentFieldsWithStep.x||childIndependentFieldsWithStep.y)){var _childIndependentFiel,_childIndependentFiel2;crossedDataName="cross_".concat(this.column.name,"_").concat(this.row.name);const fields=[].concat(null!==(_childIndependentFiel=childIndependentFieldsWithStep.x)&&void 0!==_childIndependentFiel?_childIndependentFiel:[],null!==(_childIndependentFiel2=
childIndependentFieldsWithStep.y)&&void 0!==_childIndependentFiel2?_childIndependentFiel2:[]);_childIndependentFiel=fields.map(()=>"distinct");data.push({name:crossedDataName,source:this.data,transform:[{type:"aggregate",groupby:this.fields,fields,ops:_childIndependentFiel}]})}for(const channel of["column","row"])this[channel]&&data.push(this.assembleRowColumnHeaderData(channel,crossedDataName,childIndependentFieldsWithStep));facet&&(crossedDataName=this.assembleFacetHeaderData(childIndependentFieldsWithStep))&&
data.push(...crossedDataName);return data}}class ParseNode extends DataFlowNode{clone(){return new ParseNode(null,duplicate(this._parse))}constructor(parent,parse){super(parent);_defineProperty(this,"_parse",void 0);this._parse=parse}hash(){return"Parse ".concat(hash(this._parse))}static makeExplicit(parent,model,ancestorParse){var _data$format;let explicit={};model=model.data;!isGenerator(model)&&null!==model&&void 0!==model&&null!==(_data$format=model.format)&&void 0!==_data$format&&_data$format.parse&&
(explicit=model.format.parse);return this.makeWithAncestors(parent,explicit,{},ancestorParse)}static makeWithAncestors(parent,explicit,implicit,ancestorParse){for(var field of keys$jscomp$0(implicit)){const parsedAs=ancestorParse.getWithExplicit(field);void 0!==parsedAs.value&&(parsedAs.explicit||parsedAs.value===implicit[field]||"derived"===parsedAs.value||"flatten"===implicit[field]?delete implicit[field]:warn(differentParse(field,implicit[field],parsedAs.value)))}for(var field$jscomp$0 of keys$jscomp$0(explicit))field=
ancestorParse.get(field$jscomp$0),void 0!==field&&(field===explicit[field$jscomp$0]?delete explicit[field$jscomp$0]:warn(differentParse(field$jscomp$0,explicit[field$jscomp$0],field)));explicit=new Split(explicit,implicit);ancestorParse.copyAll(explicit);implicit={};for(const key of keys$jscomp$0(explicit.combine()))field$jscomp$0=explicit.get(key),null!==field$jscomp$0&&(implicit[key]=field$jscomp$0);return 0===keys$jscomp$0(implicit).length||ancestorParse.parseNothing?null:new ParseNode(parent,
implicit)}get parse(){return this._parse}merge(other){this._parse=Object.assign({},this._parse,other.parse);other.remove()}assembleFormatParse(){const formatParse={};for(const field of keys$jscomp$0(this._parse)){const p=this._parse[field];1===accessPathDepth(field)&&(formatParse[field]=p)}return formatParse}producedFields(){return new Set(keys$jscomp$0(this._parse))}dependentFields(){return new Set(keys$jscomp$0(this._parse))}assembleTransforms(){let onlyNested=0<arguments.length&&void 0!==arguments[0]?
arguments[0]:!1;return keys$jscomp$0(this._parse).filter(field=>onlyNested?1<accessPathDepth(field):!0).map(field=>{const expr=parseExpression(field,this._parse[field]);return expr?{type:"formula",expr,as:removePathFromField(field)}:null}).filter(t=>null!==t)}}class IdentifierNode extends DataFlowNode{clone(){return new IdentifierNode(null)}constructor(parent){super(parent)}dependentFields(){return new Set}producedFields(){return new Set(["_vgsid_"])}hash(){return"Identifier"}assemble(){return{type:"identifier",
as:"_vgsid_"}}}class GraticuleNode extends DataFlowNode{clone(){return new GraticuleNode(null,this.params)}constructor(parent,params){super(parent);this.params=params}dependentFields(){return new Set}producedFields(){}hash(){return"Graticule ".concat(hash(this.params))}assemble(){return Object.assign({},{type:"graticule"},!0===this.params?{}:this.params)}}class SequenceNode extends DataFlowNode{clone(){return new SequenceNode(null,this.params)}constructor(parent,params){super(parent);this.params=
params}dependentFields(){return new Set}producedFields(){var _this$params$as;return new Set([null!==(_this$params$as=this.params.as)&&void 0!==_this$params$as?_this$params$as:"data"])}hash(){return"Hash ".concat(hash(this.params))}assemble(){return Object.assign({},{type:"sequence"},this.params)}}class SourceNode extends DataFlowNode{constructor(data){var _data;super(null);_defineProperty(this,"_data",void 0);_defineProperty(this,"_name",void 0);_defineProperty(this,"_generator",void 0);null!==(_data=
data)&&void 0!==_data?_data:data={name:"source"};let format;isGenerator(data)||(format=data.format?Object.assign({},omit(data.format,["parse"])):{});if("values"in data)this._data={values:data.values};else if("url"in data)this._data={url:data.url},format.type||(_data=/(?:\.([^.]+))?$/.exec(data.url)[1],contains(["json","csv","tsv","dsv","topojson"],_data)||(_data="json"),format.type=_data);else if("sphere"in data)this._data={values:[{type:"Sphere"}]};else if(isNamedData(data)||isGenerator(data))this._data=
{};this._generator=isGenerator(data);data.name&&(this._name=data.name);format&&!isEmpty(format)&&(this._data.format=format)}dependentFields(){return new Set}producedFields(){}get data(){return this._data}hasName(){return!!this._name}get isGenerator(){return this._generator}get dataName(){return this._name}set dataName(name){this._name=name}set parent(parent){throw Error("Source nodes have to be roots.");}remove(){throw Error("Source nodes are roots and cannot be removed.");}hash(){throw Error("Cannot hash sources");
}assemble(){return Object.assign({},{name:this._name},this._data,{transform:[]})}}var _modified=new WeakMap;class Optimizer{constructor(){if(_modified.has(this))throw new TypeError("Cannot initialize the same private elements twice on an object");_modified.set(this,{writable:!0,value:void 0});_classPrivateFieldSet(this,_modified,!1)}setModified(){_classPrivateFieldSet(this,_modified,!0)}get modifiedFlag(){var descriptor=_classExtractFieldDescriptor(this,_modified,"get");return descriptor.get?descriptor.get.call(this):
descriptor.value}}class BottomUpOptimizer extends Optimizer{getNodeDepths(node,depth,depths){depths.set(node,depth);for(const child of node.children)this.getNodeDepths(child,depth+1,depths);return depths}optimize(node){node=[...this.getNodeDepths(node,0,new Map).entries()].sort((a,b)=>b[1]-a[1]);for(const tuple of node)this.run(tuple[0]);return this.modifiedFlag}}class TopDownOptimizer extends Optimizer{optimize(node){this.run(node);for(const child of node.children)this.optimize(child);return this.modifiedFlag}}
class MergeIdenticalNodes extends TopDownOptimizer{mergeNodes(parent,nodes){const mergedNode=nodes.shift();for(const node of nodes)parent.removeChild(node),node.parent=mergedNode,node.remove()}run(node){const hashes=node.children.map(x=>x.hash()),buckets={};for(let i=0;i<hashes.length;i++)void 0===buckets[hashes[i]]?buckets[hashes[i]]=[node.children[i]]:buckets[hashes[i]].push(node.children[i]);for(const k of keys$jscomp$0(buckets))1<buckets[k].length&&(this.setModified(),this.mergeNodes(node,buckets[k]))}}
class RemoveUnnecessaryIdentifierNodes extends TopDownOptimizer{constructor(model){super();_defineProperty(this,"requiresSelectionId",void 0);this.requiresSelectionId=model&&requiresSelectionId(model)}run(node){!(node instanceof IdentifierNode)||this.requiresSelectionId&&(isDataSourceNode(node.parent)||node.parent instanceof AggregateNode||node.parent instanceof ParseNode)||(this.setModified(),node.remove())}}class RemoveDuplicateTimeUnits extends Optimizer{optimize(node){this.run(node,new Set);return this.modifiedFlag}run(node,
timeUnitFields){let producedFields=new Set;node instanceof TimeUnitNode&&(producedFields=node.producedFields(),hasIntersection(producedFields,timeUnitFields)&&(this.setModified(),node.removeFormulas(timeUnitFields),0===node.producedFields.length&&node.remove()));for(const child of node.children)this.run(child,new Set([...timeUnitFields,...producedFields]))}}class RemoveUnnecessaryOutputNodes extends TopDownOptimizer{constructor(){super()}run(node){node instanceof OutputNode&&!node.isRequired()&&(this.setModified(),
node.remove())}}class MoveParseUp extends BottomUpOptimizer{run(node){if(!(isDataSourceNode(node)||1<node.numChildren()))for(const child of node.children)child instanceof ParseNode&&(node instanceof ParseNode?(this.setModified(),node.merge(child)):fieldIntersection(node.producedFields(),child.dependentFields())||(this.setModified(),child.swapWithParent()))}}class MergeParse extends BottomUpOptimizer{run(node){const originalChildren=[...node.children];var parseChildren=node.children.filter(child=>
child instanceof ParseNode);if(1<node.numChildren()&&1<=parseChildren.length){const commonParse={};var conflictingParse=new Set;for(const parseNode of parseChildren){parseChildren=parseNode.parse;for(const k of keys$jscomp$0(parseChildren))k in commonParse?commonParse[k]!==parseChildren[k]&&conflictingParse.add(k):commonParse[k]=parseChildren[k]}for(const field of conflictingParse)delete commonParse[field];if(!isEmpty(commonParse)){this.setModified();conflictingParse=new ParseNode(node,commonParse);
for(const childNode of originalChildren){if(childNode instanceof ParseNode)for(const key of keys$jscomp$0(commonParse))delete childNode.parse[key];node.removeChild(childNode);childNode.parent=conflictingParse;childNode instanceof ParseNode&&0===keys$jscomp$0(childNode.parse).length&&childNode.remove()}}}}}class RemoveUnusedSubtrees extends BottomUpOptimizer{run(node){node instanceof OutputNode||0<node.numChildren()||node instanceof FacetNode||node instanceof SourceNode||(this.setModified(),node.remove())}}
class MergeTimeUnits extends BottomUpOptimizer{run(node){node=node.children.filter(x=>x instanceof TimeUnitNode);const combination=node.pop();for(const timeUnit of node)this.setModified(),combination.merge(timeUnit)}}class MergeAggregates extends BottomUpOptimizer{run(node){var aggChildren=node.children.filter(child=>child instanceof AggregateNode);const groupedAggregates={};for(var agg$jscomp$0 of aggChildren)aggChildren=hash(agg$jscomp$0.groupBy),aggChildren in groupedAggregates||(groupedAggregates[aggChildren]=
[]),groupedAggregates[aggChildren].push(agg$jscomp$0);for(const group of keys$jscomp$0(groupedAggregates))if(agg$jscomp$0=groupedAggregates[group],1<agg$jscomp$0.length){aggChildren=agg$jscomp$0.pop();for(const agg of agg$jscomp$0)aggChildren.merge(agg)&&(node.removeChild(agg),agg.parent=aggChildren,agg.remove(),this.setModified())}}}class MergeBins extends BottomUpOptimizer{constructor(model){super();this.model=model}run(node){var moveBinsUp=!(isDataSourceNode(node)||node instanceof FilterNode||
node instanceof ParseNode||node instanceof IdentifierNode);const promotableBins=[],remainingBins=[];for(const child of node.children)child instanceof BinNode&&(moveBinsUp&&!fieldIntersection(node.producedFields(),child.dependentFields())?promotableBins.push(child):remainingBins.push(child));if(0<promotableBins.length){moveBinsUp=promotableBins.pop();for(const bin of promotableBins)moveBinsUp.merge(bin,this.model.renameSignal.bind(this.model));this.setModified();node instanceof BinNode?node.merge(moveBinsUp,
this.model.renameSignal.bind(this.model)):moveBinsUp.swapWithParent()}if(1<remainingBins.length){node=remainingBins.pop();for(const bin of remainingBins)node.merge(bin,this.model.renameSignal.bind(this.model));this.setModified()}}}class MergeOutputs extends BottomUpOptimizer{run(node){var children=[...node.children];if(some(children,child=>child instanceof OutputNode)&&!(1>=node.numChildren())){var otherChildren=[];for(const child of children)if(child instanceof OutputNode){for(children=child;1===
children.numChildren();){const [theChild]=children.children;if(theChild instanceof OutputNode)children=theChild;else break}otherChildren.push(...children.children);if(mainOutput)node.removeChild(child),child.parent=mainOutput.parent,mainOutput.parent.removeChild(mainOutput),mainOutput.parent=children,this.setModified();else var mainOutput=children}else otherChildren.push(child);if(otherChildren.length){this.setModified();for(const child of otherChildren)child.parent.removeChild(child),child.parent=
mainOutput}}}}class JoinAggregateTransformNode extends DataFlowNode{clone(){return new JoinAggregateTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform}addDimensions(fields){this.transform.groupby=unique(this.transform.groupby.concat(fields),d=>d)}dependentFields(){const out=new Set;this.transform.groupby&&this.transform.groupby.forEach(out.add,out);this.transform.joinaggregate.map(w=>w.field).filter(f=>void 0!==f).forEach(out.add,out);
return out}producedFields(){return new Set(this.transform.joinaggregate.map(this.getDefaultName))}getDefaultName(joinAggregateFieldDef){var _joinAggregateFieldDe;return null!==(_joinAggregateFieldDe=joinAggregateFieldDef.as)&&void 0!==_joinAggregateFieldDe?_joinAggregateFieldDe:vgField(joinAggregateFieldDef)}hash(){return"JoinAggregateTransform ".concat(hash(this.transform))}assemble(){const fields=[],ops=[],as=[];for(var joinaggregate of this.transform.joinaggregate)ops.push(joinaggregate.op),as.push(this.getDefaultName(joinaggregate)),
fields.push(void 0===joinaggregate.field?null:joinaggregate.field);joinaggregate=this.transform.groupby;return Object.assign({},{type:"joinaggregate",as,ops,fields},void 0!==joinaggregate?{groupby:joinaggregate}:{})}}class StackNode extends DataFlowNode{clone(){return new StackNode(null,duplicate(this._stack))}constructor(parent,stack){super(parent);_defineProperty(this,"_stack",void 0);this._stack=stack}static makeFromTransform(parent,stackTransform){const {stack,groupby,as,offset="zero"}=stackTransform;
var sortFields=[];const sortOrder=[];if(void 0!==stackTransform.sort)for(const sortField of stackTransform.sort)sortFields.push(sortField.field),sortOrder.push(getFirstDefined(sortField.order,"ascending"));sortFields={field:sortFields,order:sortOrder};stackTransform=isValidAsArray(as)?as:vega.isString(as)?[as,"".concat(as,"_end")]:["".concat(stackTransform.stack,"_start"),"".concat(stackTransform.stack,"_end")];return new StackNode(parent,{dimensionFieldDefs:[],stackField:stack,groupby,offset,sort:sortFields,
facetby:[],as:stackTransform})}static makeFromEncoding(parent,model){var stackProperties=model.stack;const {encoding}=model;if(!stackProperties)return null;const {groupbyChannels,fieldChannel,offset,impute}=stackProperties;stackProperties=groupbyChannels.map(groupbyChannel=>getFieldDef(encoding[groupbyChannel])).filter(def=>!!def);const stackby=getStackByFields(model);var orderDef=model.encoding.order;orderDef=vega.isArray(orderDef)||isFieldDef(orderDef)?sortParams(orderDef):stackby.reduce((s,field)=>
{s.field.push(field);s.order.push("y"===fieldChannel?"descending":"ascending");return s},{field:[],order:[]});return new StackNode(parent,{dimensionFieldDefs:stackProperties,stackField:model.vgField(fieldChannel),facetby:[],stackby,sort:orderDef,offset,impute,as:[model.vgField(fieldChannel,{suffix:"start",forAs:!0}),model.vgField(fieldChannel,{suffix:"end",forAs:!0})]})}get stack(){return this._stack}addDimensions(fields){this._stack.facetby.push(...fields)}dependentFields(){const out=new Set;out.add(this._stack.stackField);
this.getGroupbyFields().forEach(out.add,out);this._stack.facetby.forEach(out.add,out);this._stack.sort.field.forEach(out.add,out);return out}producedFields(){return new Set(this._stack.as)}hash(){return"Stack ".concat(hash(this._stack))}getGroupbyFields(){const {dimensionFieldDefs,impute,groupby}=this._stack;return 0<dimensionFieldDefs.length?dimensionFieldDefs.map(dimensionFieldDef=>dimensionFieldDef.bin?impute?[vgField(dimensionFieldDef,{binSuffix:"mid"})]:[vgField(dimensionFieldDef,{}),vgField(dimensionFieldDef,
{binSuffix:"end"})]:[vgField(dimensionFieldDef)]).flat():null!==groupby&&void 0!==groupby?groupby:[]}assemble(){const transform=[],{facetby,dimensionFieldDefs,stackField:field,stackby,sort,offset,impute,as}=this._stack;if(impute)for(const dimensionFieldDef of dimensionFieldDefs){const {bandPosition=.5,bin}=dimensionFieldDef;if(bin){const binStart=vgField(dimensionFieldDef,{expr:"datum"}),binEnd=vgField(dimensionFieldDef,{expr:"datum",binSuffix:"end"});transform.push({type:"formula",expr:"".concat(bandPosition,
"*").concat(binStart,"+").concat(1-bandPosition,"*").concat(binEnd),as:vgField(dimensionFieldDef,{binSuffix:"mid",forAs:!0})})}transform.push({type:"impute",field,groupby:[...stackby,...facetby],key:vgField(dimensionFieldDef,{binSuffix:"mid"}),method:"value",value:0})}transform.push({type:"stack",groupby:[...this.getGroupbyFields(),...facetby],field,sort,as,offset});return transform}}class WindowTransformNode extends DataFlowNode{clone(){return new WindowTransformNode(null,duplicate(this.transform))}constructor(parent,
transform){super(parent);this.transform=transform}addDimensions(fields){this.transform.groupby=unique(this.transform.groupby.concat(fields),d=>d)}dependentFields(){var _this$transform$group,_this$transform$sort;const out=new Set;(null!==(_this$transform$group=this.transform.groupby)&&void 0!==_this$transform$group?_this$transform$group:[]).forEach(out.add,out);(null!==(_this$transform$sort=this.transform.sort)&&void 0!==_this$transform$sort?_this$transform$sort:[]).forEach(m=>out.add(m.field));this.transform.window.map(w=>
w.field).filter(f=>void 0!==f).forEach(out.add,out);return out}producedFields(){return new Set(this.transform.window.map(this.getDefaultName))}getDefaultName(windowFieldDef){var _windowFieldDef$as;return null!==(_windowFieldDef$as=windowFieldDef.as)&&void 0!==_windowFieldDef$as?_windowFieldDef$as:vgField(windowFieldDef)}hash(){return"WindowTransform ".concat(hash(this.transform))}assemble(){const fields=[],ops=[],as=[],params=[];for(var window of this.transform.window)ops.push(window.op),as.push(this.getDefaultName(window)),
params.push(void 0===window.param?null:window.param),fields.push(void 0===window.field?null:window.field);window=this.transform.frame;const groupby=this.transform.groupby;if(window&&null===window[0]&&null===window[1]&&ops.every(o=>isAggregateOp(o)))return Object.assign({},{type:"joinaggregate",as,ops,fields},void 0!==groupby?{groupby}:{});const sortFields=[],sortOrder=[];if(void 0!==this.transform.sort)for(const sortField of this.transform.sort){var _sortField$order;sortFields.push(sortField.field);
sortOrder.push(null!==(_sortField$order=sortField.order)&&void 0!==_sortField$order?_sortField$order:"ascending")}_sortField$order=this.transform.ignorePeers;return Object.assign({},{type:"window",params,as,ops,fields,sort:{field:sortFields,order:sortOrder}},void 0!==_sortField$order?{ignorePeers:_sortField$order}:{},void 0!==groupby?{groupby}:{},void 0!==window?{frame:window}:{})}}class SignalRefWrapper{constructor(exprGenerator){_defineProperty(this,"signal",void 0);Object.defineProperty(this,"signal",
{enumerable:!0,get:exprGenerator})}static fromName(rename,signalName){return new SignalRefWrapper(()=>rename(signalName))}}class ScaleComponent extends Split{constructor(name,typeWithExplicit){super({},{name});_defineProperty(this,"merged",!1);this.setWithExplicit("type",typeWithExplicit)}domainDefinitelyIncludesZero(){return!1!==this.get("zero")?!0:some(this.get("domains"),d=>vega.isArray(d)&&2===d.length&&0>=d[0]&&0<=d[1])}}const RANGE_PROPERTIES=["range","scheme"],scaleRules={bins:_ref=>{let {model,
fieldOrDatumDef}=_ref;return isFieldDef(fieldOrDatumDef)?bins$jscomp$1(model,fieldOrDatumDef):void 0},interpolate:_ref2=>{let {channel,fieldOrDatumDef}=_ref2;_ref2=fieldOrDatumDef.type;_ref2=contains(["color","fill","stroke"],channel)&&"nominal"!==_ref2?"hcl":void 0;return _ref2},nice:_ref3=>{let {scaleType,channel,domain,domainMin,domainMax,fieldOrDatumDef}=_ref3;var _getFieldDef;_ref3=null!==(_getFieldDef=getFieldDef(fieldOrDatumDef))&&void 0!==_getFieldDef&&_getFieldDef.bin||vega.isArray(domain)||
null!=domainMax||null!=domainMin||contains([ScaleType.TIME,ScaleType.UTC],scaleType)?void 0:isXorY(channel)?!0:void 0;return _ref3},padding:_ref4=>{let {channel,scaleType,fieldOrDatumDef,markDef,config}=_ref4;a:{_ref4=config.scale;var barConfig=config.bar;if(isXorY(channel)){if(CONTINUOUS_TO_CONTINUOUS_SCALES.has(scaleType)){if(void 0!==_ref4.continuousPadding){_ref4=_ref4.continuousPadding;break a}const {type,orient}=markDef;if("bar"===type&&(!isFieldDef(fieldOrDatumDef)||!fieldOrDatumDef.bin&&!fieldOrDatumDef.timeUnit)&&
("vertical"===orient&&"x"===channel||"horizontal"===orient&&"y"===channel)){_ref4=barConfig.continuousBandSize;break a}}if(scaleType===ScaleType.POINT){_ref4=_ref4.pointPadding;break a}}_ref4=void 0}return _ref4},paddingInner:_ref5=>{let {scalePadding,channel,markDef,scaleType,config,hasNestedOffsetScale}=_ref5;return paddingInner(scalePadding,channel,markDef.type,scaleType,config.scale,hasNestedOffsetScale)},paddingOuter:_ref6=>{let {scalePadding,channel,scaleType,scalePaddingInner,config,hasNestedOffsetScale}=
_ref6;return paddingOuter$jscomp$0(scalePadding,channel,scaleType,scalePaddingInner,config.scale,hasNestedOffsetScale)},reverse:_ref7=>{let {fieldOrDatumDef,scaleType,channel,config}=_ref7;_ref7=isFieldDef(fieldOrDatumDef)?fieldOrDatumDef.sort:void 0;var scaleConfig=config.scale;_ref7="x"===channel&&void 0!==scaleConfig.xReverse?hasContinuousDomain(scaleType)&&"descending"===_ref7?isSignalRef(scaleConfig.xReverse)?{signal:"!".concat(scaleConfig.xReverse.signal)}:!scaleConfig.xReverse:scaleConfig.xReverse:
hasContinuousDomain(scaleType)&&"descending"===_ref7?!0:void 0;return _ref7},zero:_ref8=>{let {channel,fieldOrDatumDef,domain,markDef,scaleType}=_ref8;a:if(domain&&"unaggregated"!==domain&&hasContinuousDomain(scaleType)){if(vega.isArray(domain)&&(_ref8=domain[domain.length-1],0>=domain[0]&&0<=_ref8)){_ref8=!0;break a}_ref8=!1}else if("size"!==channel||"quantitative"!==fieldOrDatumDef.type||CONTINUOUS_TO_DISCRETE_SCALES.has(scaleType))if(isFieldDef(fieldOrDatumDef)&&fieldOrDatumDef.bin||!contains([...POSITION_SCALE_CHANNELS,
...POLAR_POSITION_SCALE_CHANNELS],channel))_ref8=!1;else{const {orient,type}=markDef;_ref8=contains(["bar","area","line","trail"],type)&&("horizontal"===orient&&"y"===channel||"vertical"===orient&&"x"===channel)?!1:!0}else _ref8=!0;return _ref8}},scaleTypeTieBreaker=tieBreakByComparing((st1,st2)=>SCALE_PRECEDENCE_INDEX[st1]-SCALE_PRECEDENCE_INDEX[st2]);class NameMap{constructor(){_defineProperty(this,"nameMap",void 0);this.nameMap={}}rename(oldName,newName){this.nameMap[oldName]=newName}has(name){return void 0!==
this.nameMap[name]}get(name){for(;this.nameMap[name]&&name!==this.nameMap[name];)name=this.nameMap[name];return name}}class Model{constructor(spec,type,parent,parentGivenName,config,resolve,view){var _spec$name,_spec$transform;this.type=type;this.parent=parent;this.config=config;_defineProperty(this,"name",void 0);_defineProperty(this,"size",void 0);_defineProperty(this,"title",void 0);_defineProperty(this,"description",void 0);_defineProperty(this,"data",void 0);_defineProperty(this,"transforms",
void 0);_defineProperty(this,"layout",void 0);_defineProperty(this,"scaleNameMap",void 0);_defineProperty(this,"projectionNameMap",void 0);_defineProperty(this,"signalNameMap",void 0);_defineProperty(this,"component",void 0);_defineProperty(this,"view",void 0);_defineProperty(this,"children",void 0);_defineProperty(this,"correctDataNames",mark=>{var _mark$from,_mark$from2,_mark$from2$facet;null!==(_mark$from=mark.from)&&void 0!==_mark$from&&_mark$from.data&&(mark.from.data=this.lookupDataSource(mark.from.data));
null!==(_mark$from2=mark.from)&&void 0!==_mark$from2&&null!==(_mark$from2$facet=_mark$from2.facet)&&void 0!==_mark$from2$facet&&_mark$from2$facet.data&&(mark.from.facet.data=this.lookupDataSource(mark.from.facet.data));return mark});this.parent=parent;this.config=config;this.view=replaceExprRef(view);this.name=null!==(_spec$name=spec.name)&&void 0!==_spec$name?_spec$name:parentGivenName;this.title=isText(spec.title)?{text:spec.title}:spec.title?replaceExprRef(spec.title):void 0;this.scaleNameMap=
parent?parent.scaleNameMap:new NameMap;this.projectionNameMap=parent?parent.projectionNameMap:new NameMap;this.signalNameMap=parent?parent.signalNameMap:new NameMap;this.data=spec.data;this.description=spec.description;this.transforms=normalizeTransform(null!==(_spec$transform=spec.transform)&&void 0!==_spec$transform?_spec$transform:[]);this.layout="layer"===type||"unit"===type?{}:extractCompositionLayout(spec,type,config);this.component={data:{sources:parent?parent.component.data.sources:[],outputNodes:parent?
parent.component.data.outputNodes:{},outputNodeRefCounts:parent?parent.component.data.outputNodeRefCounts:{},isFaceted:"facet"in spec||(null===parent||void 0===parent?void 0:parent.component.data.isFaceted)&&void 0===spec.data},layoutSize:new Split,layoutHeaders:{row:{},column:{},facet:{}},mark:null,resolve:Object.assign({},{scale:{},axis:{},legend:{}},resolve?duplicate(resolve):{}),selection:null,scales:null,projection:null,axes:{},legends:{}}}get width(){return this.getSizeSignalRef("width")}get height(){return this.getSizeSignalRef("height")}parse(){this.parseScale();
this.parseLayoutSize();this.renameTopLevelLayoutSizeSignal();this.parseSelections();this.parseProjection();this.parseData();this.parseAxesAndHeaders();this.parseLegends();this.parseMarkGroup()}parseScale(){parseScales(this)}parseProjection(){parseProjection(this)}renameTopLevelLayoutSizeSignal(){"width"!==this.getName("width")&&this.renameSignal(this.getName("width"),"width");"height"!==this.getName("height")&&this.renameSignal(this.getName("height"),"height")}parseLegends(){parseLegend(this)}assembleEncodeFromView(view){view=
Object.assign({},view);view=(delete view.style,view);const e={};for(const property of keys$jscomp$0(view)){const value=view[property];void 0!==value&&(e[property]=signalOrValueRef(value))}return e}assembleGroupEncodeEntry(isTopLevel){let encodeEntry={};this.view&&(encodeEntry=this.assembleEncodeFromView(this.view));if(!isTopLevel&&(this.description&&(encodeEntry.description=signalOrValueRef(this.description)),"unit"===this.type||"layer"===this.type)){var _encodeEntry;return Object.assign({},{width:this.getSizeSignalRef("width"),
height:this.getSizeSignalRef("height")},null!==(_encodeEntry=encodeEntry)&&void 0!==_encodeEntry?_encodeEntry:{})}return isEmpty(encodeEntry)?void 0:encodeEntry}assembleLayout(){if(this.layout){var $jscomp$destructuring$var129=this.layout,$jscomp$destructuring$var130=Object.assign({},$jscomp$destructuring$var129);$jscomp$destructuring$var129=$jscomp$destructuring$var129.spacing;$jscomp$destructuring$var130=(delete $jscomp$destructuring$var130.spacing,$jscomp$destructuring$var130);var {component,config}=
this,headerComponentIndex=component.layoutHeaders,titleBand={};for(JSCompiler_inline_result of FACET_CHANNELS){var headerComponent=headerComponentIndex[JSCompiler_inline_result];if(null!==headerComponent&&void 0!==headerComponent&&headerComponent.facetFieldDef){const {titleAnchor,titleOrient}=getHeaderProperties(["titleAnchor","titleOrient"],headerComponent.facetFieldDef.header,config,JSCompiler_inline_result);headerComponent=getHeaderChannel(JSCompiler_inline_result,titleOrient);const band=LAYOUT_TITLE_BAND[headerComponent][titleAnchor];
void 0!==band&&(titleBand[headerComponent]=band)}}var JSCompiler_inline_result=isEmpty(titleBand)?void 0:titleBand;return Object.assign({},{padding:$jscomp$destructuring$var129},this.assembleDefaultLayout(),$jscomp$destructuring$var130,JSCompiler_inline_result?{titleBand:JSCompiler_inline_result}:{})}}assembleDefaultLayout(){return{}}assembleHeaderMarks(){var {layoutHeaders}=this.component,headerMarks=[];for(var channel$jscomp$0 of FACET_CHANNELS)if(layoutHeaders[channel$jscomp$0].title){var JSCompiler_temp_const=
headerMarks,JSCompiler_temp_const$jscomp$0=JSCompiler_temp_const.push;var JSCompiler_inline_result=channel$jscomp$0;var title=this.component.layoutHeaders[JSCompiler_inline_result].title,config=this.config?this.config:void 0,facetFieldDef=this.component.layoutHeaders[JSCompiler_inline_result].facetFieldDef?this.component.layoutHeaders[JSCompiler_inline_result].facetFieldDef:void 0;const {titleAnchor,titleAngle:ta,titleOrient}=getHeaderProperties(["titleAnchor","titleAngle","titleOrient"],facetFieldDef.header,
config,JSCompiler_inline_result);var headerChannel=getHeaderChannel(JSCompiler_inline_result,titleOrient),titleAngle=normalizeAngle(ta);JSCompiler_inline_result={name:"".concat(JSCompiler_inline_result,"-title"),type:"group",role:"".concat(headerChannel,"-title"),title:Object.assign({},{text:title},"row"===JSCompiler_inline_result?{orient:"left"}:{},{style:"guide-title"},defaultHeaderGuideBaseline(titleAngle,headerChannel),defaultHeaderGuideAlign(headerChannel,titleAngle,titleAnchor),assembleHeaderProperties(config,
facetFieldDef,JSCompiler_inline_result,HEADER_TITLE_PROPERTIES,HEADER_TITLE_PROPERTIES_MAP))};JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const,JSCompiler_inline_result)}for(const channel of HEADER_CHANNELS){layoutHeaders=headerMarks;headerMarks=layoutHeaders.concat;JSCompiler_temp_const=channel;JSCompiler_temp_const$jscomp$0=this.component.layoutHeaders[JSCompiler_temp_const];channel$jscomp$0=[];for(const headerType of HEADER_TYPES)if(JSCompiler_temp_const$jscomp$0[headerType])for(const headerComponent of JSCompiler_temp_const$jscomp$0[headerType]){a:{facetFieldDef=
void 0;JSCompiler_inline_result=JSCompiler_temp_const;var headerType$jscomp$0=headerType,layoutHeader=JSCompiler_temp_const$jscomp$0;if(title=headerComponent){config=null;({facetFieldDef:JSCompiler_inline_result$jscomp$0}=layoutHeader);headerChannel=this.config?this.config:void 0;JSCompiler_inline_result$jscomp$0&&title.labels&&({labelOrient:titleAngle}=getHeaderProperties(["labelOrient"],JSCompiler_inline_result$jscomp$0.header,headerChannel,JSCompiler_inline_result),"row"===JSCompiler_inline_result&&
!contains(["top","bottom"],titleAngle)||"column"===JSCompiler_inline_result&&!contains(["left","right"],titleAngle))&&(config=assembleLabelTitle(JSCompiler_inline_result$jscomp$0,JSCompiler_inline_result,headerChannel));const isFacetWithoutRowCol=isFacetModel(this)&&!isFacetMapping(this.facet),axes=title.axes,hasAxes=0<(null===axes||void 0===axes?void 0:axes.length);if(config||hasAxes){const sizeChannel="row"===JSCompiler_inline_result?"height":"width";headerChannel=Object;titleAngle=headerChannel.assign;
headerType$jscomp$0={name:this.getName("".concat(JSCompiler_inline_result,"_").concat(headerType$jscomp$0)),type:"group",role:"".concat(JSCompiler_inline_result,"-").concat(headerType$jscomp$0)};if(layoutHeader.facetFieldDef){layoutHeader={data:this.getName("".concat(JSCompiler_inline_result,"_domain"))};{var facetFieldDef$jscomp$0=JSCompiler_inline_result$jscomp$0;const {sort}=facetFieldDef$jscomp$0;var JSCompiler_inline_result$jscomp$0=isSortField(sort)?{field:vgField(sort,{expr:"datum"}),order:null!==
(facetFieldDef=sort.order)&&void 0!==facetFieldDef?facetFieldDef:"ascending"}:vega.isArray(sort)?{field:sortArrayIndexField(facetFieldDef$jscomp$0,JSCompiler_inline_result,{expr:"datum"}),order:"ascending"}:{field:vgField(facetFieldDef$jscomp$0,{expr:"datum"}),order:null!==sort&&void 0!==sort?sort:"ascending"}}facetFieldDef={from:layoutHeader,sort:JSCompiler_inline_result$jscomp$0}}else facetFieldDef={};JSCompiler_inline_result=titleAngle.call(headerChannel,{},headerType$jscomp$0,facetFieldDef,hasAxes&&
isFacetWithoutRowCol?{from:{data:this.getName("facet_domain_".concat(JSCompiler_inline_result))}}:{},config?{title:config}:{},title.sizeSignal?{encode:{update:{[sizeChannel]:title.sizeSignal}}}:{},hasAxes?{axes}:{});break a}}JSCompiler_inline_result=null}null!=JSCompiler_inline_result&&channel$jscomp$0.push(JSCompiler_inline_result)}headerMarks=headerMarks.call(layoutHeaders,channel$jscomp$0)}return headerMarks}assembleAxes(){return assembleAxes(this.component.axes,this.config)}assembleLegends(){return assembleLegends(this)}assembleProjections(){var JSCompiler_inline_result=
isLayerModel(this)||isConcatModel(this)?assembleProjectionsForModelAndChildren(this):assembleProjectionForModel(this);return JSCompiler_inline_result}assembleTitle(){var _this$title,$jscomp$destructuring$var131=null!==(_this$title=this.title)&&void 0!==_this$title?_this$title:{};_this$title=Object.assign({},$jscomp$destructuring$var131);$jscomp$destructuring$var131=$jscomp$destructuring$var131.encoding;_this$title=(delete _this$title.encoding,_this$title);$jscomp$destructuring$var131=Object.assign({},
extractTitleConfig(this.config.title).nonMarkTitleProperties,_this$title,$jscomp$destructuring$var131?{encode:{update:$jscomp$destructuring$var131}}:{});if($jscomp$destructuring$var131.text){if(contains(["unit","layer"],this.type)){if(contains(["middle",void 0],$jscomp$destructuring$var131.anchor)){var _title$frame;null!==(_title$frame=$jscomp$destructuring$var131.frame)&&void 0!==_title$frame?_title$frame:$jscomp$destructuring$var131.frame="group"}}else{var _title$anchor;null!==(_title$anchor=$jscomp$destructuring$var131.anchor)&&
void 0!==_title$anchor?_title$anchor:$jscomp$destructuring$var131.anchor="start"}return isEmpty($jscomp$destructuring$var131)?void 0:$jscomp$destructuring$var131}}assembleGroup(){var signals=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[];const group={};signals=signals.concat(this.assembleSignals());0<signals.length&&(group.signals=signals);if(signals=this.assembleLayout())group.layout=signals;group.marks=[].concat(this.assembleHeaderMarks(),this.assembleMarks());signals=!this.parent||isFacetModel(this.parent)?
assembleScales(this):[];0<signals.length&&(group.scales=signals);signals=this.assembleAxes();0<signals.length&&(group.axes=signals);signals=this.assembleLegends();0<signals.length&&(group.legends=signals);return group}getName(text){return varName((this.name?"".concat(this.name,"_"):"")+text)}getDataName(type){return this.getName(DataSourceType[type].toLowerCase())}requestDataName(name){name=this.getDataName(name);const refCounts=this.component.data.outputNodeRefCounts;refCounts[name]=(refCounts[name]||
0)+1;return name}getSizeSignalRef(layoutSizeType){if(isFacetModel(this.parent)){var sizeType=getSizeTypeFromLayoutSizeType(layoutSizeType),channel=getPositionScaleChannel(sizeType);if((sizeType=this.component.scales[channel])&&!sizeType.merged){var type=sizeType.get("type");const range=sizeType.get("range");if(hasDiscreteDomain(type)&&isVgRangeStep(range)){layoutSizeType=sizeType.get("name");type=assembleDomain(this,channel);if(type=getFieldFromDomain(type))return channel=vgField({aggregate:"distinct",
field:type},{expr:"datum"}),{signal:sizeExpr(layoutSizeType,sizeType,channel)};warn(unknownField(channel));return null}}}return{signal:this.signalNameMap.get(this.getName(layoutSizeType))}}lookupDataSource(name){const node=this.component.data.outputNodes[name];return node?node.getSource():name}getSignalName(oldSignalName){return this.signalNameMap.get(oldSignalName)}renameSignal(oldName,newName){this.signalNameMap.rename(oldName,newName)}renameScale(oldName,newName){this.scaleNameMap.rename(oldName,
newName)}renameProjection(oldName,newName){this.projectionNameMap.rename(oldName,newName)}scaleName(originalScaleName,parse){if(parse)return this.getName(originalScaleName);if(CHANNEL_INDEX[originalScaleName]&&SCALE_CHANNEL_INDEX[originalScaleName]&&this.component.scales[originalScaleName]||this.scaleNameMap.has(this.getName(originalScaleName)))return this.scaleNameMap.get(this.getName(originalScaleName))}projectionName(parse){if(parse)return this.getName("projection");if(this.component.projection&&
!this.component.projection.merged||this.projectionNameMap.has(this.getName("projection")))return this.projectionNameMap.get(this.getName("projection"))}getScaleComponent(channel){if(!this.component.scales)throw Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");const localScaleComponent=this.component.scales[channel];return localScaleComponent&&!localScaleComponent.merged?localScaleComponent:this.parent?this.parent.getScaleComponent(channel):
void 0}getSelectionComponent(variableName,origName){let sel=this.component.selection[variableName];!sel&&this.parent&&(sel=this.parent.getSelectionComponent(variableName,origName));if(!sel)throw Error('Cannot find a selection named "'.concat(origName,'".'));return sel}hasAxisOrientSignalRef(){var _this$component$axes$,_this$component$axes$2;return(null===(_this$component$axes$=this.component.axes.x)||void 0===_this$component$axes$?void 0:_this$component$axes$.some(a=>a.hasOrientSignalRef()))||(null===
(_this$component$axes$2=this.component.axes.y)||void 0===_this$component$axes$2?void 0:_this$component$axes$2.some(a=>a.hasOrientSignalRef()))}}class ModelWithField extends Model{vgField(channel){let opt=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};const fieldDef=this.fieldDef(channel);if(fieldDef)return vgField(fieldDef,opt)}reduceFieldDef(f,init){return reduce(this.getMapping(),(acc,cd,c)=>(cd=getFieldDef(cd))?f(acc,cd,c):acc,init)}forEachFieldDef(f,t){forEach(this.getMapping(),(cd,
c)=>{(cd=getFieldDef(cd))&&f(cd,c)},t)}}class DensityTransformNode extends DataFlowNode{clone(){return new DensityTransformNode(null,duplicate(this.transform))}constructor(parent,transform){var _this$transform$as,_specifiedAs$,_specifiedAs$2;super(parent);this.transform=transform;this.transform=duplicate(transform);parent=null!==(_this$transform$as=this.transform.as)&&void 0!==_this$transform$as?_this$transform$as:[void 0,void 0];this.transform.as=[null!==(_specifiedAs$=parent[0])&&void 0!==_specifiedAs$?
_specifiedAs$:"value",null!==(_specifiedAs$2=parent[1])&&void 0!==_specifiedAs$2?_specifiedAs$2:"density"]}dependentFields(){var _this$transform$group;return new Set([this.transform.density,...(null!==(_this$transform$group=this.transform.groupby)&&void 0!==_this$transform$group?_this$transform$group:[])])}producedFields(){return new Set(this.transform.as)}hash(){return"DensityTransform ".concat(hash(this.transform))}assemble(){var $jscomp$destructuring$var133=this.transform,$jscomp$destructuring$var134=
Object.assign({},$jscomp$destructuring$var133);$jscomp$destructuring$var133=$jscomp$destructuring$var133.density;$jscomp$destructuring$var134=(delete $jscomp$destructuring$var134.density,$jscomp$destructuring$var134);return Object.assign({},{type:"kde",field:$jscomp$destructuring$var133},$jscomp$destructuring$var134)}}class FilterInvalidNode extends DataFlowNode{clone(){return new FilterInvalidNode(null,Object.assign({},this.filter))}constructor(parent,filter){super(parent);this.filter=filter}static make(parent,
model){const {config,mark,markDef}=model;if("filter"!==getMarkPropOrConfig("invalid",markDef,config))return null;const filter=model.reduceFieldDef((aggregator,fieldDef,channel)=>{if(channel=!!SCALE_CHANNEL_INDEX[channel]&&model.getScaleComponent(channel))channel=channel.get("type"),hasContinuousDomain(channel)&&"count"!==fieldDef.aggregate&&!isPathMark(mark)&&(aggregator[fieldDef.field]=fieldDef);return aggregator},{});return keys$jscomp$0(filter).length?new FilterInvalidNode(parent,filter):null}dependentFields(){return new Set(keys$jscomp$0(this.filter))}producedFields(){return new Set}hash(){return"FilterInvalid ".concat(hash(this.filter))}assemble(){const filters=
keys$jscomp$0(this.filter).reduce((vegaFilters,field)=>{field=this.filter[field];const ref=vgField(field,{expr:"datum"});null!==field&&("temporal"===field.type?vegaFilters.push("(isDate(".concat(ref,") || (isValid(").concat(ref,") \x26\x26 isFinite(+").concat(ref,")))")):"quantitative"===field.type&&(vegaFilters.push("isValid(".concat(ref,")")),vegaFilters.push("isFinite(+".concat(ref,")"))));return vegaFilters},[]);return 0<filters.length?{type:"filter",expr:filters.join(" \x26\x26 ")}:null}}class FlattenTransformNode extends DataFlowNode{clone(){return new FlattenTransformNode(this.parent,
duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform;this.transform=duplicate(transform);const {flatten,as=[]}=this.transform;this.transform.as=flatten.map((f,i)=>{var _as$i;return null!==(_as$i=as[i])&&void 0!==_as$i?_as$i:f})}dependentFields(){return new Set(this.transform.flatten)}producedFields(){return new Set(this.transform.as)}hash(){return"FlattenTransform ".concat(hash(this.transform))}assemble(){const {flatten:fields,as}=this.transform;return{type:"flatten",
fields,as}}}class FoldTransformNode extends DataFlowNode{clone(){return new FoldTransformNode(null,duplicate(this.transform))}constructor(parent,transform){var _this$transform$as,_specifiedAs$,_specifiedAs$2;super(parent);this.transform=transform;this.transform=duplicate(transform);parent=null!==(_this$transform$as=this.transform.as)&&void 0!==_this$transform$as?_this$transform$as:[void 0,void 0];this.transform.as=[null!==(_specifiedAs$=parent[0])&&void 0!==_specifiedAs$?_specifiedAs$:"key",null!==
(_specifiedAs$2=parent[1])&&void 0!==_specifiedAs$2?_specifiedAs$2:"value"]}dependentFields(){return new Set(this.transform.fold)}producedFields(){return new Set(this.transform.as)}hash(){return"FoldTransform ".concat(hash(this.transform))}assemble(){const {fold,as}=this.transform;return{type:"fold",fields:fold,as}}}class GeoJSONNode extends DataFlowNode{clone(){return new GeoJSONNode(null,duplicate(this.fields),this.geojson,this.signal)}static parseAll(parent,model){if(model.component.projection&&
!model.component.projection.isFit)return parent;let geoJsonCounter=0;for(var coordinates of[["longitude","latitude"],["longitude2","latitude2"]]){const pair=coordinates.map(channel=>{channel=getFieldOrDatumDef(model.encoding[channel]);return isFieldDef(channel)?channel.field:isDatumDef(channel)?{expr:"".concat(channel.datum)}:isValueDef(channel)?{expr:"".concat(channel.value)}:void 0});if(pair[0]||pair[1])parent=new GeoJSONNode(parent,pair,null,model.getName("geojson_".concat(geoJsonCounter++)))}model.channelHasField("shape")&&
(coordinates=model.typedFieldDef("shape"),"geojson"===coordinates.type&&(parent=new GeoJSONNode(parent,null,coordinates.field,model.getName("geojson_".concat(geoJsonCounter++)))));return parent}constructor(parent,fields,geojson,signal){super(parent);this.fields=fields;this.geojson=geojson;this.signal=signal}dependentFields(){var _this$fields;const fields=(null!==(_this$fields=this.fields)&&void 0!==_this$fields?_this$fields:[]).filter(vega.isString);return new Set([...(this.geojson?[this.geojson]:
[]),...fields])}producedFields(){return new Set}hash(){return"GeoJSON ".concat(this.geojson," ").concat(this.signal," ").concat(hash(this.fields))}assemble(){return[...(this.geojson?[{type:"filter",expr:'isValid(datum["'.concat(this.geojson,'"])')}]:[]),Object.assign({},{type:"geojson"},this.fields?{fields:this.fields}:{},this.geojson?{geojson:this.geojson}:{},{signal:this.signal})]}}class GeoPointNode extends DataFlowNode{clone(){return new GeoPointNode(null,this.projection,duplicate(this.fields),
duplicate(this.as))}constructor(parent,projection,fields,as){super(parent);this.projection=projection;this.fields=fields;this.as=as}static parseAll(parent,model){if(!model.projectionName())return parent;for(const coordinates of[["longitude","latitude"],["longitude2","latitude2"]]){const pair=coordinates.map(channel=>{channel=getFieldOrDatumDef(model.encoding[channel]);return isFieldDef(channel)?channel.field:isDatumDef(channel)?{expr:"".concat(channel.datum)}:isValueDef(channel)?{expr:"".concat(channel.value)}:
void 0}),suffix="longitude2"===coordinates[0]?"2":"";if(pair[0]||pair[1])parent=new GeoPointNode(parent,model.projectionName(),pair,[model.getName("x".concat(suffix)),model.getName("y".concat(suffix))])}return parent}dependentFields(){return new Set(this.fields.filter(vega.isString))}producedFields(){return new Set(this.as)}hash(){return"Geopoint ".concat(this.projection," ").concat(hash(this.fields)," ").concat(hash(this.as))}assemble(){return{type:"geopoint",projection:this.projection,fields:this.fields,
as:this.as}}}class ImputeNode extends DataFlowNode{clone(){return new ImputeNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform}dependentFields(){var _this$transform$group;return new Set([this.transform.impute,this.transform.key,...(null!==(_this$transform$group=this.transform.groupby)&&void 0!==_this$transform$group?_this$transform$group:[])])}producedFields(){return new Set([this.transform.impute])}processSequence(keyvals){const {start=0,stop,
step}=keyvals;keyvals=[start,stop,...(step?[step]:[])].join();return{signal:"sequence(".concat(keyvals,")")}}static makeFromTransform(parent,imputeTransform){return new ImputeNode(parent,imputeTransform)}static makeFromEncoding(parent,model){const encoding=model.encoding;var xDef=encoding.x;const yDef=encoding.y;if(isFieldDef(xDef)&&isFieldDef(yDef)){const imputedChannel=xDef.impute?xDef:yDef.impute?yDef:void 0;if(void 0===imputedChannel)return;xDef=xDef.impute?yDef:yDef.impute?xDef:void 0;const {method,
value,frame,keyvals}=imputedChannel.impute;model=pathGroupingFields(model.mark,encoding);return new ImputeNode(parent,Object.assign({},{impute:imputedChannel.field,key:xDef.field},method?{method}:{},void 0!==value?{value}:{},frame?{frame}:{},void 0!==keyvals?{keyvals}:{},model.length?{groupby:model}:{}))}return null}hash(){return"Impute ".concat(hash(this.transform))}assemble(){const {impute,key,keyvals,method,groupby,value,frame=[null,null]}=this.transform,imputeTransform=Object.assign({},{type:"impute",
field:impute,key},keyvals?{keyvals:void 0!==(null===keyvals||void 0===keyvals?void 0:keyvals.stop)?this.processSequence(keyvals):keyvals}:{},{method:"value"},groupby?{groupby}:{},{value:method&&"value"!==method?null:value});if(method&&"value"!==method){const deriveNewField=Object.assign({},{type:"window",as:["imputed_".concat(impute,"_value")],ops:[method],fields:[impute],frame,ignorePeers:!1},groupby?{groupby}:{}),replaceOriginal={type:"formula",expr:"datum.".concat(impute," \x3d\x3d\x3d null ? datum.imputed_").concat(impute,
"_value : datum.").concat(impute),as:impute};return[imputeTransform,deriveNewField,replaceOriginal]}return[imputeTransform]}}class LoessTransformNode extends DataFlowNode{clone(){return new LoessTransformNode(null,duplicate(this.transform))}constructor(parent,transform){var _this$transform$as,_specifiedAs$,_specifiedAs$2;super(parent);this.transform=transform;this.transform=duplicate(transform);parent=null!==(_this$transform$as=this.transform.as)&&void 0!==_this$transform$as?_this$transform$as:[void 0,
void 0];this.transform.as=[null!==(_specifiedAs$=parent[0])&&void 0!==_specifiedAs$?_specifiedAs$:transform.on,null!==(_specifiedAs$2=parent[1])&&void 0!==_specifiedAs$2?_specifiedAs$2:transform.loess]}dependentFields(){var _this$transform$group;return new Set([this.transform.loess,this.transform.on,...(null!==(_this$transform$group=this.transform.groupby)&&void 0!==_this$transform$group?_this$transform$group:[])])}producedFields(){return new Set(this.transform.as)}hash(){return"LoessTransform ".concat(hash(this.transform))}assemble(){var $jscomp$destructuring$var135=
this.transform,$jscomp$destructuring$var136=Object.assign({},$jscomp$destructuring$var135);const loess=$jscomp$destructuring$var135.loess;$jscomp$destructuring$var135=$jscomp$destructuring$var135.on;$jscomp$destructuring$var136=(delete $jscomp$destructuring$var136.loess,delete $jscomp$destructuring$var136.on,$jscomp$destructuring$var136);return Object.assign({},{type:"loess",x:$jscomp$destructuring$var135,y:loess},$jscomp$destructuring$var136)}}class LookupNode extends DataFlowNode{clone(){return new LookupNode(null,
duplicate(this.transform),this.secondary)}constructor(parent,transform,secondary){super(parent);this.transform=transform;this.secondary=secondary}static make(parent,model,transform,counter){const sources=model.component.data.sources,{from}=transform;var fromOutputNode=null;if("data"in from)fromOutputNode=findSource(from.data,sources),fromOutputNode||(fromOutputNode=new SourceNode(from.data),sources.push(fromOutputNode)),counter=model.getName("lookup_".concat(counter)),fromOutputNode=new OutputNode(fromOutputNode,
counter,DataSourceType.Lookup,model.component.data.outputNodeRefCounts),model.component.data.outputNodes[counter]=fromOutputNode;else if("param"in from){counter=from.param;transform=Object.assign({},{as:counter},transform);let selCmpt;try{selCmpt=model.getSelectionComponent(varName(counter),counter)}catch(e){throw Error('Lookups can only be performed on selection parameters. "'.concat(counter,'" is a variable parameter.'));}fromOutputNode=selCmpt.materialized;if(!fromOutputNode)throw Error('Cannot define and lookup the "'.concat(counter,
'" selection in the same view. ')+"Try moving the lookup into a second, layered view?");}return new LookupNode(parent,transform,fromOutputNode.getSource())}dependentFields(){return new Set([this.transform.lookup])}producedFields(){return new Set(this.transform.as?vega.array(this.transform.as):this.transform.from.fields)}hash(){return"Lookup ".concat(hash({transform:this.transform,secondary:this.secondary}))}assemble(){if(this.transform.from.fields)var foreign=Object.assign({},{values:this.transform.from.fields},
this.transform.as?{as:vega.array(this.transform.as)}:{});else foreign=this.transform.as,vega.isString(foreign)||(warn('If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.'),foreign="_lookup"),foreign={as:[foreign]};return Object.assign({},{type:"lookup",from:this.secondary,key:this.transform.from.key,fields:[this.transform.lookup]},foreign,this.transform.default?{default:this.transform.default}:{})}}class QuantileTransformNode extends DataFlowNode{clone(){return new QuantileTransformNode(null,
duplicate(this.transform))}constructor(parent,transform){var _this$transform$as,_specifiedAs$,_specifiedAs$2;super(parent);this.transform=transform;this.transform=duplicate(transform);parent=null!==(_this$transform$as=this.transform.as)&&void 0!==_this$transform$as?_this$transform$as:[void 0,void 0];this.transform.as=[null!==(_specifiedAs$=parent[0])&&void 0!==_specifiedAs$?_specifiedAs$:"prob",null!==(_specifiedAs$2=parent[1])&&void 0!==_specifiedAs$2?_specifiedAs$2:"value"]}dependentFields(){var _this$transform$group;
return new Set([this.transform.quantile,...(null!==(_this$transform$group=this.transform.groupby)&&void 0!==_this$transform$group?_this$transform$group:[])])}producedFields(){return new Set(this.transform.as)}hash(){return"QuantileTransform ".concat(hash(this.transform))}assemble(){var $jscomp$destructuring$var137=this.transform,$jscomp$destructuring$var138=Object.assign({},$jscomp$destructuring$var137);$jscomp$destructuring$var137=$jscomp$destructuring$var137.quantile;$jscomp$destructuring$var138=
(delete $jscomp$destructuring$var138.quantile,$jscomp$destructuring$var138);return Object.assign({},{type:"quantile",field:$jscomp$destructuring$var137},$jscomp$destructuring$var138)}}class RegressionTransformNode extends DataFlowNode{clone(){return new RegressionTransformNode(null,duplicate(this.transform))}constructor(parent,transform){var _this$transform$as,_specifiedAs$,_specifiedAs$2;super(parent);this.transform=transform;this.transform=duplicate(transform);parent=null!==(_this$transform$as=
this.transform.as)&&void 0!==_this$transform$as?_this$transform$as:[void 0,void 0];this.transform.as=[null!==(_specifiedAs$=parent[0])&&void 0!==_specifiedAs$?_specifiedAs$:transform.on,null!==(_specifiedAs$2=parent[1])&&void 0!==_specifiedAs$2?_specifiedAs$2:transform.regression]}dependentFields(){var _this$transform$group;return new Set([this.transform.regression,this.transform.on,...(null!==(_this$transform$group=this.transform.groupby)&&void 0!==_this$transform$group?_this$transform$group:[])])}producedFields(){return new Set(this.transform.as)}hash(){return"RegressionTransform ".concat(hash(this.transform))}assemble(){var $jscomp$destructuring$var139=
this.transform,$jscomp$destructuring$var140=Object.assign({},$jscomp$destructuring$var139);const regression=$jscomp$destructuring$var139.regression;$jscomp$destructuring$var139=$jscomp$destructuring$var139.on;$jscomp$destructuring$var140=(delete $jscomp$destructuring$var140.regression,delete $jscomp$destructuring$var140.on,$jscomp$destructuring$var140);return Object.assign({},{type:"regression",x:$jscomp$destructuring$var139,y:regression},$jscomp$destructuring$var140)}}class PivotTransformNode extends DataFlowNode{clone(){return new PivotTransformNode(null,
duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform}addDimensions(fields){var _this$transform$group;this.transform.groupby=unique((null!==(_this$transform$group=this.transform.groupby)&&void 0!==_this$transform$group?_this$transform$group:[]).concat(fields),d=>d)}producedFields(){}dependentFields(){var _this$transform$group2;return new Set([this.transform.pivot,this.transform.value,...(null!==(_this$transform$group2=this.transform.groupby)&&void 0!==_this$transform$group2?
_this$transform$group2:[])])}hash(){return"PivotTransform ".concat(hash(this.transform))}assemble(){const {pivot,value,groupby,limit,op}=this.transform;return Object.assign({},{type:"pivot",field:pivot,value},void 0!==limit?{limit}:{},void 0!==op?{op}:{},void 0!==groupby?{groupby}:{})}}class SampleTransformNode extends DataFlowNode{clone(){return new SampleTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform}dependentFields(){return new Set}producedFields(){return new Set}hash(){return"SampleTransform ".concat(hash(this.transform))}assemble(){return{type:"sample",
size:this.transform.sample}}}class FacetModel extends ModelWithField{constructor(spec,parent,parentGivenName,config){super(spec,"facet",parent,parentGivenName,config,spec.resolve);_defineProperty(this,"facet",void 0);_defineProperty(this,"child",void 0);_defineProperty(this,"children",void 0);this.child=buildModel(spec.spec,this,this.getName("child"),void 0,config);this.children=[this.child];this.facet=this.initFacet(spec.facet)}initFacet(facet){if(!isFacetMapping(facet))return{facet:this.initFacetFieldDef(facet,
"facet")};var channels=keys$jscomp$0(facet);const normalizedFacet={};for(const channel of channels){if(!["row","column"].includes(channel)){warn(incompatibleChannel(channel,"facet"));break}channels=facet[channel];if(void 0===channels.field){warn(emptyFieldDef(channels,channel));break}normalizedFacet[channel]=this.initFacetFieldDef(channels,channel)}return normalizedFacet}initFacetFieldDef(fieldDef,channel){fieldDef=initFieldDef(fieldDef,channel);fieldDef.header?fieldDef.header=replaceExprRef(fieldDef.header):
null===fieldDef.header&&(fieldDef.header=null);return fieldDef}channelHasField(channel){return!!this.facet[channel]}fieldDef(channel){return this.facet[channel]}parseData(){this.component.data=parseData(this);this.child.parseData()}parseLayoutSize(){parseChildrenLayoutSize(this)}parseSelections(){this.child.parseSelections();this.component.selection=this.child.component.selection}parseMarkGroup(){this.child.parseMarkGroup()}parseAxesAndHeaders(){this.child.parseAxesAndHeaders();for(const channel of FACET_CHANNELS){var _fieldDef$header=
void 0,channel$jscomp$0=channel;const {facet,config,child,component}=this;if(this.channelHasField(channel$jscomp$0)){const fieldDef=facet[channel$jscomp$0];var titleConfig=getHeaderProperty("title",null,config,channel$jscomp$0);titleConfig=title$jscomp$0(fieldDef,config,{allowDisabling:!0,includeDefault:void 0===titleConfig||!!titleConfig});child.component.layoutHeaders[channel$jscomp$0].title&&(titleConfig=vega.isArray(titleConfig)?titleConfig.join(", "):titleConfig,titleConfig+=" / ".concat(child.component.layoutHeaders[channel$jscomp$0].title),
child.component.layoutHeaders[channel$jscomp$0].title=null);const labelOrient=getHeaderProperty("labelOrient",fieldDef.header,config,channel$jscomp$0),labels=null!==fieldDef.header?getFirstDefined(null===(_fieldDef$header=fieldDef.header)||void 0===_fieldDef$header?void 0:_fieldDef$header.labels,config.header.labels,!0):!1;_fieldDef$header=contains(["bottom","right"],labelOrient)?"footer":"header";component.layoutHeaders[channel$jscomp$0]={title:null!==fieldDef.header?titleConfig:null,facetFieldDef:fieldDef,
[_fieldDef$header]:"facet"===channel$jscomp$0?[]:[makeHeaderComponent(this,channel$jscomp$0,labels)]}}}mergeChildAxis(this,"x");mergeChildAxis(this,"y")}assembleSelectionTopLevelSignals(signals){return this.child.assembleSelectionTopLevelSignals(signals)}assembleSignals(){this.child.assembleSignals();return[]}assembleSelectionData(data){return this.child.assembleSelectionData(data)}getHeaderLayoutMixins(){const layoutMixins={};for(const channel of FACET_CHANNELS)for(const headerType of HEADER_TYPES){const layoutHeaderComponent=
this.component.layoutHeaders[channel];var headerComponent=layoutHeaderComponent[headerType],{facetFieldDef}=layoutHeaderComponent;if(facetFieldDef&&(facetFieldDef=getHeaderProperty("titleOrient",facetFieldDef.header,this.config,channel),["right","bottom"].includes(facetFieldDef))){var _layoutMixins$titleAn;facetFieldDef=getHeaderChannel(channel,facetFieldDef);null!==(_layoutMixins$titleAn=layoutMixins.titleAnchor)&&void 0!==_layoutMixins$titleAn?_layoutMixins$titleAn:layoutMixins.titleAnchor={};layoutMixins.titleAnchor[facetFieldDef]=
"end"}if(null!==headerComponent&&void 0!==headerComponent&&headerComponent[0]){headerComponent="row"===channel?"height":"width";facetFieldDef="header"===headerType?"headerBand":"footerBand";if("facet"!==channel&&!this.child.component.layoutSize.get(headerComponent)){var _layoutMixins$bandTyp;null!==(_layoutMixins$bandTyp=layoutMixins[facetFieldDef])&&void 0!==_layoutMixins$bandTyp?_layoutMixins$bandTyp:layoutMixins[facetFieldDef]={};layoutMixins[facetFieldDef][channel]=.5}if(layoutHeaderComponent.title){var _layoutMixins$offset;
null!==(_layoutMixins$offset=layoutMixins.offset)&&void 0!==_layoutMixins$offset?_layoutMixins$offset:layoutMixins.offset={};layoutMixins.offset["row"===channel?"rowTitle":"columnTitle"]=10}}}return layoutMixins}assembleDefaultLayout(){const {column,row}=this.facet,columns=column?this.columnDistinctSignal():row?1:void 0;let align="all";row||"independent"!==this.component.resolve.scale.x?column||"independent"!==this.component.resolve.scale.y||(align="none"):align="none";return Object.assign({},this.getHeaderLayoutMixins(),
columns?{columns}:{},{bounds:"full",align})}assembleLayoutSignals(){return this.child.assembleLayoutSignals()}columnDistinctSignal(){if(!(this.parent&&this.parent instanceof FacetModel)){const facetLayoutDataName=this.getName("column_domain");return{signal:"length(data('".concat(facetLayoutDataName,"'))")}}}assembleGroupStyle(){}assembleGroup(signals){return this.parent&&this.parent instanceof FacetModel?Object.assign({},this.channelHasField("column")?{encode:{update:{columns:{field:vgField(this.facet.column,
{prefix:"distinct"})}}}}:{},super.assembleGroup(signals)):super.assembleGroup(signals)}getCardinalityAggregateForChild(){const fields=[],ops=[],as=[];if(this.child instanceof FacetModel){if(this.child.channelHasField("column")){var field=vgField(this.child.facet.column);fields.push(field);ops.push("distinct");as.push("distinct_".concat(field))}}else for(field of POSITION_SCALE_CHANNELS){var childScaleComponent=this.child.component.scales[field];if(childScaleComponent&&!childScaleComponent.merged){var type=
childScaleComponent.get("type");childScaleComponent=childScaleComponent.get("range");hasDiscreteDomain(type)&&isVgRangeStep(childScaleComponent)&&(type=assembleDomain(this.child,field),(type=getFieldFromDomain(type))?(fields.push(type),ops.push("distinct"),as.push("distinct_".concat(type))):warn(unknownField(field)))}}return{fields,ops,as}}assembleFacet(){const {name,data}=this.component.data.facetRoot,{row,column}=this.facet,{fields,ops,as}=this.getCardinalityAggregateForChild(),groupby=[];for(var channel of FACET_CHANNELS){var fieldDef=
this.facet[channel];if(fieldDef){groupby.push(vgField(fieldDef));const {bin,sort}=fieldDef;isBinning(bin)&&groupby.push(vgField(fieldDef,{binSuffix:"end"}));if(isSortField(sort)){const {field,op="min"}=sort;fieldDef=facetSortFieldName(fieldDef,sort);row&&column?(fields.push(fieldDef),ops.push("max")):(fields.push(field),ops.push(op));as.push(fieldDef)}else vega.isArray(sort)&&(fieldDef=sortArrayIndexField(fieldDef,channel),fields.push(fieldDef),ops.push("max"),as.push(fieldDef))}}channel=!!row&&!!column;
return Object.assign({},{name,data,groupby},channel||0<fields.length?{aggregate:Object.assign({},channel?{cross:channel}:{},fields.length?{fields,ops,as}:{})}:{})}facetSortFields(channel){var {facet}=this;return(facet=facet[channel])?isSortField(facet.sort)?[facetSortFieldName(facet,facet.sort,{expr:"datum"})]:vega.isArray(facet.sort)?[sortArrayIndexField(facet,channel,{expr:"datum"})]:[vgField(facet,{expr:"datum"})]:[]}facetSortOrder(channel){const {facet}=this;return(channel=facet[channel])?({sort:channel}=
channel,[(isSortField(channel)?channel.order:!vega.isArray(channel)&&channel)||"ascending"]):[]}assembleLabelTitle(){const {facet,config}=this;if(facet.facet)return assembleLabelTitle(facet.facet,"facet",config);const ORTHOGONAL_ORIENT={row:["top","bottom"],column:["left","right"]};for(const channel of HEADER_CHANNELS)if(facet[channel]){var _facet$channel;const labelOrient=getHeaderProperty("labelOrient",null===(_facet$channel=facet[channel])||void 0===_facet$channel?void 0:_facet$channel.header,
config,channel);if(ORTHOGONAL_ORIENT[channel].includes(labelOrient))return assembleLabelTitle(facet[channel],channel,config)}}assembleMarks(){const {child}=this,data=assembleFacetData(this.component.data.facetRoot),encodeEntry=child.assembleGroupEncodeEntry(!1),title=this.assembleLabelTitle()||child.assembleTitle(),style=child.assembleGroupStyle();return[Object.assign({},{name:this.getName("cell"),type:"group"},title?{title}:{},style?{style}:{},{from:{facet:this.assembleFacet()},sort:{field:FACET_CHANNELS.map(c=>
this.facetSortFields(c)).flat(),order:FACET_CHANNELS.map(c=>this.facetSortOrder(c)).flat()}},0<data.length?{data}:{},encodeEntry?{encode:{update:encodeEntry}}:{},child.assembleGroup(assembleFacetSignals(this,[])))]}getMapping(){return this.facet}}class ConcatModel extends Model{constructor(spec,parent,parentGivenName,config){var _spec$resolve,_spec$resolve$axis,_spec$resolve2,_spec$resolve2$axis;super(spec,"concat",parent,parentGivenName,config,spec.resolve);_defineProperty(this,"children",void 0);
"shared"!==(null===(_spec$resolve=spec.resolve)||void 0===_spec$resolve?void 0:null===(_spec$resolve$axis=_spec$resolve.axis)||void 0===_spec$resolve$axis?void 0:_spec$resolve$axis.x)&&"shared"!==(null===(_spec$resolve2=spec.resolve)||void 0===_spec$resolve2?void 0:null===(_spec$resolve2$axis=_spec$resolve2.axis)||void 0===_spec$resolve2$axis?void 0:_spec$resolve2$axis.y)||warn("Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).");this.children=
this.getChildren(spec).map((child,i)=>buildModel(child,this,this.getName("concat_".concat(i)),void 0,config))}parseData(){this.component.data=parseData(this);for(const child of this.children)child.parseData()}parseSelections(){this.component.selection={};for(const child of this.children){child.parseSelections();for(const key of keys$jscomp$0(child.component.selection))this.component.selection[key]=child.component.selection[key]}}parseMarkGroup(){for(const child of this.children)child.parseMarkGroup()}parseAxesAndHeaders(){for(const child of this.children)child.parseAxesAndHeaders()}getChildren(spec){return"vconcat"in
spec?spec.vconcat:"hconcat"in spec?spec.hconcat:spec.concat}parseLayoutSize(){parseChildrenLayoutSize(this);const heightType=void 0===this.layout.columns?"height":"childHeight";parseNonUnitLayoutSizeForChannel(this,1===this.layout.columns?"width":"childWidth");parseNonUnitLayoutSizeForChannel(this,heightType)}parseAxisGroup(){return null}assembleSelectionTopLevelSignals(signals){return this.children.reduce((sg,child)=>child.assembleSelectionTopLevelSignals(sg),signals)}assembleSignals(){this.children.forEach(child=>
child.assembleSignals());return[]}assembleLayoutSignals(){const layoutSignals=assembleLayoutSignals(this);for(const child of this.children)layoutSignals.push(...child.assembleLayoutSignals());return layoutSignals}assembleSelectionData(data){return this.children.reduce((db,child)=>child.assembleSelectionData(db),data)}assembleMarks(){return this.children.map(child=>{const title=child.assembleTitle(),style=child.assembleGroupStyle(),encodeEntry=child.assembleGroupEncodeEntry(!1);return Object.assign({},
{type:"group",name:child.getName("group")},title?{title}:{},style?{style}:{},encodeEntry?{encode:{update:encodeEntry}}:{},child.assembleGroup())})}assembleGroupStyle(){}assembleDefaultLayout(){const columns=this.layout.columns;return Object.assign({},null!=columns?{columns}:{},{bounds:"full",align:"each"})}}const AXIS_COMPONENT_PROPERTIES_INDEX=Object.assign({},{disable:1,gridScale:1,scale:1},COMMON_AXIS_PROPERTIES_INDEX,{labelExpr:1,encode:1}),AXIS_COMPONENT_PROPERTIES=keys$jscomp$0(AXIS_COMPONENT_PROPERTIES_INDEX);
class AxisComponent extends Split{constructor(){let explicit=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},implicit=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},mainExtracted=2<arguments.length&&void 0!==arguments[2]?arguments[2]:!1;super();this.explicit=explicit;this.implicit=implicit;this.mainExtracted=mainExtracted}clone(){return new AxisComponent(duplicate(this.explicit),duplicate(this.implicit),this.mainExtracted)}hasAxisPart(part){if("axis"===part)return!0;if("grid"===
part||"title"===part)return!!this.get(part);part=this.get(part);return!(!1===part||null===part)}hasOrientSignalRef(){return isSignalRef(this.explicit.orient)}}const OPPOSITE_ORIENT={bottom:"top",top:"bottom",left:"right",right:"left"},propsToAlwaysIncludeConfig=new Set("grid translate format formatType orient labelExpr tickCount position tickMinStep".split(" ")),markCompiler={arc:{vgMark:"arc",encodeEntry:model=>Object.assign({},baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",
size:"ignore",orient:"ignore",theta:"ignore"}),pointPosition("x",model,{defaultPos:"mid"}),pointPosition("y",model,{defaultPos:"mid"}),rectPosition(model,"radius"),rectPosition(model,"theta"))},area:{vgMark:"area",encodeEntry:model=>Object.assign({},baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",orient:"include",size:"ignore",theta:"ignore"}),pointOrRangePosition("x",model,{defaultPos:"zeroOrMin",defaultPos2:"zeroOrMin",range:"horizontal"===model.markDef.orient}),pointOrRangePosition("y",
model,{defaultPos:"zeroOrMin",defaultPos2:"zeroOrMin",range:"vertical"===model.markDef.orient}),defined(model))},bar:{vgMark:"rect",encodeEntry:model=>Object.assign({},baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",orient:"ignore",size:"ignore",theta:"ignore"}),rectPosition(model,"x"),rectPosition(model,"y"))},circle:{vgMark:"symbol",encodeEntry:model=>encodeEntry(model,"circle")},geoshape:{vgMark:"shape",encodeEntry:model=>Object.assign({},baseEncodeEntry(model,{align:"ignore",
baseline:"ignore",color:"include",size:"ignore",orient:"ignore",theta:"ignore"})),postEncodingTransform:model=>{var {encoding}=model;encoding=encoding.shape;return[Object.assign({},{type:"geoshape",projection:model.projectionName()},encoding&&isFieldDef(encoding)&&"geojson"===encoding.type?{field:vgField(encoding,{expr:"datum"})}:{})]}},image:{vgMark:"image",encodeEntry:model=>Object.assign({},baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"ignore",orient:"ignore",size:"ignore",theta:"ignore"}),
rectPosition(model,"x"),rectPosition(model,"y"),text$1(model,"url"))},line:{vgMark:"line",encodeEntry:model=>Object.assign({},baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",size:"ignore",orient:"ignore",theta:"ignore"}),pointPosition("x",model,{defaultPos:"mid"}),pointPosition("y",model,{defaultPos:"mid"}),nonPosition("size",model,{vgChannel:"strokeWidth"}),defined(model))},point:{vgMark:"symbol",encodeEntry:model=>encodeEntry(model)},rect:{vgMark:"rect",encodeEntry:model=>
Object.assign({},baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",orient:"ignore",size:"ignore",theta:"ignore"}),rectPosition(model,"x"),rectPosition(model,"y"))},rule:{vgMark:"rule",encodeEntry:model=>{var {markDef}=model;markDef=markDef.orient;return model.encoding.x||model.encoding.y||model.encoding.latitude||model.encoding.longitude?Object.assign({},baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",orient:"ignore",size:"ignore",theta:"ignore"}),pointOrRangePosition("x",
model,{defaultPos:"horizontal"===markDef?"zeroOrMax":"mid",defaultPos2:"zeroOrMin",range:"vertical"!==markDef}),pointOrRangePosition("y",model,{defaultPos:"vertical"===markDef?"zeroOrMax":"mid",defaultPos2:"zeroOrMin",range:"horizontal"!==markDef}),nonPosition("size",model,{vgChannel:"strokeWidth"})):{}}},square:{vgMark:"symbol",encodeEntry:model=>encodeEntry(model,"square")},text:{vgMark:"text",encodeEntry:model=>{var {config}=model,JSCompiler_temp_const=Object,JSCompiler_temp_const$jscomp$0=JSCompiler_temp_const.assign,
JSCompiler_temp_const$jscomp$1=baseEncodeEntry(model,{align:"include",baseline:"include",color:"include",size:"ignore",orient:"ignore",theta:"include"}),JSCompiler_temp_const$jscomp$2=pointPosition("x",model,{defaultPos:"mid"}),JSCompiler_temp_const$jscomp$3=pointPosition("y",model,{defaultPos:"mid"}),JSCompiler_temp_const$jscomp$4=text$1(model),JSCompiler_temp_const$jscomp$5=nonPosition("size",model,{vgChannel:"fontSize"}),JSCompiler_temp_const$jscomp$6=nonPosition("angle",model);var JSCompiler_inline_result=
void 0===getMarkPropOrConfig("align",model.markDef,config)?"center":void 0;JSCompiler_inline_result=valueIfDefined("align",JSCompiler_inline_result);config=void 0===getMarkPropOrConfig("baseline",model.markDef,config)?"middle":void 0;return JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const,{},JSCompiler_temp_const$jscomp$1,JSCompiler_temp_const$jscomp$2,JSCompiler_temp_const$jscomp$3,JSCompiler_temp_const$jscomp$4,JSCompiler_temp_const$jscomp$5,JSCompiler_temp_const$jscomp$6,JSCompiler_inline_result,
valueIfDefined("baseline",config),pointPosition("radius",model,{defaultPos:null}),pointPosition("theta",model,{defaultPos:null}))}},tick:{vgMark:"rect",encodeEntry:model=>{const {config:config$jscomp$0,markDef:markDef$jscomp$0}=model;var orient=markDef$jscomp$0.orient;const vgSizeChannel$jscomp$0="horizontal"===orient?"width":"height";orient="horizontal"===orient?"height":"width";var JSCompiler_temp_const=Object,JSCompiler_temp_const$jscomp$0=JSCompiler_temp_const.assign,JSCompiler_temp_const$jscomp$1=
baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",orient:"ignore",size:"ignore",theta:"ignore"}),JSCompiler_temp_const$jscomp$2=pointPosition("x",model,{defaultPos:"mid",vgChannel:"xc"}),JSCompiler_temp_const$jscomp$3=pointPosition("y",model,{defaultPos:"mid",vgChannel:"yc"}),JSCompiler_inline_result;{const {config,markDef}=model;var {orient:orient$jscomp$0}=markDef;const vgSizeChannel="horizontal"===orient$jscomp$0?"width":"height";orient$jscomp$0=model.getScaleComponent("horizontal"===
orient$jscomp$0?"x":"y");const markPropOrConfig=null!==(JSCompiler_inline_result=getMarkPropOrConfig("size",markDef,config,{vgChannel:vgSizeChannel}))&&void 0!==JSCompiler_inline_result?JSCompiler_inline_result:config.tick.bandSize;JSCompiler_inline_result=void 0!==markPropOrConfig?markPropOrConfig:(JSCompiler_inline_result=orient$jscomp$0?orient$jscomp$0.get("range"):void 0)&&isVgRangeStep(JSCompiler_inline_result)&&vega.isNumber(JSCompiler_inline_result.step)?3*JSCompiler_inline_result.step/4:3*
getViewConfigDiscreteStep(config.view,vgSizeChannel)/4}return JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const,{},JSCompiler_temp_const$jscomp$1,JSCompiler_temp_const$jscomp$2,JSCompiler_temp_const$jscomp$3,nonPosition("size",model,{defaultValue:JSCompiler_inline_result,vgChannel:vgSizeChannel$jscomp$0}),{[orient]:signalOrValueRef(getMarkPropOrConfig("thickness",markDef$jscomp$0,config$jscomp$0))})}},trail:{vgMark:"trail",encodeEntry:model=>Object.assign({},baseEncodeEntry(model,{align:"ignore",
baseline:"ignore",color:"include",size:"include",orient:"ignore",theta:"ignore"}),pointPosition("x",model,{defaultPos:"mid"}),pointPosition("y",model,{defaultPos:"mid"}),nonPosition("size",model),defined(model))}};class UnitModel extends ModelWithField{constructor(spec,parent,parentGivenName){var _spec$params;let parentGivenSize=3<arguments.length&&void 0!==arguments[3]?arguments[3]:{},config=4<arguments.length?arguments[4]:void 0;super(spec,"unit",parent,parentGivenName,config,void 0,isFrameMixins(spec)?
spec.view:void 0);_defineProperty(this,"markDef",void 0);_defineProperty(this,"encoding",void 0);_defineProperty(this,"specifiedScales",{});_defineProperty(this,"stack",void 0);_defineProperty(this,"specifiedAxes",{});_defineProperty(this,"specifiedLegends",{});_defineProperty(this,"specifiedProjection",{});_defineProperty(this,"selection",[]);_defineProperty(this,"children",[]);const markDef=isMarkDef(spec.mark)?Object.assign({},spec.mark):{type:spec.mark},mark=markDef.type;void 0===markDef.filled&&
(markDef.filled=defaultFilled(markDef,config,{graticule:spec.data&&"graticule"in spec.data}));const encoding=this.encoding=initEncoding(spec.encoding||{},mark,markDef.filled,config);this.markDef=initMarkdef(markDef,encoding,config);this.size=initLayoutSize({encoding,size:isFrameMixins(spec)?Object.assign({},parentGivenSize,spec.width?{width:spec.width}:{},spec.height?{height:spec.height}:{}):parentGivenSize});this.stack=stack$jscomp$1(mark,encoding);this.specifiedScales=this.initScales(mark,encoding);
this.specifiedAxes=this.initAxes(encoding);this.specifiedLegends=this.initLegends(encoding);this.specifiedProjection=spec.projection;this.selection=(null!==(_spec$params=spec.params)&&void 0!==_spec$params?_spec$params:[]).filter(p=>!!p.select)}get hasProjection(){const {encoding}=this,isGeoShapeMark=this.mark===GEOSHAPE,hasGeoPosition=encoding&&GEOPOSITION_CHANNELS.some(channel=>isFieldOrDatumDef(encoding[channel]));return isGeoShapeMark||hasGeoPosition}scaleDomain(channel){return(channel=this.specifiedScales[channel])?
channel.domain:void 0}axis(channel){return this.specifiedAxes[channel]}legend(channel){return this.specifiedLegends[channel]}initScales(mark,encoding){return SCALE_CHANNELS.reduce((scales,channel)=>{const fieldOrDatumDef=getFieldOrDatumDef(encoding[channel]);if(fieldOrDatumDef){var _fieldOrDatumDef$scal;scales[channel]=this.initScale(null!==(_fieldOrDatumDef$scal=fieldOrDatumDef.scale)&&void 0!==_fieldOrDatumDef$scal?_fieldOrDatumDef$scal:{})}return scales},{})}initScale(scale){const {domain,range}=
scale;scale=replaceExprRef(scale);vega.isArray(domain)&&(scale.domain=domain.map(signalRefOrValue));vega.isArray(range)&&(scale.range=range.map(signalRefOrValue));return scale}initAxes(encoding){return POSITION_SCALE_CHANNELS.reduce((_axis,channel)=>{var channelDef=encoding[channel];if(isFieldOrDatumDef(channelDef)||"x"===channel&&isFieldOrDatumDef(encoding.x2)||"y"===channel&&isFieldOrDatumDef(encoding.y2))channelDef=isFieldOrDatumDef(channelDef)?channelDef.axis:void 0,_axis[channel]=channelDef?
this.initAxis(Object.assign({},channelDef)):channelDef;return _axis},{})}initAxis(axis){var props=keys$jscomp$0(axis);const axisInternal={};for(const prop of props)props=axis[prop],axisInternal[prop]=isConditionalAxisValue(props)?signalOrValueRefWithCondition(props):signalRefOrValue(props);return axisInternal}initLegends(encoding){return NONPOSITION_SCALE_CHANNELS.reduce((_legend,channel)=>{var fieldOrDatumDef=getFieldOrDatumDef(encoding[channel]),JSCompiler_temp;if(JSCompiler_temp=fieldOrDatumDef)a:{switch(channel){case "color":case "fill":case "stroke":case "size":case "shape":case "opacity":case "strokeWidth":case "strokeDash":JSCompiler_temp=
!0;break a;case "fillOpacity":case "strokeOpacity":case "angle":JSCompiler_temp=!1;break a}JSCompiler_temp=void 0}JSCompiler_temp&&(fieldOrDatumDef=fieldOrDatumDef.legend,_legend[channel]=fieldOrDatumDef?replaceExprRef(fieldOrDatumDef):fieldOrDatumDef);return _legend},{})}parseData(){this.component.data=parseData(this)}parseLayoutSize(){const {size,component}=this;for(const channel of POSITION_SCALE_CHANNELS){const sizeType=getSizeChannel(channel);if(size[sizeType]){var specifiedSize=size[sizeType];
component.layoutSize.set(sizeType,isStep(specifiedSize)?"step":specifiedSize,!0)}else specifiedSize=defaultUnitSize(this,sizeType),component.layoutSize.set(sizeType,specifiedSize,!1)}}parseSelections(){var JSCompiler_temp_const=this.component,JSCompiler_inline_result;{var selDefs=this.selection;const selCmpts={},selectionConfig=this.config.selection;if(selDefs&&selDefs.length)for(const def of selDefs){selDefs=varName(def.name);var selDef=def.select;const type=vega.isString(selDef)?selDef:selDef.type;
selDef=vega.isObject(selDef)?duplicate(selDef):{type};const cfg=selectionConfig[type];for(const key in cfg)"fields"!==key&&"encodings"!==key&&("mark"===key&&(selDef[key]=Object.assign({},cfg[key],selDef[key])),void 0===selDef[key]||!0===selDef[key])&&(selDef[key]=null!==(JSCompiler_inline_result=cfg[key])&&void 0!==JSCompiler_inline_result?JSCompiler_inline_result:selDef[key]);selDefs=selCmpts[selDefs]=Object.assign({},selDef,{name:selDefs,type,init:def.value,bind:def.bind,events:vega.isString(selDef.on)?
vega.parseSelector(selDef.on,"scope"):vega.array(duplicate(selDef.on))});for(const c of selectionCompilers)c.defined(selDefs)&&c.parse&&c.parse(this,selDefs,def)}JSCompiler_inline_result=selCmpts}JSCompiler_temp_const.selection=JSCompiler_inline_result}parseMarkGroup(){this.component.mark=parseMarkGroups(this)}parseAxesAndHeaders(){this.component.axes=parseUnitAxes(this)}assembleSelectionTopLevelSignals(signals){return assembleTopLevelSignals(this,signals)}assembleSignals(){var JSCompiler_temp_const=
[...assembleAxisSignals(this)];var JSCompiler_inline_result=[];for(const selCmpt of vals$jscomp$0(null!==(_model$component$sele=this.component.selection)&&void 0!==_model$component$sele?_model$component$sele:{})){var _model$component$sele;_model$component$sele=selCmpt.name;let modifyExpr="".concat(_model$component$sele).concat("_tuple",", ").concat("global"===selCmpt.resolve?"true":"{unit: ".concat(unitName(this),"}"));for(const c of selectionCompilers)c.defined(selCmpt)&&(c.signals&&(JSCompiler_inline_result=
c.signals(this,selCmpt,JSCompiler_inline_result)),c.modifyExpr&&(modifyExpr=c.modifyExpr(this,selCmpt,modifyExpr)));JSCompiler_inline_result.push({name:_model$component$sele+"_modify",on:[{events:{signal:selCmpt.name+"_tuple"},update:"modify(".concat(vega.stringValue(selCmpt.name+"_store"),", ").concat(modifyExpr,")")}]})}JSCompiler_inline_result=cleanupEmptyOnArray(JSCompiler_inline_result);return[...JSCompiler_temp_const,...JSCompiler_inline_result]}assembleSelectionData(data){return assembleUnitSelectionData(this,
data)}assembleLayout(){return null}assembleLayoutSignals(){return assembleLayoutSignals(this)}assembleMarks(){var _this$component$mark;let marks=null!==(_this$component$mark=this.component.mark)&&void 0!==_this$component$mark?_this$component$mark:[];this.parent&&isLayerModel(this.parent)||(marks=assembleUnitSelectionMarks(this,marks));return marks.map(this.correctDataNames)}assembleGroupStyle(){const {style}=this.view||{};if(void 0!==style)return style;if(this.encoding.x||this.encoding.y)return"cell"}getMapping(){return this.encoding}get mark(){return this.markDef.type}channelHasField(channel){return channelHasField(this.encoding,
channel)}fieldDef(channel){return getFieldDef(this.encoding[channel])}typedFieldDef(channel){channel=this.fieldDef(channel);return isTypedFieldDef(channel)?channel:null}}class LayerModel extends Model{constructor(spec,parent,parentGivenName,parentGivenSize,config){super(spec,"layer",parent,parentGivenName,config,spec.resolve,spec.view);_defineProperty(this,"children",void 0);const layoutSize=Object.assign({},parentGivenSize,spec.width?{width:spec.width}:{},spec.height?{height:spec.height}:{});this.children=
spec.layer.map((layer,i)=>{if("layer"in layer)return new LayerModel(layer,this,this.getName("layer_".concat(i)),layoutSize,config);if(isUnitSpec(layer))return new UnitModel(layer,this,this.getName("layer_".concat(i)),layoutSize,config);throw Error(invalidSpec(layer));})}parseData(){this.component.data=parseData(this);for(const child of this.children)child.parseData()}parseLayoutSize(){parseChildrenLayoutSize(this);parseNonUnitLayoutSizeForChannel(this,"width");parseNonUnitLayoutSizeForChannel(this,
"height")}parseSelections(){this.component.selection={};for(const child of this.children){child.parseSelections();for(const key of keys$jscomp$0(child.component.selection))this.component.selection[key]=child.component.selection[key]}}parseMarkGroup(){for(const child of this.children)child.parseMarkGroup()}parseAxesAndHeaders(){const {axes,resolve}=this.component,axisCount={top:0,bottom:0,right:0,left:0};for(var child$jscomp$0 of this.children){child$jscomp$0.parseAxesAndHeaders();for(const channel of keys$jscomp$0(child$jscomp$0.component.axes))resolve.axis[channel]=
parseGuideResolve(this.component.resolve,channel),"shared"===resolve.axis[channel]&&(axes[channel]=mergeAxisComponents(axes[channel],child$jscomp$0.component.axes[channel]),axes[channel]||(resolve.axis[channel]="independent",delete axes[channel]))}for(const channel of POSITION_SCALE_CHANNELS){for(const child of this.children)if(child.component.axes[channel]){if("independent"===resolve.axis[channel]){var _axes$channel;axes[channel]=(null!==(_axes$channel=axes[channel])&&void 0!==_axes$channel?_axes$channel:
[]).concat(child.component.axes[channel]);for(const axisComponent of child.component.axes[channel]){const {value:orient,explicit}=axisComponent.getWithExplicit("orient");isSignalRef(orient)||(0<axisCount[orient]&&!explicit&&(child$jscomp$0=OPPOSITE_ORIENT[orient],axisCount[orient]>axisCount[child$jscomp$0]&&axisComponent.set("orient",child$jscomp$0,!1)),axisCount[orient]++)}}delete child.component.axes[channel]}if("independent"===resolve.axis[channel]&&axes[channel]&&1<axes[channel].length)for(const axisCmpt of axes[channel])axisCmpt.get("grid")&&
!axisCmpt.explicit.grid&&(axisCmpt.implicit.grid=!1)}}assembleSelectionTopLevelSignals(signals){return this.children.reduce((sg,child)=>child.assembleSelectionTopLevelSignals(sg),signals)}assembleSignals(){return this.children.reduce((signals,child)=>signals.concat(child.assembleSignals()),assembleAxisSignals(this))}assembleLayoutSignals(){return this.children.reduce((signals,child)=>signals.concat(child.assembleLayoutSignals()),assembleLayoutSignals(this))}assembleSelectionData(data){return this.children.reduce((db,
child)=>child.assembleSelectionData(db),data)}assembleGroupStyle(){var uniqueStyles=new Set;for(const child of this.children)for(const style of vega.array(child.assembleGroupStyle()))uniqueStyles.add(style);uniqueStyles=Array.from(uniqueStyles);return 1<uniqueStyles.length?uniqueStyles:1===uniqueStyles.length?uniqueStyles[0]:void 0}assembleTitle(){let title=super.assembleTitle();if(title)return title;for(const child of this.children)if(title=child.assembleTitle())return title}assembleLayout(){return null}assembleMarks(){return assembleLayerSelectionMarks(this,
this.children.flatMap(child=>child.assembleMarks()))}assembleLegends(){return this.children.reduce((legends,child)=>legends.concat(child.assembleLegends()),assembleLegends(this))}}exports.accessPathDepth=accessPathDepth;exports.accessPathWithDatum=accessPathWithDatum;exports.compile=function(inputSpec){let opt=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};opt.logger&&(current=opt.logger);opt.fieldTitle&&(titleFormatter=opt.fieldTitle);try{const config=initConfig(vega.mergeConfig(opt.config,
inputSpec.config)),spec=normalize$jscomp$0(inputSpec,config),model=buildModel(spec,null,"",void 0,config);model.parse();var data=model.component.data,model$jscomp$0=model;checkLinks(data.sources);let firstPassCounter=0,secondPassCounter=0;for(var i=0;5>i&&optimizationDataflowHelper(data,model$jscomp$0,!0);i++)firstPassCounter++;data.sources.map(moveFacetDown);for(i=0;5>i&&optimizationDataflowHelper(data,model$jscomp$0,!1);i++)secondPassCounter++;checkLinks(data.sources);5===Math.max(firstPassCounter,
secondPassCounter)&&warn("Maximum optimization runs(".concat(5,") reached."));var autosize=spec.autosize;data=config;model$jscomp$0=model;const width=model$jscomp$0.component.layoutSize.get("width"),height=model$jscomp$0.component.layoutSize.get("height");void 0===autosize?(autosize={type:"pad"},model$jscomp$0.hasAxisOrientSignalRef()&&(autosize.resize=!0)):vega.isString(autosize)&&(autosize={type:autosize});var JSCompiler_temp;if(JSCompiler_temp=width&&height){var autoSizeType=autosize.type;JSCompiler_temp=
"fit"===autoSizeType||"fit-x"===autoSizeType||"fit-y"===autoSizeType}if(JSCompiler_temp)if("step"===width&&"step"===height)warn(droppingFit()),autosize.type="pad";else if("step"===width||"step"===height){autoSizeType="step"===width?"width":"height";warn(droppingFit(getPositionScaleChannel(autoSizeType)));JSCompiler_temp=autosize;var JSCompiler_inline_result=(autoSizeType="width"===autoSizeType?"height":"width","fit-".concat(getPositionScaleChannel(autoSizeType)));JSCompiler_temp.type=JSCompiler_inline_result}var JSCompiler_inline_result$jscomp$0=
Object.assign({},1===keys$jscomp$0(autosize).length&&autosize.type?"pad"===autosize.type?{}:{autosize:autosize.type}:{autosize},extractTopLevelProperties(data,!1),extractTopLevelProperties(inputSpec,!0));return{spec:assembleTopLevelModel(model,JSCompiler_inline_result$jscomp$0,inputSpec.datasets,inputSpec.usermeta),normalized:spec}}finally{opt.logger&&(current=main),opt.fieldTitle&&(titleFormatter=defaultTitleFormatter)}};exports.contains=contains;exports.deepEqual=deepEqual;exports.deleteNestedProperty=
deleteNestedProperty;exports.duplicate=duplicate;exports.entries=entries$1;exports.every=every;exports.fieldIntersection=fieldIntersection;exports.flatAccessWithDatum=flatAccessWithDatum;exports.getFirstDefined=getFirstDefined;exports.hasIntersection=hasIntersection;exports.hash=hash;exports.internalField=internalField;exports.isBoolean=isBoolean;exports.isEmpty=isEmpty;exports.isEqual=function(dict,other){const dictKeys=keys$jscomp$0(dict),otherKeys=keys$jscomp$0(other);if(dictKeys.length!==otherKeys.length)return!1;
for(const key of dictKeys)if(dict[key]!==other[key])return!1;return!0};exports.isInternalField=isInternalField;exports.isNullOrFalse=isNullOrFalse;exports.isNumeric=isNumeric;exports.keys=keys$jscomp$0;exports.logicalExpr=logicalExpr;exports.mergeDeep=mergeDeep;exports.never=never;exports.normalize=normalize$jscomp$0;exports.normalizeAngle=normalizeAngle;exports.omit=omit;exports.pick=pick;exports.prefixGenerator=prefixGenerator;exports.removePathFromField=removePathFromField;exports.replaceAll=replaceAll;
exports.replacePathInField=replacePathInField;exports.resetIdCounter=function(){idCounter=42};exports.setEqual=setEqual;exports.some=some;exports.stringify=stringify;exports.titleCase=titleCase;exports.unique=unique;exports.uniqueId=uniqueId;exports.vals=vals$jscomp$0;exports.varName=varName;exports.version="5.2.0";Object.defineProperty(exports,"__esModule",{value:!0})})}
//# sourceMappingURL=module$node_modules$vega_lite$build$vega_lite.js.map
