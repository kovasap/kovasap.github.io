{
"version":3,
"file":"module$node_modules$vega_dataflow$build$vega_dataflow.js",
"lineCount":46,
"mappings":"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",
"sources":["node_modules/vega-dataflow/build/vega-dataflow.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$vega_dataflow$build$vega_dataflow\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('vega-loader'), require('vega-format')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'vega-loader', 'vega-format'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.vega, global.vega, global.vega));\n}(this, (function (exports, vegaUtil, vegaLoader, vegaFormat) { 'use strict';\n\n  function UniqueList(idFunc) {\n    const $ = idFunc || vegaUtil.identity,\n          list = [],\n          ids = {};\n\n    list.add = _ => {\n      const id = $(_);\n\n      if (!ids[id]) {\n        ids[id] = 1;\n        list.push(_);\n      }\n\n      return list;\n    };\n\n    list.remove = _ => {\n      const id = $(_);\n\n      if (ids[id]) {\n        ids[id] = 0;\n        const idx = list.indexOf(_);\n        if (idx >= 0) list.splice(idx, 1);\n      }\n\n      return list;\n    };\n\n    return list;\n  }\n\n  /**\n   * Invoke and await a potentially async callback function. If\n   * an error occurs, trap it and route to Dataflow.error.\n   * @param {Dataflow} df - The dataflow instance\n   * @param {function} callback - A callback function to invoke\n   *   and then await. The dataflow will be passed as the single\n   *   argument to the function.\n   */\n  async function asyncCallback (df, callback) {\n    try {\n      await callback(df);\n    } catch (err) {\n      df.error(err);\n    }\n  }\n\n  const TUPLE_ID_KEY = Symbol('vega_id');\n  let TUPLE_ID = 1;\n  /**\n   * Checks if an input value is a registered tuple.\n   * @param {*} t - The value to check.\n   * @return {boolean} True if the input is a tuple, false otherwise.\n   */\n\n  function isTuple(t) {\n    return !!(t && tupleid(t));\n  }\n  /**\n   * Returns the id of a tuple.\n   * @param {object} t - The input tuple.\n   * @return {*} the tuple id.\n   */\n\n  function tupleid(t) {\n    return t[TUPLE_ID_KEY];\n  }\n  /**\n   * Sets the id of a tuple.\n   * @param {object} t - The input tuple.\n   * @param {*} id - The id value to set.\n   * @return {object} the input tuple.\n   */\n\n  function setid(t, id) {\n    t[TUPLE_ID_KEY] = id;\n    return t;\n  }\n  /**\n   * Ingest an object or value as a data tuple.\n   * If the input value is an object, an id field will be added to it. For\n   * efficiency, the input object is modified directly. A copy is not made.\n   * If the input value is a literal, it will be wrapped in a new object\n   * instance, with the value accessible as the 'data' property.\n   * @param datum - The value to ingest.\n   * @return {object} The ingested data tuple.\n   */\n\n\n  function ingest$1(datum) {\n    const t = datum === Object(datum) ? datum : {\n      data: datum\n    };\n    return tupleid(t) ? t : setid(t, TUPLE_ID++);\n  }\n  /**\n   * Given a source tuple, return a derived copy.\n   * @param {object} t - The source tuple.\n   * @return {object} The derived tuple.\n   */\n\n  function derive(t) {\n    return rederive(t, ingest$1({}));\n  }\n  /**\n   * Rederive a derived tuple by copying values from the source tuple.\n   * @param {object} t - The source tuple.\n   * @param {object} d - The derived tuple.\n   * @return {object} The derived tuple.\n   */\n\n  function rederive(t, d) {\n    for (const k in t) d[k] = t[k];\n\n    return d;\n  }\n  /**\n   * Replace an existing tuple with a new tuple.\n   * @param {object} t - The existing data tuple.\n   * @param {object} d - The new tuple that replaces the old.\n   * @return {object} The new tuple.\n   */\n\n  function replace(t, d) {\n    return setid(d, tupleid(t));\n  }\n  /**\n   * Generate an augmented comparator function that provides stable\n   * sorting by tuple id when the given comparator produces ties.\n   * @param {function} cmp - The comparator to augment.\n   * @param {function} [f] - Optional tuple accessor function.\n   * @return {function} An augmented comparator function.\n   */\n\n  function stableCompare(cmp, f) {\n    return !cmp ? null : f ? (a, b) => cmp(a, b) || tupleid(f(a)) - tupleid(f(b)) : (a, b) => cmp(a, b) || tupleid(a) - tupleid(b);\n  }\n\n  function isChangeSet(v) {\n    return v && v.constructor === changeset;\n  }\n  function changeset() {\n    const add = [],\n          // insert tuples\n    rem = [],\n          // remove tuples\n    mod = [],\n          // modify tuples\n    remp = [],\n          // remove by predicate\n    modp = []; // modify by predicate\n\n    let clean = null,\n        reflow = false;\n    return {\n      constructor: changeset,\n\n      insert(t) {\n        const d = vegaUtil.array(t),\n              n = d.length;\n\n        for (let i = 0; i < n; ++i) add.push(d[i]);\n\n        return this;\n      },\n\n      remove(t) {\n        const a = vegaUtil.isFunction(t) ? remp : rem,\n              d = vegaUtil.array(t),\n              n = d.length;\n\n        for (let i = 0; i < n; ++i) a.push(d[i]);\n\n        return this;\n      },\n\n      modify(t, field, value) {\n        const m = {\n          field: field,\n          value: vegaUtil.constant(value)\n        };\n\n        if (vegaUtil.isFunction(t)) {\n          m.filter = t;\n          modp.push(m);\n        } else {\n          m.tuple = t;\n          mod.push(m);\n        }\n\n        return this;\n      },\n\n      encode(t, set) {\n        if (vegaUtil.isFunction(t)) modp.push({\n          filter: t,\n          field: set\n        });else mod.push({\n          tuple: t,\n          field: set\n        });\n        return this;\n      },\n\n      clean(value) {\n        clean = value;\n        return this;\n      },\n\n      reflow() {\n        reflow = true;\n        return this;\n      },\n\n      pulse(pulse, tuples) {\n        const cur = {},\n              out = {};\n        let i, n, m, f, t, id; // build lookup table of current tuples\n\n        for (i = 0, n = tuples.length; i < n; ++i) {\n          cur[tupleid(tuples[i])] = 1;\n        } // process individual tuples to remove\n\n\n        for (i = 0, n = rem.length; i < n; ++i) {\n          t = rem[i];\n          cur[tupleid(t)] = -1;\n        } // process predicate-based removals\n\n\n        for (i = 0, n = remp.length; i < n; ++i) {\n          f = remp[i];\n          tuples.forEach(t => {\n            if (f(t)) cur[tupleid(t)] = -1;\n          });\n        } // process all add tuples\n\n\n        for (i = 0, n = add.length; i < n; ++i) {\n          t = add[i];\n          id = tupleid(t);\n\n          if (cur[id]) {\n            // tuple already resides in dataset\n            // if flagged for both add and remove, cancel\n            cur[id] = 1;\n          } else {\n            // tuple does not reside in dataset, add\n            pulse.add.push(ingest$1(add[i]));\n          }\n        } // populate pulse rem list\n\n\n        for (i = 0, n = tuples.length; i < n; ++i) {\n          t = tuples[i];\n          if (cur[tupleid(t)] < 0) pulse.rem.push(t);\n        } // modify helper method\n\n\n        function modify(t, f, v) {\n          if (v) {\n            t[f] = v(t);\n          } else {\n            pulse.encode = f;\n          }\n\n          if (!reflow) out[tupleid(t)] = t;\n        } // process individual tuples to modify\n\n\n        for (i = 0, n = mod.length; i < n; ++i) {\n          m = mod[i];\n          t = m.tuple;\n          f = m.field;\n          id = cur[tupleid(t)];\n\n          if (id > 0) {\n            modify(t, f, m.value);\n            pulse.modifies(f);\n          }\n        } // process predicate-based modifications\n\n\n        for (i = 0, n = modp.length; i < n; ++i) {\n          m = modp[i];\n          f = m.filter;\n          tuples.forEach(t => {\n            if (f(t) && cur[tupleid(t)] > 0) {\n              modify(t, m.field, m.value);\n            }\n          });\n          pulse.modifies(m.field);\n        } // upon reflow request, populate mod with all non-removed tuples\n        // otherwise, populate mod with modified tuples only\n\n\n        if (reflow) {\n          pulse.mod = rem.length || remp.length ? tuples.filter(t => cur[tupleid(t)] > 0) : tuples.slice();\n        } else {\n          for (id in out) pulse.mod.push(out[id]);\n        } // set pulse garbage collection request\n\n\n        if (clean || clean == null && (rem.length || remp.length)) {\n          pulse.clean(true);\n        }\n\n        return pulse;\n      }\n\n    };\n  }\n\n  const CACHE = '_:mod:_';\n  /**\n   * Hash that tracks modifications to assigned values.\n   * Callers *must* use the set method to update values.\n   */\n\n  function Parameters() {\n    Object.defineProperty(this, CACHE, {\n      writable: true,\n      value: {}\n    });\n  }\n  Parameters.prototype = {\n    /**\n     * Set a parameter value. If the parameter value changes, the parameter\n     * will be recorded as modified.\n     * @param {string} name - The parameter name.\n     * @param {number} index - The index into an array-value parameter. Ignored if\n     *   the argument is undefined, null or less than zero.\n     * @param {*} value - The parameter value to set.\n     * @param {boolean} [force=false] - If true, records the parameter as modified\n     *   even if the value is unchanged.\n     * @return {Parameters} - This parameter object.\n     */\n    set(name, index, value, force) {\n      const o = this,\n            v = o[name],\n            mod = o[CACHE];\n\n      if (index != null && index >= 0) {\n        if (v[index] !== value || force) {\n          v[index] = value;\n          mod[index + ':' + name] = -1;\n          mod[name] = -1;\n        }\n      } else if (v !== value || force) {\n        o[name] = value;\n        mod[name] = vegaUtil.isArray(value) ? 1 + value.length : -1;\n      }\n\n      return o;\n    },\n\n    /**\n     * Tests if one or more parameters has been modified. If invoked with no\n     * arguments, returns true if any parameter value has changed. If the first\n     * argument is array, returns trues if any parameter name in the array has\n     * changed. Otherwise, tests if the given name and optional array index has\n     * changed.\n     * @param {string} name - The parameter name to test.\n     * @param {number} [index=undefined] - The parameter array index to test.\n     * @return {boolean} - Returns true if a queried parameter was modified.\n     */\n    modified(name, index) {\n      const mod = this[CACHE];\n\n      if (!arguments.length) {\n        for (const k in mod) {\n          if (mod[k]) return true;\n        }\n\n        return false;\n      } else if (vegaUtil.isArray(name)) {\n        for (let k = 0; k < name.length; ++k) {\n          if (mod[name[k]]) return true;\n        }\n\n        return false;\n      }\n\n      return index != null && index >= 0 ? index + 1 < mod[name] || !!mod[index + ':' + name] : !!mod[name];\n    },\n\n    /**\n     * Clears the modification records. After calling this method,\n     * all parameters are considered unmodified.\n     */\n    clear() {\n      this[CACHE] = {};\n      return this;\n    }\n\n  };\n\n  let OP_ID = 0;\n  const PULSE = 'pulse',\n        NO_PARAMS = new Parameters(); // Boolean Flags\n\n  const SKIP$1 = 1,\n        MODIFIED = 2;\n  /**\n   * An Operator is a processing node in a dataflow graph.\n   * Each operator stores a value and an optional value update function.\n   * Operators can accept a hash of named parameters. Parameter values can\n   * either be direct (JavaScript literals, arrays, objects) or indirect\n   * (other operators whose values will be pulled dynamically). Operators\n   * included as parameters will have this operator added as a dependency.\n   * @constructor\n   * @param {*} [init] - The initial value for this operator.\n   * @param {function(object, Pulse)} [update] - An update function. Upon\n   *   evaluation of this operator, the update function will be invoked and the\n   *   return value will be used as the new value of this operator.\n   * @param {object} [params] - The parameters for this operator.\n   * @param {boolean} [react=true] - Flag indicating if this operator should\n   *   listen for changes to upstream operators included as parameters.\n   * @see parameters\n   */\n\n  function Operator(init, update, params, react) {\n    this.id = ++OP_ID;\n    this.value = init;\n    this.stamp = -1;\n    this.rank = -1;\n    this.qrank = -1;\n    this.flags = 0;\n\n    if (update) {\n      this._update = update;\n    }\n\n    if (params) this.parameters(params, react);\n  }\n\n  function flag(bit) {\n    return function (state) {\n      const f = this.flags;\n      if (arguments.length === 0) return !!(f & bit);\n      this.flags = state ? f | bit : f & ~bit;\n      return this;\n    };\n  }\n\n  Operator.prototype = {\n    /**\n     * Returns a list of target operators dependent on this operator.\n     * If this list does not exist, it is created and then returned.\n     * @return {UniqueList}\n     */\n    targets() {\n      return this._targets || (this._targets = UniqueList(vegaUtil.id));\n    },\n\n    /**\n     * Sets the value of this operator.\n     * @param {*} value - the value to set.\n     * @return {Number} Returns 1 if the operator value has changed\n     *   according to strict equality, returns 0 otherwise.\n     */\n    set(value) {\n      if (this.value !== value) {\n        this.value = value;\n        return 1;\n      } else {\n        return 0;\n      }\n    },\n\n    /**\n     * Indicates that operator evaluation should be skipped on the next pulse.\n     * This operator will still propagate incoming pulses, but its update function\n     * will not be invoked. The skip flag is reset after every pulse, so calling\n     * this method will affect processing of the next pulse only.\n     */\n    skip: flag(SKIP$1),\n\n    /**\n     * Indicates that this operator's value has been modified on its most recent\n     * pulse. Normally modification is checked via strict equality; however, in\n     * some cases it is more efficient to update the internal state of an object.\n     * In those cases, the modified flag can be used to trigger propagation. Once\n     * set, the modification flag persists across pulses until unset. The flag can\n     * be used with the last timestamp to test if a modification is recent.\n     */\n    modified: flag(MODIFIED),\n\n    /**\n     * Sets the parameters for this operator. The parameter values are analyzed for\n     * operator instances. If found, this operator will be added as a dependency\n     * of the parameterizing operator. Operator values are dynamically marshalled\n     * from each operator parameter prior to evaluation. If a parameter value is\n     * an array, the array will also be searched for Operator instances. However,\n     * the search does not recurse into sub-arrays or object properties.\n     * @param {object} params - A hash of operator parameters.\n     * @param {boolean} [react=true] - A flag indicating if this operator should\n     *   automatically update (react) when parameter values change. In other words,\n     *   this flag determines if the operator registers itself as a listener on\n     *   any upstream operators included in the parameters.\n     * @param {boolean} [initonly=false] - A flag indicating if this operator\n     *   should calculate an update only upon its initiatal evaluation, then\n     *   deregister dependencies and suppress all future update invocations.\n     * @return {Operator[]} - An array of upstream dependencies.\n     */\n    parameters(params, react, initonly) {\n      react = react !== false;\n      const argval = this._argval = this._argval || new Parameters(),\n            argops = this._argops = this._argops || [],\n            deps = [];\n      let name, value, n, i;\n\n      const add = (name, index, value) => {\n        if (value instanceof Operator) {\n          if (value !== this) {\n            if (react) value.targets().add(this);\n            deps.push(value);\n          }\n\n          argops.push({\n            op: value,\n            name: name,\n            index: index\n          });\n        } else {\n          argval.set(name, index, value);\n        }\n      };\n\n      for (name in params) {\n        value = params[name];\n\n        if (name === PULSE) {\n          vegaUtil.array(value).forEach(op => {\n            if (!(op instanceof Operator)) {\n              vegaUtil.error('Pulse parameters must be operator instances.');\n            } else if (op !== this) {\n              op.targets().add(this);\n              deps.push(op);\n            }\n          });\n          this.source = value;\n        } else if (vegaUtil.isArray(value)) {\n          argval.set(name, -1, Array(n = value.length));\n\n          for (i = 0; i < n; ++i) add(name, i, value[i]);\n        } else {\n          add(name, -1, value);\n        }\n      }\n\n      this.marshall().clear(); // initialize values\n\n      if (initonly) argops.initonly = true;\n      return deps;\n    },\n\n    /**\n     * Internal method for marshalling parameter values.\n     * Visits each operator dependency to pull the latest value.\n     * @return {Parameters} A Parameters object to pass to the update function.\n     */\n    marshall(stamp) {\n      const argval = this._argval || NO_PARAMS,\n            argops = this._argops;\n      let item, i, op, mod;\n\n      if (argops) {\n        const n = argops.length;\n\n        for (i = 0; i < n; ++i) {\n          item = argops[i];\n          op = item.op;\n          mod = op.modified() && op.stamp === stamp;\n          argval.set(item.name, item.index, op.value, mod);\n        }\n\n        if (argops.initonly) {\n          for (i = 0; i < n; ++i) {\n            item = argops[i];\n            item.op.targets().remove(this);\n          }\n\n          this._argops = null;\n          this._update = null;\n        }\n      }\n\n      return argval;\n    },\n\n    /**\n     * Detach this operator from the dataflow.\n     * Unregisters listeners on upstream dependencies.\n     */\n    detach() {\n      const argops = this._argops;\n      let i, n, item, op;\n\n      if (argops) {\n        for (i = 0, n = argops.length; i < n; ++i) {\n          item = argops[i];\n          op = item.op;\n\n          if (op._targets) {\n            op._targets.remove(this);\n          }\n        }\n      } // remove references to the source and pulse object,\n      // if present, to prevent memory leaks of old data.\n\n\n      this.pulse = null;\n      this.source = null;\n    },\n\n    /**\n     * Delegate method to perform operator processing.\n     * Subclasses can override this method to perform custom processing.\n     * By default, it marshalls parameters and calls the update function\n     * if that function is defined. If the update function does not\n     * change the operator value then StopPropagation is returned.\n     * If no update function is defined, this method does nothing.\n     * @param {Pulse} pulse - the current dataflow pulse.\n     * @return The output pulse or StopPropagation. A falsy return value\n     *   (including undefined) will let the input pulse pass through.\n     */\n    evaluate(pulse) {\n      const update = this._update;\n\n      if (update) {\n        const params = this.marshall(pulse.stamp),\n              v = update.call(this, params, pulse);\n        params.clear();\n\n        if (v !== this.value) {\n          this.value = v;\n        } else if (!this.modified()) {\n          return pulse.StopPropagation;\n        }\n      }\n    },\n\n    /**\n     * Run this operator for the current pulse. If this operator has already\n     * been run at (or after) the pulse timestamp, returns StopPropagation.\n     * Internally, this method calls {@link evaluate} to perform processing.\n     * If {@link evaluate} returns a falsy value, the input pulse is returned.\n     * This method should NOT be overridden, instead overrride {@link evaluate}.\n     * @param {Pulse} pulse - the current dataflow pulse.\n     * @return the output pulse for this operator (or StopPropagation)\n     */\n    run(pulse) {\n      if (pulse.stamp < this.stamp) return pulse.StopPropagation;\n      let rv;\n\n      if (this.skip()) {\n        this.skip(false);\n        rv = 0;\n      } else {\n        rv = this.evaluate(pulse);\n      }\n\n      return this.pulse = rv || pulse;\n    }\n\n  };\n\n  /**\n   * Add an operator to the dataflow graph. This function accepts a\n   * variety of input argument types. The basic signature supports an\n   * initial value, update function and parameters. If the first parameter\n   * is an Operator instance, it will be added directly. If it is a\n   * constructor for an Operator subclass, a new instance will be instantiated.\n   * Otherwise, if the first parameter is a function instance, it will be used\n   * as the update function and a null initial value is assumed.\n   * @param {*} init - One of: the operator to add, the initial value of\n   *   the operator, an operator class to instantiate, or an update function.\n   * @param {function} [update] - The operator update function.\n   * @param {object} [params] - The operator parameters.\n   * @param {boolean} [react=true] - Flag indicating if this operator should\n   *   listen for changes to upstream operators included as parameters.\n   * @return {Operator} - The added operator.\n   */\n\n  function add (init, update, params, react) {\n    let shift = 1,\n        op;\n\n    if (init instanceof Operator) {\n      op = init;\n    } else if (init && init.prototype instanceof Operator) {\n      op = new init();\n    } else if (vegaUtil.isFunction(init)) {\n      op = new Operator(null, init);\n    } else {\n      shift = 0;\n      op = new Operator(init, update);\n    }\n\n    this.rank(op);\n\n    if (shift) {\n      react = params;\n      params = update;\n    }\n\n    if (params) this.connect(op, op.parameters(params, react));\n    this.touch(op);\n    return op;\n  }\n\n  /**\n   * Connect a target operator as a dependent of source operators.\n   * If necessary, this method will rerank the target operator and its\n   * dependents to ensure propagation proceeds in a topologically sorted order.\n   * @param {Operator} target - The target operator.\n   * @param {Array<Operator>} - The source operators that should propagate\n   *   to the target operator.\n   */\n  function connect (target, sources) {\n    const targetRank = target.rank,\n          n = sources.length;\n\n    for (let i = 0; i < n; ++i) {\n      if (targetRank < sources[i].rank) {\n        this.rerank(target);\n        return;\n      }\n    }\n  }\n\n  let STREAM_ID = 0;\n  /**\n   * Models an event stream.\n   * @constructor\n   * @param {function(Object, number): boolean} [filter] - Filter predicate.\n   *   Events pass through when truthy, events are suppressed when falsy.\n   * @param {function(Object): *} [apply] - Applied to input events to produce\n   *   new event values.\n   * @param {function(Object)} [receive] - Event callback function to invoke\n   *   upon receipt of a new event. Use to override standard event processing.\n   */\n\n  function EventStream(filter, apply, receive) {\n    this.id = ++STREAM_ID;\n    this.value = null;\n    if (receive) this.receive = receive;\n    if (filter) this._filter = filter;\n    if (apply) this._apply = apply;\n  }\n  /**\n   * Creates a new event stream instance with the provided\n   * (optional) filter, apply and receive functions.\n   * @param {function(Object, number): boolean} [filter] - Filter predicate.\n   *   Events pass through when truthy, events are suppressed when falsy.\n   * @param {function(Object): *} [apply] - Applied to input events to produce\n   *   new event values.\n   * @see EventStream\n   */\n\n  function stream(filter, apply, receive) {\n    return new EventStream(filter, apply, receive);\n  }\n  EventStream.prototype = {\n    _filter: vegaUtil.truthy,\n    _apply: vegaUtil.identity,\n\n    targets() {\n      return this._targets || (this._targets = UniqueList(vegaUtil.id));\n    },\n\n    consume(_) {\n      if (!arguments.length) return !!this._consume;\n      this._consume = !!_;\n      return this;\n    },\n\n    receive(evt) {\n      if (this._filter(evt)) {\n        const val = this.value = this._apply(evt),\n              trg = this._targets,\n              n = trg ? trg.length : 0;\n\n        for (let i = 0; i < n; ++i) trg[i].receive(val);\n\n        if (this._consume) {\n          evt.preventDefault();\n          evt.stopPropagation();\n        }\n      }\n    },\n\n    filter(filter) {\n      const s = stream(filter);\n      this.targets().add(s);\n      return s;\n    },\n\n    apply(apply) {\n      const s = stream(null, apply);\n      this.targets().add(s);\n      return s;\n    },\n\n    merge() {\n      const s = stream();\n      this.targets().add(s);\n\n      for (let i = 0, n = arguments.length; i < n; ++i) {\n        arguments[i].targets().add(s);\n      }\n\n      return s;\n    },\n\n    throttle(pause) {\n      let t = -1;\n      return this.filter(() => {\n        const now = Date.now();\n\n        if (now - t > pause) {\n          t = now;\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n    },\n\n    debounce(delay) {\n      const s = stream();\n      this.targets().add(stream(null, null, vegaUtil.debounce(delay, e => {\n        const df = e.dataflow;\n        s.receive(e);\n        if (df && df.run) df.run();\n      })));\n      return s;\n    },\n\n    between(a, b) {\n      let active = false;\n      a.targets().add(stream(null, null, () => active = true));\n      b.targets().add(stream(null, null, () => active = false));\n      return this.filter(() => active);\n    },\n\n    detach() {\n      // ensures compatibility with operators (#2753)\n      // remove references to other streams and filter functions that may\n      // be bound to subcontexts that need to be garbage collected.\n      this._filter = vegaUtil.truthy;\n      this._targets = null;\n    }\n\n  };\n\n  /**\n   * Create a new event stream from an event source.\n   * @param {object} source - The event source to monitor. The input must\n   *  support the addEventListener method.\n   * @param {string} type - The event type.\n   * @param {function(object): boolean} [filter] - Event filter function.\n   * @param {function(object): *} [apply] - Event application function.\n   *   If provided, this function will be invoked and the result will be\n   *   used as the downstream event value.\n   * @return {EventStream}\n   */\n\n  function events (source, type, filter, apply) {\n    const df = this,\n          s = stream(filter, apply),\n          send = function (e) {\n      e.dataflow = df;\n\n      try {\n        s.receive(e);\n      } catch (error) {\n        df.error(error);\n      } finally {\n        df.run();\n      }\n    };\n\n    let sources;\n\n    if (typeof source === 'string' && typeof document !== 'undefined') {\n      sources = document.querySelectorAll(source);\n    } else {\n      sources = vegaUtil.array(source);\n    }\n\n    const n = sources.length;\n\n    for (let i = 0; i < n; ++i) {\n      sources[i].addEventListener(type, send);\n    }\n\n    return s;\n  }\n\n  function parse(data, format) {\n    const locale = this.locale();\n    return vegaLoader.read(data, format, locale.timeParse, locale.utcParse);\n  }\n  /**\n   * Ingests new data into the dataflow. First parses the data using the\n   * vega-loader read method, then pulses a changeset to the target operator.\n   * @param {Operator} target - The Operator to target with ingested data,\n   *   typically a Collect transform instance.\n   * @param {*} data - The input data, prior to parsing. For JSON this may\n   *   be a string or an object. For CSV, TSV, etc should be a string.\n   * @param {object} format - The data format description for parsing\n   *   loaded data. This object is passed to the vega-loader read method.\n   * @returns {Dataflow}\n   */\n\n  function ingest(target, data, format) {\n    data = this.parse(data, format);\n    return this.pulse(target, this.changeset().insert(data));\n  }\n  /**\n   * Request data from an external source, parse it, and return a Promise.\n   * @param {string} url - The URL from which to load the data. This string\n   *   is passed to the vega-loader load method.\n   * @param {object} [format] - The data format description for parsing\n   *   loaded data. This object is passed to the vega-loader read method.\n   * @return {Promise} A Promise that resolves upon completion of the request.\n   *   The resolved object contains the following properties:\n   *   - data: an array of parsed data (or null upon error)\n   *   - status: a code for success (0), load fail (-1), or parse fail (-2)\n   */\n\n  async function request(url, format) {\n    const df = this;\n    let status = 0,\n        data;\n\n    try {\n      data = await df.loader().load(url, {\n        context: 'dataflow',\n        response: vegaLoader.responseType(format && format.type)\n      });\n\n      try {\n        data = df.parse(data, format);\n      } catch (err) {\n        status = -2;\n        df.warn('Data ingestion failed', url, err);\n      }\n    } catch (err) {\n      status = -1;\n      df.warn('Loading failed', url, err);\n    }\n\n    return {\n      data,\n      status\n    };\n  }\n  async function preload(target, url, format) {\n    const df = this,\n          pending = df._pending || loadPending(df);\n    pending.requests += 1;\n    const res = await df.request(url, format);\n    df.pulse(target, df.changeset().remove(vegaUtil.truthy).insert(res.data || []));\n    pending.done();\n    return res;\n  }\n\n  function loadPending(df) {\n    let accept;\n    const pending = new Promise(a => accept = a);\n    pending.requests = 0;\n\n    pending.done = () => {\n      if (--pending.requests === 0) {\n        df._pending = null;\n        accept(df);\n      }\n    };\n\n    return df._pending = pending;\n  }\n\n  const SKIP = {\n    skip: true\n  };\n  /**\n   * Perform operator updates in response to events. Applies an\n   * update function to compute a new operator value. If the update function\n   * returns a {@link ChangeSet}, the operator will be pulsed with those tuple\n   * changes. Otherwise, the operator value will be updated to the return value.\n   * @param {EventStream|Operator} source - The event source to react to.\n   *   This argument can be either an EventStream or an Operator.\n   * @param {Operator|function(object):Operator} target - The operator to update.\n   *   This argument can either be an Operator instance or (if the source\n   *   argument is an EventStream), a function that accepts an event object as\n   *   input and returns an Operator to target.\n   * @param {function(Parameters,Event): *} [update] - Optional update function\n   *   to compute the new operator value, or a literal value to set. Update\n   *   functions expect to receive a parameter object and event as arguments.\n   *   This function can either return a new operator value or (if the source\n   *   argument is an EventStream) a {@link ChangeSet} instance to pulse\n   *   the target operator with tuple changes.\n   * @param {object} [params] - The update function parameters.\n   * @param {object} [options] - Additional options hash. If not overridden,\n   *   updated operators will be skipped by default.\n   * @param {boolean} [options.skip] - If true, the operator will\n   *  be skipped: it will not be evaluated, but its dependents will be.\n   * @param {boolean} [options.force] - If true, the operator will\n   *   be re-evaluated even if its value has not changed.\n   * @return {Dataflow}\n   */\n\n  function on (source, target, update, params, options) {\n    const fn = source instanceof Operator ? onOperator : onStream;\n    fn(this, source, target, update, params, options);\n    return this;\n  }\n\n  function onStream(df, stream, target, update, params, options) {\n    const opt = vegaUtil.extend({}, options, SKIP);\n    let func, op;\n    if (!vegaUtil.isFunction(target)) target = vegaUtil.constant(target);\n\n    if (update === undefined) {\n      func = e => df.touch(target(e));\n    } else if (vegaUtil.isFunction(update)) {\n      op = new Operator(null, update, params, false);\n\n      func = e => {\n        op.evaluate(e);\n        const t = target(e),\n              v = op.value;\n        isChangeSet(v) ? df.pulse(t, v, options) : df.update(t, v, opt);\n      };\n    } else {\n      func = e => df.update(target(e), update, opt);\n    }\n\n    stream.apply(func);\n  }\n\n  function onOperator(df, source, target, update, params, options) {\n    if (update === undefined) {\n      source.targets().add(target);\n    } else {\n      const opt = options || {},\n            op = new Operator(null, updater(target, update), params, false);\n      op.modified(opt.force);\n      op.rank = source.rank; // immediately follow source\n\n      source.targets().add(op); // add dependency\n\n      if (target) {\n        op.skip(true); // skip first invocation\n\n        op.value = target.value; // initialize value\n\n        op.targets().add(target); // chain dependencies\n\n        df.connect(target, [op]); // rerank as needed, #1672\n      }\n    }\n  }\n\n  function updater(target, update) {\n    update = vegaUtil.isFunction(update) ? update : vegaUtil.constant(update);\n    return target ? function (_, pulse) {\n      const value = update(_, pulse);\n\n      if (!target.skip()) {\n        target.skip(value !== this.value).value = value;\n      }\n\n      return value;\n    } : update;\n  }\n\n  /**\n   * Assigns a rank to an operator. Ranks are assigned in increasing order\n   * by incrementing an internal rank counter.\n   * @param {Operator} op - The operator to assign a rank.\n   */\n\n  function rank(op) {\n    op.rank = ++this._rank;\n  }\n  /**\n   * Re-ranks an operator and all downstream target dependencies. This\n   * is necessary when upstream dependencies of higher rank are added to\n   * a target operator.\n   * @param {Operator} op - The operator to re-rank.\n   */\n\n  function rerank(op) {\n    const queue = [op];\n    let cur, list, i;\n\n    while (queue.length) {\n      this.rank(cur = queue.pop());\n\n      if (list = cur._targets) {\n        for (i = list.length; --i >= 0;) {\n          queue.push(cur = list[i]);\n          if (cur === op) vegaUtil.error('Cycle detected in dataflow graph.');\n        }\n      }\n    }\n  }\n\n  /**\n   * Sentinel value indicating pulse propagation should stop.\n   */\n\n  const StopPropagation = {}; // Pulse visit type flags\n\n  const ADD = 1 << 0,\n        REM = 1 << 1,\n        MOD = 1 << 2,\n        ADD_REM = ADD | REM,\n        ADD_MOD = ADD | MOD,\n        ALL = ADD | REM | MOD,\n        REFLOW = 1 << 3,\n        SOURCE = 1 << 4,\n        NO_SOURCE = 1 << 5,\n        NO_FIELDS = 1 << 6;\n  /**\n   * A Pulse enables inter-operator communication during a run of the\n   * dataflow graph. In addition to the current timestamp, a pulse may also\n   * contain a change-set of added, removed or modified data tuples, as well as\n   * a pointer to a full backing data source. Tuple change sets may not\n   * be fully materialized; for example, to prevent needless array creation\n   * a change set may include larger arrays and corresponding filter functions.\n   * The pulse provides a {@link visit} method to enable proper and efficient\n   * iteration over requested data tuples.\n   *\n   * In addition, each pulse can track modification flags for data tuple fields.\n   * Responsible transform operators should call the {@link modifies} method to\n   * indicate changes to data fields. The {@link modified} method enables\n   * querying of this modification state.\n   *\n   * @constructor\n   * @param {Dataflow} dataflow - The backing dataflow instance.\n   * @param {number} stamp - The current propagation timestamp.\n   * @param {string} [encode] - An optional encoding set name, which is then\n   *   accessible as Pulse.encode. Operators can respond to (or ignore) this\n   *   setting as appropriate. This parameter can be used in conjunction with\n   *   the Encode transform in the vega-encode module.\n   */\n\n  function Pulse(dataflow, stamp, encode) {\n    this.dataflow = dataflow;\n    this.stamp = stamp == null ? -1 : stamp;\n    this.add = [];\n    this.rem = [];\n    this.mod = [];\n    this.fields = null;\n    this.encode = encode || null;\n  }\n\n  function materialize(data, filter) {\n    const out = [];\n    vegaUtil.visitArray(data, filter, _ => out.push(_));\n    return out;\n  }\n\n  function filter(pulse, flags) {\n    const map = {};\n    pulse.visit(flags, t => {\n      map[tupleid(t)] = 1;\n    });\n    return t => map[tupleid(t)] ? null : t;\n  }\n\n  function addFilter(a, b) {\n    return a ? (t, i) => a(t, i) && b(t, i) : b;\n  }\n\n  Pulse.prototype = {\n    /**\n     * Sentinel value indicating pulse propagation should stop.\n     */\n    StopPropagation,\n\n    /**\n     * Boolean flag indicating ADD (added) tuples.\n     */\n    ADD,\n\n    /**\n     * Boolean flag indicating REM (removed) tuples.\n     */\n    REM,\n\n    /**\n     * Boolean flag indicating MOD (modified) tuples.\n     */\n    MOD,\n\n    /**\n     * Boolean flag indicating ADD (added) and REM (removed) tuples.\n     */\n    ADD_REM,\n\n    /**\n     * Boolean flag indicating ADD (added) and MOD (modified) tuples.\n     */\n    ADD_MOD,\n\n    /**\n     * Boolean flag indicating ADD, REM and MOD tuples.\n     */\n    ALL,\n\n    /**\n     * Boolean flag indicating all tuples in a data source\n     * except for the ADD, REM and MOD tuples.\n     */\n    REFLOW,\n\n    /**\n     * Boolean flag indicating a 'pass-through' to a\n     * backing data source, ignoring ADD, REM and MOD tuples.\n     */\n    SOURCE,\n\n    /**\n     * Boolean flag indicating that source data should be\n     * suppressed when creating a forked pulse.\n     */\n    NO_SOURCE,\n\n    /**\n     * Boolean flag indicating that field modifications should be\n     * suppressed when creating a forked pulse.\n     */\n    NO_FIELDS,\n\n    /**\n     * Creates a new pulse based on the values of this pulse.\n     * The dataflow, time stamp and field modification values are copied over.\n     * By default, new empty ADD, REM and MOD arrays are created.\n     * @param {number} flags - Integer of boolean flags indicating which (if any)\n     *   tuple arrays should be copied to the new pulse. The supported flag values\n     *   are ADD, REM and MOD. Array references are copied directly: new array\n     *   instances are not created.\n     * @return {Pulse} - The forked pulse instance.\n     * @see init\n     */\n    fork(flags) {\n      return new Pulse(this.dataflow).init(this, flags);\n    },\n\n    /**\n     * Creates a copy of this pulse with new materialized array\n     * instances for the ADD, REM, MOD, and SOURCE arrays.\n     * The dataflow, time stamp and field modification values are copied over.\n     * @return {Pulse} - The cloned pulse instance.\n     * @see init\n     */\n    clone() {\n      const p = this.fork(ALL);\n      p.add = p.add.slice();\n      p.rem = p.rem.slice();\n      p.mod = p.mod.slice();\n      if (p.source) p.source = p.source.slice();\n      return p.materialize(ALL | SOURCE);\n    },\n\n    /**\n     * Returns a pulse that adds all tuples from a backing source. This is\n     * useful for cases where operators are added to a dataflow after an\n     * upstream data pipeline has already been processed, ensuring that\n     * new operators can observe all tuples within a stream.\n     * @return {Pulse} - A pulse instance with all source tuples included\n     *   in the add array. If the current pulse already has all source\n     *   tuples in its add array, it is returned directly. If the current\n     *   pulse does not have a backing source, it is returned directly.\n     */\n    addAll() {\n      let p = this;\n      const reuse = !p.source || p.add === p.rem // special case for indexed set (e.g., crossfilter)\n      || !p.rem.length && p.source.length === p.add.length;\n\n      if (reuse) {\n        return p;\n      } else {\n        p = new Pulse(this.dataflow).init(this);\n        p.add = p.source;\n        p.rem = []; // new operators can ignore rem #2769\n\n        return p;\n      }\n    },\n\n    /**\n     * Initialize this pulse based on the values of another pulse. This method\n     * is used internally by {@link fork} to initialize a new forked tuple.\n     * The dataflow, time stamp and field modification values are copied over.\n     * By default, new empty ADD, REM and MOD arrays are created.\n     * @param {Pulse} src - The source pulse to copy from.\n     * @param {number} flags - Integer of boolean flags indicating which (if any)\n     *   tuple arrays should be copied to the new pulse. The supported flag values\n     *   are ADD, REM and MOD. Array references are copied directly: new array\n     *   instances are not created. By default, source data arrays are copied\n     *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.\n     * @return {Pulse} - Returns this Pulse instance.\n     */\n    init(src, flags) {\n      const p = this;\n      p.stamp = src.stamp;\n      p.encode = src.encode;\n\n      if (src.fields && !(flags & NO_FIELDS)) {\n        p.fields = src.fields;\n      }\n\n      if (flags & ADD) {\n        p.addF = src.addF;\n        p.add = src.add;\n      } else {\n        p.addF = null;\n        p.add = [];\n      }\n\n      if (flags & REM) {\n        p.remF = src.remF;\n        p.rem = src.rem;\n      } else {\n        p.remF = null;\n        p.rem = [];\n      }\n\n      if (flags & MOD) {\n        p.modF = src.modF;\n        p.mod = src.mod;\n      } else {\n        p.modF = null;\n        p.mod = [];\n      }\n\n      if (flags & NO_SOURCE) {\n        p.srcF = null;\n        p.source = null;\n      } else {\n        p.srcF = src.srcF;\n        p.source = src.source;\n        if (src.cleans) p.cleans = src.cleans;\n      }\n\n      return p;\n    },\n\n    /**\n     * Schedules a function to run after pulse propagation completes.\n     * @param {function} func - The function to run.\n     */\n    runAfter(func) {\n      this.dataflow.runAfter(func);\n    },\n\n    /**\n     * Indicates if tuples have been added, removed or modified.\n     * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.\n     *   Defaults to ALL, returning true if any tuple type has changed.\n     * @return {boolean} - Returns true if one or more queried tuple types have\n     *   changed, false otherwise.\n     */\n    changed(flags) {\n      const f = flags || ALL;\n      return f & ADD && this.add.length || f & REM && this.rem.length || f & MOD && this.mod.length;\n    },\n\n    /**\n     * Forces a \"reflow\" of tuple values, such that all tuples in the backing\n     * source are added to the MOD set, unless already present in the ADD set.\n     * @param {boolean} [fork=false] - If true, returns a forked copy of this\n     *   pulse, and invokes reflow on that derived pulse.\n     * @return {Pulse} - The reflowed pulse instance.\n     */\n    reflow(fork) {\n      if (fork) return this.fork(ALL).reflow();\n      const len = this.add.length,\n            src = this.source && this.source.length;\n\n      if (src && src !== len) {\n        this.mod = this.source;\n        if (len) this.filter(MOD, filter(this, ADD));\n      }\n\n      return this;\n    },\n\n    /**\n     * Get/set metadata to pulse requesting garbage collection\n     * to reclaim currently unused resources.\n     */\n    clean(value) {\n      if (arguments.length) {\n        this.cleans = !!value;\n        return this;\n      } else {\n        return this.cleans;\n      }\n    },\n\n    /**\n     * Marks one or more data field names as modified to assist dependency\n     * tracking and incremental processing by transform operators.\n     * @param {string|Array<string>} _ - The field(s) to mark as modified.\n     * @return {Pulse} - This pulse instance.\n     */\n    modifies(_) {\n      const hash = this.fields || (this.fields = {});\n\n      if (vegaUtil.isArray(_)) {\n        _.forEach(f => hash[f] = true);\n      } else {\n        hash[_] = true;\n      }\n\n      return this;\n    },\n\n    /**\n     * Checks if one or more data fields have been modified during this pulse\n     * propagation timestamp.\n     * @param {string|Array<string>} _ - The field(s) to check for modified.\n     * @param {boolean} nomod - If true, will check the modified flag even if\n     *   no mod tuples exist. If false (default), mod tuples must be present.\n     * @return {boolean} - Returns true if any of the provided fields has been\n     *   marked as modified, false otherwise.\n     */\n    modified(_, nomod) {\n      const fields = this.fields;\n      return !((nomod || this.mod.length) && fields) ? false : !arguments.length ? !!fields : vegaUtil.isArray(_) ? _.some(f => fields[f]) : fields[_];\n    },\n\n    /**\n     * Adds a filter function to one more tuple sets. Filters are applied to\n     * backing tuple arrays, to determine the actual set of tuples considered\n     * added, removed or modified. They can be used to delay materialization of\n     * a tuple set in order to avoid expensive array copies. In addition, the\n     * filter functions can serve as value transformers: unlike standard predicate\n     * function (which return boolean values), Pulse filters should return the\n     * actual tuple value to process. If a tuple set is already filtered, the\n     * new filter function will be appended into a conjuntive ('and') query.\n     * @param {number} flags - Flags indicating the tuple set(s) to filter.\n     * @param {function(*):object} filter - Filter function that will be applied\n     *   to the tuple set array, and should return a data tuple if the value\n     *   should be included in the tuple set, and falsy (or null) otherwise.\n     * @return {Pulse} - Returns this pulse instance.\n     */\n    filter(flags, filter) {\n      const p = this;\n      if (flags & ADD) p.addF = addFilter(p.addF, filter);\n      if (flags & REM) p.remF = addFilter(p.remF, filter);\n      if (flags & MOD) p.modF = addFilter(p.modF, filter);\n      if (flags & SOURCE) p.srcF = addFilter(p.srcF, filter);\n      return p;\n    },\n\n    /**\n     * Materialize one or more tuple sets in this pulse. If the tuple set(s) have\n     * a registered filter function, it will be applied and the tuple set(s) will\n     * be replaced with materialized tuple arrays.\n     * @param {number} flags - Flags indicating the tuple set(s) to materialize.\n     * @return {Pulse} - Returns this pulse instance.\n     */\n    materialize(flags) {\n      flags = flags || ALL;\n      const p = this;\n\n      if (flags & ADD && p.addF) {\n        p.add = materialize(p.add, p.addF);\n        p.addF = null;\n      }\n\n      if (flags & REM && p.remF) {\n        p.rem = materialize(p.rem, p.remF);\n        p.remF = null;\n      }\n\n      if (flags & MOD && p.modF) {\n        p.mod = materialize(p.mod, p.modF);\n        p.modF = null;\n      }\n\n      if (flags & SOURCE && p.srcF) {\n        p.source = p.source.filter(p.srcF);\n        p.srcF = null;\n      }\n\n      return p;\n    },\n\n    /**\n     * Visit one or more tuple sets in this pulse.\n     * @param {number} flags - Flags indicating the tuple set(s) to visit.\n     *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source\n     *   has been set).\n     * @param {function(object):*} - Visitor function invoked per-tuple.\n     * @return {Pulse} - Returns this pulse instance.\n     */\n    visit(flags, visitor) {\n      const p = this,\n            v = visitor;\n\n      if (flags & SOURCE) {\n        vegaUtil.visitArray(p.source, p.srcF, v);\n        return p;\n      }\n\n      if (flags & ADD) vegaUtil.visitArray(p.add, p.addF, v);\n      if (flags & REM) vegaUtil.visitArray(p.rem, p.remF, v);\n      if (flags & MOD) vegaUtil.visitArray(p.mod, p.modF, v);\n      const src = p.source;\n\n      if (flags & REFLOW && src) {\n        const sum = p.add.length + p.mod.length;\n\n        if (sum === src.length) ; else if (sum) {\n          vegaUtil.visitArray(src, filter(p, ADD_MOD), v);\n        } else {\n          // if no add/rem/mod tuples, visit source\n          vegaUtil.visitArray(src, p.srcF, v);\n        }\n      }\n\n      return p;\n    }\n\n  };\n\n  /**\n   * Represents a set of multiple pulses. Used as input for operators\n   * that accept multiple pulses at a time. Contained pulses are\n   * accessible via the public \"pulses\" array property. This pulse doe\n   * not carry added, removed or modified tuples directly. However,\n   * the visit method can be used to traverse all such tuples contained\n   * in sub-pulses with a timestamp matching this parent multi-pulse.\n   * @constructor\n   * @param {Dataflow} dataflow - The backing dataflow instance.\n   * @param {number} stamp - The timestamp.\n   * @param {Array<Pulse>} pulses - The sub-pulses for this multi-pulse.\n   */\n\n  function MultiPulse(dataflow, stamp, pulses, encode) {\n    const p = this,\n          n = pulses.length;\n    let c = 0;\n    this.dataflow = dataflow;\n    this.stamp = stamp;\n    this.fields = null;\n    this.encode = encode || null;\n    this.pulses = pulses;\n\n    for (let i = 0; i < n; ++i) {\n      const pulse = pulses[i];\n      if (pulse.stamp !== stamp) continue;\n\n      if (pulse.fields) {\n        const hash = p.fields || (p.fields = {});\n\n        for (const f in pulse.fields) {\n          hash[f] = 1;\n        }\n      }\n\n      if (pulse.changed(p.ADD)) c |= p.ADD;\n      if (pulse.changed(p.REM)) c |= p.REM;\n      if (pulse.changed(p.MOD)) c |= p.MOD;\n    }\n\n    this.changes = c;\n  }\n  vegaUtil.inherits(MultiPulse, Pulse, {\n    /**\n     * Creates a new pulse based on the values of this pulse.\n     * The dataflow, time stamp and field modification values are copied over.\n     * @return {Pulse}\n     */\n    fork(flags) {\n      const p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);\n\n      if (flags !== undefined) {\n        if (flags & p.ADD) this.visit(p.ADD, t => p.add.push(t));\n        if (flags & p.REM) this.visit(p.REM, t => p.rem.push(t));\n        if (flags & p.MOD) this.visit(p.MOD, t => p.mod.push(t));\n      }\n\n      return p;\n    },\n\n    changed(flags) {\n      return this.changes & flags;\n    },\n\n    modified(_) {\n      const p = this,\n            fields = p.fields;\n      return !(fields && p.changes & p.MOD) ? 0 : vegaUtil.isArray(_) ? _.some(f => fields[f]) : fields[_];\n    },\n\n    filter() {\n      vegaUtil.error('MultiPulse does not support filtering.');\n    },\n\n    materialize() {\n      vegaUtil.error('MultiPulse does not support materialization.');\n    },\n\n    visit(flags, visitor) {\n      const p = this,\n            pulses = p.pulses,\n            n = pulses.length;\n      let i = 0;\n\n      if (flags & p.SOURCE) {\n        for (; i < n; ++i) {\n          pulses[i].visit(flags, visitor);\n        }\n      } else {\n        for (; i < n; ++i) {\n          if (pulses[i].stamp === p.stamp) {\n            pulses[i].visit(flags, visitor);\n          }\n        }\n      }\n\n      return p;\n    }\n\n  });\n\n  /* eslint-disable require-atomic-updates */\n  /**\n   * Evaluates the dataflow and returns a Promise that resolves when pulse\n   * propagation completes. This method will increment the current timestamp\n   * and process all updated, pulsed and touched operators. When invoked for\n   * the first time, all registered operators will be processed. This method\n   * should not be invoked by third-party clients, use {@link runAsync} or\n   * {@link run} instead.\n   * @param {string} [encode] - The name of an encoding set to invoke during\n   *   propagation. This value is added to generated Pulse instances;\n   *   operators can then respond to (or ignore) this setting as appropriate.\n   *   This parameter can be used in conjunction with the Encode transform in\n   *   the vega-encode package.\n   * @param {function} [prerun] - An optional callback function to invoke\n   *   immediately before dataflow evaluation commences.\n   * @param {function} [postrun] - An optional callback function to invoke\n   *   after dataflow evaluation completes. The callback will be invoked\n   *   after those registered via {@link runAfter}.\n   * @return {Promise} - A promise that resolves to this dataflow after\n   *   evaluation completes.\n   */\n\n  async function evaluate(encode, prerun, postrun) {\n    const df = this,\n          async = []; // if the pulse value is set, this is a re-entrant call\n\n    if (df._pulse) return reentrant(df); // wait for pending datasets to load\n\n    if (df._pending) await df._pending; // invoke prerun function, if provided\n\n    if (prerun) await asyncCallback(df, prerun); // exit early if there are no updates\n\n    if (!df._touched.length) {\n      df.debug('Dataflow invoked, but nothing to do.');\n      return df;\n    } // increment timestamp clock\n\n\n    const stamp = ++df._clock; // set the current pulse\n\n    df._pulse = new Pulse(df, stamp, encode); // initialize priority queue, reset touched operators\n\n    df._touched.forEach(op => df._enqueue(op, true));\n\n    df._touched = UniqueList(vegaUtil.id);\n    let count = 0,\n        op,\n        next,\n        error;\n\n    try {\n      while (df._heap.size() > 0) {\n        // dequeue operator with highest priority\n        op = df._heap.pop(); // re-queue if rank changed\n\n        if (op.rank !== op.qrank) {\n          df._enqueue(op, true);\n\n          continue;\n        } // otherwise, evaluate the operator\n\n\n        next = op.run(df._getPulse(op, encode));\n\n        if (next.then) {\n          // await if operator returns a promise directly\n          next = await next;\n        } else if (next.async) {\n          // queue parallel asynchronous execution\n          async.push(next.async);\n          next = StopPropagation;\n        } // propagate evaluation, enqueue dependent operators\n\n\n        if (next !== StopPropagation) {\n          if (op._targets) op._targets.forEach(op => df._enqueue(op));\n        } // increment visit counter\n\n\n        ++count;\n      }\n    } catch (err) {\n      df._heap.clear();\n\n      error = err;\n    } // reset pulse map\n\n\n    df._input = {};\n    df._pulse = null;\n    df.debug(`Pulse ${stamp}: ${count} operators`);\n\n    if (error) {\n      df._postrun = [];\n      df.error(error);\n    } // invoke callbacks queued via runAfter\n\n\n    if (df._postrun.length) {\n      const pr = df._postrun.sort((a, b) => b.priority - a.priority);\n\n      df._postrun = [];\n\n      for (let i = 0; i < pr.length; ++i) {\n        await asyncCallback(df, pr[i].callback);\n      }\n    } // invoke postrun function, if provided\n\n\n    if (postrun) await asyncCallback(df, postrun); // handle non-blocking asynchronous callbacks\n\n    if (async.length) {\n      Promise.all(async).then(cb => df.runAsync(null, () => {\n        cb.forEach(f => {\n          try {\n            f(df);\n          } catch (err) {\n            df.error(err);\n          }\n        });\n      }));\n    }\n\n    return df;\n  }\n  /**\n   * Queues dataflow evaluation to run once any other queued evaluations have\n   * completed and returns a Promise that resolves when the queued pulse\n   * propagation completes. If provided, a callback function will be invoked\n   * immediately before evaluation commences. This method will ensure a\n   * separate evaluation is invoked for each time it is called.\n   * @param {string} [encode] - The name of an encoding set to invoke during\n   *   propagation. This value is added to generated Pulse instances;\n   *   operators can then respond to (or ignore) this setting as appropriate.\n   *   This parameter can be used in conjunction with the Encode transform in\n   *   the vega-encode package.\n   * @param {function} [prerun] - An optional callback function to invoke\n   *   immediately before dataflow evaluation commences.\n   * @param {function} [postrun] - An optional callback function to invoke\n   *   after dataflow evaluation completes. The callback will be invoked\n   *   after those registered via {@link runAfter}.\n   * @return {Promise} - A promise that resolves to this dataflow after\n   *   evaluation completes.\n   */\n\n  async function runAsync(encode, prerun, postrun) {\n    // await previously queued functions\n    while (this._running) await this._running; // run dataflow, manage running promise\n\n\n    const clear = () => this._running = null;\n\n    (this._running = this.evaluate(encode, prerun, postrun)).then(clear, clear);\n    return this._running;\n  }\n  /**\n   * Requests dataflow evaluation and the immediately returns this dataflow\n   * instance. If there are pending data loading or other asynchronous\n   * operations, the dataflow will evaluate asynchronously after this method\n   * has been invoked. To track when dataflow evaluation completes, use the\n   * {@link runAsync} method instead. This method will raise an error if\n   * invoked while the dataflow is already in the midst of evaluation.\n   * @param {string} [encode] - The name of an encoding set to invoke during\n   *   propagation. This value is added to generated Pulse instances;\n   *   operators can then respond to (or ignore) this setting as appropriate.\n   *   This parameter can be used in conjunction with the Encode transform in\n   *   the vega-encode module.\n   * @param {function} [prerun] - An optional callback function to invoke\n   *   immediately before dataflow evaluation commences.\n   * @param {function} [postrun] - An optional callback function to invoke\n   *   after dataflow evaluation completes. The callback will be invoked\n   *   after those registered via {@link runAfter}.\n   * @return {Dataflow} - This dataflow instance.\n   */\n\n  function run(encode, prerun, postrun) {\n    return this._pulse ? reentrant(this) : (this.evaluate(encode, prerun, postrun), this);\n  }\n  /**\n   * Schedules a callback function to be invoked after the current pulse\n   * propagation completes. If no propagation is currently occurring,\n   * the function is invoked immediately. Callbacks scheduled via runAfter\n   * are invoked immediately upon completion of the current cycle, before\n   * any request queued via runAsync. This method is primarily intended for\n   * internal use. Third-party callers using runAfter to schedule a callback\n   * that invokes {@link run} or {@link runAsync} should not use this method,\n   * but instead use {@link runAsync} with prerun or postrun arguments.\n   * @param {function(Dataflow)} callback - The callback function to run.\n   *   The callback will be invoked with this Dataflow instance as its\n   *   sole argument.\n   * @param {boolean} enqueue - A boolean flag indicating that the\n   *   callback should be queued up to run after the next propagation\n   *   cycle, suppressing immediate invocation when propagation is not\n   *   currently occurring.\n   * @param {number} [priority] - A priority value used to sort registered\n   *   callbacks to determine execution order. This argument is intended\n   *   for internal Vega use only.\n   */\n\n  function runAfter(callback, enqueue, priority) {\n    if (this._pulse || enqueue) {\n      // pulse propagation is currently running, queue to run after\n      this._postrun.push({\n        priority: priority || 0,\n        callback: callback\n      });\n    } else {\n      // pulse propagation already complete, invoke immediately\n      try {\n        callback(this);\n      } catch (err) {\n        this.error(err);\n      }\n    }\n  }\n  /**\n   * Raise an error for re-entrant dataflow evaluation.\n   */\n\n  function reentrant(df) {\n    df.error('Dataflow already running. Use runAsync() to chain invocations.');\n    return df;\n  }\n  /**\n   * Enqueue an operator into the priority queue for evaluation. The operator\n   * will be enqueued if it has no registered pulse for the current cycle, or if\n   * the force argument is true. Upon enqueue, this method also sets the\n   * operator's qrank to the current rank value.\n   * @param {Operator} op - The operator to enqueue.\n   * @param {boolean} [force] - A flag indicating if the operator should be\n   *   forceably added to the queue, even if it has already been previously\n   *   enqueued during the current pulse propagation. This is useful when the\n   *   dataflow graph is dynamically modified and the operator rank changes.\n   */\n\n\n  function enqueue(op, force) {\n    const q = op.stamp < this._clock;\n    if (q) op.stamp = this._clock;\n\n    if (q || force) {\n      op.qrank = op.rank;\n\n      this._heap.push(op);\n    }\n  }\n  /**\n   * Provide a correct pulse for evaluating an operator. If the operator has an\n   * explicit source operator, we will try to pull the pulse(s) from it.\n   * If there is an array of source operators, we build a multi-pulse.\n   * Otherwise, we return a current pulse with correct source data.\n   * If the pulse is the pulse map has an explicit target set, we use that.\n   * Else if the pulse on the upstream source operator is current, we use that.\n   * Else we use the pulse from the pulse map, but copy the source tuple array.\n   * @param {Operator} op - The operator for which to get an input pulse.\n   * @param {string} [encode] - An (optional) encoding set name with which to\n   *   annotate the returned pulse. See {@link run} for more information.\n   */\n\n  function getPulse(op, encode) {\n    const s = op.source,\n          stamp = this._clock;\n    return s && vegaUtil.isArray(s) ? new MultiPulse(this, stamp, s.map(_ => _.pulse), encode) : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);\n  }\n\n  function singlePulse(p, s) {\n    if (s && s.stamp === p.stamp) {\n      return s;\n    }\n\n    p = p.fork();\n\n    if (s && s !== StopPropagation) {\n      p.source = s.source;\n    }\n\n    return p;\n  }\n\n  const NO_OPT = {\n    skip: false,\n    force: false\n  };\n  /**\n   * Touches an operator, scheduling it to be evaluated. If invoked outside of\n   * a pulse propagation, the operator will be evaluated the next time this\n   * dataflow is run. If invoked in the midst of pulse propagation, the operator\n   * will be queued for evaluation if and only if the operator has not yet been\n   * evaluated on the current propagation timestamp.\n   * @param {Operator} op - The operator to touch.\n   * @param {object} [options] - Additional options hash.\n   * @param {boolean} [options.skip] - If true, the operator will\n   *   be skipped: it will not be evaluated, but its dependents will be.\n   * @return {Dataflow}\n   */\n\n  function touch(op, options) {\n    const opt = options || NO_OPT;\n\n    if (this._pulse) {\n      // if in midst of propagation, add to priority queue\n      this._enqueue(op);\n    } else {\n      // otherwise, queue for next propagation\n      this._touched.add(op);\n    }\n\n    if (opt.skip) op.skip(true);\n    return this;\n  }\n  /**\n   * Updates the value of the given operator.\n   * @param {Operator} op - The operator to update.\n   * @param {*} value - The value to set.\n   * @param {object} [options] - Additional options hash.\n   * @param {boolean} [options.force] - If true, the operator will\n   *   be re-evaluated even if its value has not changed.\n   * @param {boolean} [options.skip] - If true, the operator will\n   *   be skipped: it will not be evaluated, but its dependents will be.\n   * @return {Dataflow}\n   */\n\n  function update(op, value, options) {\n    const opt = options || NO_OPT;\n\n    if (op.set(value) || opt.force) {\n      this.touch(op, opt);\n    }\n\n    return this;\n  }\n  /**\n   * Pulses an operator with a changeset of tuples. If invoked outside of\n   * a pulse propagation, the pulse will be applied the next time this\n   * dataflow is run. If invoked in the midst of pulse propagation, the pulse\n   * will be added to the set of active pulses and will be applied if and\n   * only if the target operator has not yet been evaluated on the current\n   * propagation timestamp.\n   * @param {Operator} op - The operator to pulse.\n   * @param {ChangeSet} value - The tuple changeset to apply.\n   * @param {object} [options] - Additional options hash.\n   * @param {boolean} [options.skip] - If true, the operator will\n   *   be skipped: it will not be evaluated, but its dependents will be.\n   * @return {Dataflow}\n   */\n\n  function pulse(op, changeset, options) {\n    this.touch(op, options || NO_OPT);\n    const p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)),\n          t = op.pulse && op.pulse.source || [];\n    p.target = op;\n    this._input[op.id] = changeset.pulse(p, t);\n    return this;\n  }\n\n  function Heap(cmp) {\n    let nodes = [];\n    return {\n      clear: () => nodes = [],\n      size: () => nodes.length,\n      peek: () => nodes[0],\n      push: x => {\n        nodes.push(x);\n        return siftdown(nodes, 0, nodes.length - 1, cmp);\n      },\n      pop: () => {\n        const last = nodes.pop();\n        let item;\n\n        if (nodes.length) {\n          item = nodes[0];\n          nodes[0] = last;\n          siftup(nodes, 0, cmp);\n        } else {\n          item = last;\n        }\n\n        return item;\n      }\n    };\n  }\n\n  function siftdown(array, start, idx, cmp) {\n    let parent, pidx;\n    const item = array[idx];\n\n    while (idx > start) {\n      pidx = idx - 1 >> 1;\n      parent = array[pidx];\n\n      if (cmp(item, parent) < 0) {\n        array[idx] = parent;\n        idx = pidx;\n        continue;\n      }\n\n      break;\n    }\n\n    return array[idx] = item;\n  }\n\n  function siftup(array, idx, cmp) {\n    const start = idx,\n          end = array.length,\n          item = array[idx];\n    let cidx = (idx << 1) + 1,\n        ridx;\n\n    while (cidx < end) {\n      ridx = cidx + 1;\n\n      if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {\n        cidx = ridx;\n      }\n\n      array[idx] = array[cidx];\n      idx = cidx;\n      cidx = (idx << 1) + 1;\n    }\n\n    array[idx] = item;\n    return siftdown(array, start, idx, cmp);\n  }\n\n  /**\n   * A dataflow graph for reactive processing of data streams.\n   * @constructor\n   */\n\n  function Dataflow() {\n    this.logger(vegaUtil.logger());\n    this.logLevel(vegaUtil.Error);\n    this._clock = 0;\n    this._rank = 0;\n    this._locale = vegaFormat.defaultLocale();\n\n    try {\n      this._loader = vegaLoader.loader();\n    } catch (e) {// do nothing if loader module is unavailable\n    }\n\n    this._touched = UniqueList(vegaUtil.id);\n    this._input = {};\n    this._pulse = null;\n    this._heap = Heap((a, b) => a.qrank - b.qrank);\n    this._postrun = [];\n  }\n\n  function logMethod(method) {\n    return function () {\n      return this._log[method].apply(this, arguments);\n    };\n  }\n\n  Dataflow.prototype = {\n    /**\n     * The current timestamp of this dataflow. This value reflects the\n     * timestamp of the previous dataflow run. The dataflow is initialized\n     * with a stamp value of 0. The initial run of the dataflow will have\n     * a timestap of 1, and so on. This value will match the\n     * {@link Pulse.stamp} property.\n     * @return {number} - The current timestamp value.\n     */\n    stamp() {\n      return this._clock;\n    },\n\n    /**\n     * Gets or sets the loader instance to use for data file loading. A\n     * loader object must provide a \"load\" method for loading files and a\n     * \"sanitize\" method for checking URL/filename validity. Both methods\n     * should accept a URI and options hash as arguments, and return a Promise\n     * that resolves to the loaded file contents (load) or a hash containing\n     * sanitized URI data with the sanitized url assigned to the \"href\" property\n     * (sanitize).\n     * @param {object} _ - The loader instance to use.\n     * @return {object|Dataflow} - If no arguments are provided, returns\n     *   the current loader instance. Otherwise returns this Dataflow instance.\n     */\n    loader(_) {\n      if (arguments.length) {\n        this._loader = _;\n        return this;\n      } else {\n        return this._loader;\n      }\n    },\n\n    /**\n     * Gets or sets the locale instance to use for formatting and parsing\n     * string values. The locale object should be provided by the\n     * vega-format library, and include methods such as format, timeFormat,\n     * utcFormat, timeParse, and utcParse.\n     * @param {object} _ - The locale instance to use.\n     * @return {object|Dataflow} - If no arguments are provided, returns\n     *   the current locale instance. Otherwise returns this Dataflow instance.\n     */\n    locale(_) {\n      if (arguments.length) {\n        this._locale = _;\n        return this;\n      } else {\n        return this._locale;\n      }\n    },\n\n    /**\n     * Get or set the logger instance used to log messages. If no arguments are\n     * provided, returns the current logger instance. Otherwise, sets the logger\n     * and return this Dataflow instance. Provided loggers must support the full\n     * API of logger objects generated by the vega-util logger method. Note that\n     * by default the log level of the new logger will be used; use the logLevel\n     * method to adjust the log level as needed.\n     */\n    logger(logger) {\n      if (arguments.length) {\n        this._log = logger;\n        return this;\n      } else {\n        return this._log;\n      }\n    },\n\n    /**\n     * Logs an error message. By default, logged messages are written to console\n     * output. The message will only be logged if the current log level is high\n     * enough to permit error messages.\n     */\n    error: logMethod('error'),\n\n    /**\n     * Logs a warning message. By default, logged messages are written to console\n     * output. The message will only be logged if the current log level is high\n     * enough to permit warning messages.\n     */\n    warn: logMethod('warn'),\n\n    /**\n     * Logs a information message. By default, logged messages are written to\n     * console output. The message will only be logged if the current log level is\n     * high enough to permit information messages.\n     */\n    info: logMethod('info'),\n\n    /**\n     * Logs a debug message. By default, logged messages are written to console\n     * output. The message will only be logged if the current log level is high\n     * enough to permit debug messages.\n     */\n    debug: logMethod('debug'),\n\n    /**\n     * Get or set the current log level. If an argument is provided, it\n     * will be used as the new log level.\n     * @param {number} [level] - Should be one of None, Warn, Info\n     * @return {number} - The current log level.\n     */\n    logLevel: logMethod('level'),\n\n    /**\n     * Empty entry threshold for garbage cleaning. Map data structures will\n     * perform cleaning once the number of empty entries exceeds this value.\n     */\n    cleanThreshold: 1e4,\n    // OPERATOR REGISTRATION\n    add,\n    connect,\n    rank,\n    rerank,\n    // OPERATOR UPDATES\n    pulse,\n    touch,\n    update,\n    changeset,\n    // DATA LOADING\n    ingest,\n    parse,\n    preload,\n    request,\n    // EVENT HANDLING\n    events,\n    on,\n    // PULSE PROPAGATION\n    evaluate,\n    run,\n    runAsync,\n    runAfter,\n    _enqueue: enqueue,\n    _getPulse: getPulse\n  };\n\n  /**\n   * Abstract class for operators that process data tuples.\n   * Subclasses must provide a {@link transform} method for operator processing.\n   * @constructor\n   * @param {*} [init] - The initial value for this operator.\n   * @param {object} [params] - The parameters for this operator.\n   * @param {Operator} [source] - The operator from which to receive pulses.\n   */\n\n  function Transform(init, params) {\n    Operator.call(this, init, null, params);\n  }\n  vegaUtil.inherits(Transform, Operator, {\n    /**\n     * Overrides {@link Operator.evaluate} for transform operators.\n     * Internally, this method calls {@link evaluate} to perform processing.\n     * If {@link evaluate} returns a falsy value, the input pulse is returned.\n     * This method should NOT be overridden, instead overrride {@link evaluate}.\n     * @param {Pulse} pulse - the current dataflow pulse.\n     * @return the output pulse for this operator (or StopPropagation)\n     */\n    run(pulse) {\n      if (pulse.stamp < this.stamp) return pulse.StopPropagation;\n      let rv;\n\n      if (this.skip()) {\n        this.skip(false);\n      } else {\n        rv = this.evaluate(pulse);\n      }\n\n      rv = rv || pulse;\n\n      if (rv.then) {\n        rv = rv.then(_ => this.pulse = _);\n      } else if (rv !== pulse.StopPropagation) {\n        this.pulse = rv;\n      }\n\n      return rv;\n    },\n\n    /**\n     * Overrides {@link Operator.evaluate} for transform operators.\n     * Marshalls parameter values and then invokes {@link transform}.\n     * @param {Pulse} pulse - the current dataflow pulse.\n     * @return {Pulse} The output pulse (or StopPropagation). A falsy return\n         value (including undefined) will let the input pulse pass through.\n    */\n    evaluate(pulse) {\n      const params = this.marshall(pulse.stamp),\n            out = this.transform(params, pulse);\n      params.clear();\n      return out;\n    },\n\n    /**\n     * Process incoming pulses.\n     * Subclasses should override this method to implement transforms.\n     * @param {Parameters} _ - The operator parameter values.\n     * @param {Pulse} pulse - The current dataflow pulse.\n     * @return {Pulse} The output pulse (or StopPropagation). A falsy return\n     *   value (including undefined) will let the input pulse pass through.\n     */\n    transform() {}\n\n  });\n\n  const transforms = {};\n  function definition(type) {\n    const t = transform(type);\n    return t && t.Definition || null;\n  }\n  function transform(type) {\n    type = type && type.toLowerCase();\n    return vegaUtil.hasOwnProperty(transforms, type) ? transforms[type] : null;\n  }\n\n  exports.Dataflow = Dataflow;\n  exports.EventStream = EventStream;\n  exports.MultiPulse = MultiPulse;\n  exports.Operator = Operator;\n  exports.Parameters = Parameters;\n  exports.Pulse = Pulse;\n  exports.Transform = Transform;\n  exports.UniqueList = UniqueList;\n  exports.asyncCallback = asyncCallback;\n  exports.changeset = changeset;\n  exports.definition = definition;\n  exports.derive = derive;\n  exports.ingest = ingest$1;\n  exports.isChangeSet = isChangeSet;\n  exports.isTuple = isTuple;\n  exports.rederive = rederive;\n  exports.replace = replace;\n  exports.stableCompare = stableCompare;\n  exports.transform = transform;\n  exports.transforms = transforms;\n  exports.tupleid = tupleid;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n};"],
"names":["shadow$provide","global","require","module","exports","factory","define","amd","globalThis","self","vega","vegaUtil","vegaLoader","vegaFormat","UniqueList","idFunc","$","identity","list","ids","add","_","list.add","id","push","remove","list.remove","idx","indexOf","splice","asyncCallback","df","callback","err","error","ingest$1","datum","t","Object","data","TUPLE_ID_KEY","rederive","d","k","isChangeSet","v","constructor","changeset","rem","mod","remp","modp","clean","reflow","insert","array","n","length","i","a","isFunction","modify","field","value","m","constant","filter","tuple","encode","set","pulse","tuples","f","out","cur","forEach","modifies","slice","Parameters","defineProperty","CACHE","writable","Operator","init","update","params","react","OP_ID","qrank","rank","stamp","flags","_update","parameters","flag","bit","state","arguments","EventStream","apply","receive","STREAM_ID","_filter","_apply","stream","loadPending","accept","pending","Promise","requests","done","pending.done","_pending","onStream","target","options","opt","extend","SKIP","op","undefined","func","e","touch","evaluate","onOperator","source","targets","updater","modified","force","skip","connect","Pulse","dataflow","fields","materialize","visitArray","map","visit","addFilter","b","MultiPulse","pulses","c","hash","p","changed","ADD","REM","MOD","changes","reentrant","singlePulse","s","fork","StopPropagation","Heap","cmp","nodes","clear","size","peek","x","siftdown","pop","last","item","start","end","cidx","ridx","parent","pidx","Dataflow","logger","logLevel","Error","_rank","_clock","_locale","defaultLocale","_loader","loader","_touched","_input","_pulse","_heap","_postrun","logMethod","method","_log","Transform","call","transform","type","toLowerCase","hasOwnProperty","transforms","Symbol","TUPLE_ID","prototype","name","index","o","isArray","NO_PARAMS","_targets","SKIP$1","MODIFIED","initonly","argval","_argval","argops","_argops","deps","PULSE","Array","marshall","detach","run","rv","truthy","consume","_consume","evt","val","trg","preventDefault","stopPropagation","merge","throttle","pause","now","Date","debounce","delay","between","active","ADD_REM","ADD_MOD","ALL","REFLOW","SOURCE","NO_SOURCE","NO_FIELDS","clone","addAll","src","addF","remF","modF","srcF","cleans","runAfter","len","nomod","some","visitor","sum","inherits","NO_OPT","locale","warn","info","debug","cleanThreshold","shift","sources","targetRank","rerank","queue","_enqueue","ingest","format","parse","read","timeParse","utcParse","preload","url","res","request","status","load","context","response","responseType","events","send","document","querySelectorAll","addEventListener","on","fn","prerun","postrun","async","count","next","_getPulse","then","pr","sort","priority","all","cb","runAsync","_running","enqueue","q","getPulse","definition","Definition","derive","isTuple","replace","stableCompare","tupleid"]
}
