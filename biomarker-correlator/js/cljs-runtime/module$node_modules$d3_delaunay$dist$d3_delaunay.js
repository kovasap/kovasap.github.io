shadow$provide.module$node_modules$d3_delaunay$dist$d3_delaunay=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){"object"===typeof exports$jscomp$0&&"undefined"!==typeof module?factory(exports$jscomp$0):"function"===typeof define&&define.amd?define(["exports"],factory):(global=global||self,factory(global.d3=global.d3||{}))})(this,function(exports){function dist(ax,ay,bx,by){ax-=bx;ay-=by;return ax*ax+ay*ay}function orientIfSure(px,py,rx,ry,qx,qy){ry=(ry-py)*(qx-
px);px=(rx-px)*(qy-py);return Math.abs(ry-px)>=3.3306690738754716E-16*Math.abs(ry+px)?ry-px:0}function orient(rx,ry,qx,qy,px,py){return 0>(orientIfSure(px,py,rx,ry,qx,qy)||orientIfSure(rx,ry,qx,qy,px,py)||orientIfSure(qx,qy,px,py,rx,ry))}function quicksort(ids,dists,left,right){if(20>=right-left)for(var i=left+1;i<=right;i++){for(var temp=ids[i],tempDist=dists[temp],j=i-1;j>=left&&dists[ids[j]]>tempDist;)ids[j+1]=ids[j--];ids[j+1]=temp}else{i=left+1;temp=right;swap(ids,left+right>>1,i);dists[ids[left]]>
dists[ids[right]]&&swap(ids,left,right);dists[ids[i]]>dists[ids[right]]&&swap(ids,i,right);dists[ids[left]]>dists[ids[i]]&&swap(ids,left,i);tempDist=ids[i];for(j=dists[tempDist];;){do i++;while(dists[ids[i]]<j);do temp--;while(dists[ids[temp]]>j);if(temp<i)break;swap(ids,i,temp)}ids[left+1]=ids[temp];ids[temp]=tempDist;right-i+1>=temp-left?(quicksort(ids,dists,i,right),quicksort(ids,dists,left,temp-1)):(quicksort(ids,dists,left,temp-1),quicksort(ids,dists,i,right))}}function swap(arr,i,j){const tmp=
arr[i];arr[i]=arr[j];arr[j]=tmp}function defaultGetX(p){return p[0]}function defaultGetY(p){return p[1]}function pointX(p){return p[0]}function pointY(p){return p[1]}function collinear$jscomp$0(d){const {triangles,coords}=d;for(d=0;d<triangles.length;d+=3){const a=2*triangles[d],b=2*triangles[d+1],c=2*triangles[d+2];if(1E-10<(coords[c]-coords[a])*(coords[b+1]-coords[a+1])-(coords[b]-coords[a])*(coords[c+1]-coords[a+1]))return!1}return!0}function jitter(x,y,r){return[x+Math.sin(x+y)*r,y+Math.cos(x-
y)*r]}function*flatIterable(points,fx,fy,that){let i=0;for(const p of points)yield fx.call(that,p,i,points),yield fy.call(that,p,i,points),++i}const EPSILON=Math.pow(2,-52),EDGE_STACK=new Uint32Array(512);class Delaunator{static from(points,getX=defaultGetX,getY=defaultGetY){const n=points.length,coords=new Float64Array(2*n);for(let i=0;i<n;i++){const p=points[i];coords[2*i]=getX(p);coords[2*i+1]=getY(p)}return new Delaunator(coords)}constructor(coords){const n=coords.length>>1;if(0<n&&"number"!==
typeof coords[0])throw Error("Expected coords to contain numbers.");this.coords=coords;coords=Math.max(2*n-5,0);this._triangles=new Uint32Array(3*coords);this._halfedges=new Int32Array(3*coords);this._hashSize=Math.ceil(Math.sqrt(n));this._hullPrev=new Uint32Array(n);this._hullNext=new Uint32Array(n);this._hullTri=new Uint32Array(n);this._hullHash=(new Int32Array(this._hashSize)).fill(-1);this._ids=new Uint32Array(n);this._dists=new Float64Array(n);this.update()}update(){const {coords,_hullPrev:hullPrev,
_hullNext:hullNext,_hullTri:hullTri,_hullHash:hullHash}=this;var n=coords.length>>1,minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;for(var i$jscomp$0=0;i$jscomp$0<n;i$jscomp$0++){var x=coords[2*i$jscomp$0];var JSCompiler_object_inline_x_2185=coords[2*i$jscomp$0+1];x<minX&&(minX=x);JSCompiler_object_inline_x_2185<minY&&(minY=JSCompiler_object_inline_x_2185);x>maxX&&(maxX=x);JSCompiler_object_inline_x_2185>maxY&&(maxY=JSCompiler_object_inline_x_2185);this._ids[i$jscomp$0]=i$jscomp$0}maxX=
(minX+maxX)/2;minY=(minY+maxY)/2;minX=Infinity;for(maxY=0;maxY<n;maxY++)if(i$jscomp$0=dist(maxX,minY,coords[2*maxY],coords[2*maxY+1]),i$jscomp$0<minX){var i0=maxY;minX=i$jscomp$0}minY=coords[2*i0];maxY=coords[2*i0+1];minX=Infinity;for(maxX=0;maxX<n;maxX++)if(maxX!==i0&&(i$jscomp$0=dist(minY,maxY,coords[2*maxX],coords[2*maxX+1]),i$jscomp$0<minX&&0<i$jscomp$0)){var i1=maxX;minX=i$jscomp$0}minX=coords[2*i1];maxX=coords[2*i1+1];JSCompiler_object_inline_x_2185=Infinity;for(i$jscomp$0=0;i$jscomp$0<n;i$jscomp$0++)if(i$jscomp$0!==
i0&&i$jscomp$0!==i1){x=minX-minY;var dy=maxX-maxY;var JSCompiler_object_inline_y_2186=coords[2*i$jscomp$0]-minY;var ey=coords[2*i$jscomp$0+1]-maxY,bl=x*x+dy*dy,cl=JSCompiler_object_inline_y_2186*JSCompiler_object_inline_y_2186+ey*ey,d=.5/(x*ey-dy*JSCompiler_object_inline_y_2186);dy=(ey*bl-dy*cl)*d;x=(x*cl-JSCompiler_object_inline_y_2186*bl)*d;x=dy*dy+x*x;if(x<JSCompiler_object_inline_x_2185){var i2=i$jscomp$0;JSCompiler_object_inline_x_2185=x}}i$jscomp$0=coords[2*i2];x=coords[2*i2+1];if(Infinity===
JSCompiler_object_inline_x_2185){for(i0=0;i0<n;i0++)this._dists[i0]=coords[2*i0]-coords[0]||coords[2*i0+1]-coords[1];quicksort(this._ids,this._dists,0,n-1);i0=new Uint32Array(n);i1=0;for(let i=0,d0=-Infinity;i<n;i++)i2=this._ids[i],this._dists[i2]>d0&&(i0[i1++]=i2,d0=this._dists[i2]);this.hull=i0.subarray(0,i1);this.triangles=new Uint32Array(0);this.halfedges=new Uint32Array(0)}else{orient(minY,maxY,minX,maxX,i$jscomp$0,x)&&(JSCompiler_object_inline_x_2185=i1,JSCompiler_object_inline_y_2186=minX,
bl=maxX,i1=i2,minX=i$jscomp$0,maxX=x,i2=JSCompiler_object_inline_x_2185,i$jscomp$0=JSCompiler_object_inline_y_2186,x=bl);JSCompiler_object_inline_y_2186=minX-minY;JSCompiler_object_inline_x_2185=maxX-maxY;bl=i$jscomp$0-minY;ey=x-maxY;cl=JSCompiler_object_inline_y_2186*JSCompiler_object_inline_y_2186+JSCompiler_object_inline_x_2185*JSCompiler_object_inline_x_2185;d=bl*bl+ey*ey;dy=.5/(JSCompiler_object_inline_y_2186*ey-JSCompiler_object_inline_x_2185*bl);JSCompiler_object_inline_x_2185=minY+(ey*cl-
JSCompiler_object_inline_x_2185*d)*dy;JSCompiler_object_inline_y_2186=maxY+(JSCompiler_object_inline_y_2186*d-bl*cl)*dy;this._cx=JSCompiler_object_inline_x_2185;this._cy=JSCompiler_object_inline_y_2186;for(bl=0;bl<n;bl++)this._dists[bl]=dist(coords[2*bl],coords[2*bl+1],JSCompiler_object_inline_x_2185,JSCompiler_object_inline_y_2186);quicksort(this._ids,this._dists,0,n-1);this._hullStart=i0;n=3;hullNext[i0]=hullPrev[i2]=i1;hullNext[i1]=hullPrev[i0]=i2;hullNext[i2]=hullPrev[i1]=i0;hullTri[i0]=0;hullTri[i1]=
1;hullTri[i2]=2;hullHash.fill(-1);hullHash[this._hashKey(minY,maxY)]=i0;hullHash[this._hashKey(minX,maxX)]=i1;hullHash[this._hashKey(i$jscomp$0,x)]=i2;this.trianglesLen=0;this._addTriangle(i0,i1,i2,-1,-1,-1);for(let k=0,xp,yp;k<this._ids.length;k++){minY=this._ids[k];maxY=coords[2*minY];minX=coords[2*minY+1];if(0<k&&Math.abs(maxY-xp)<=EPSILON&&Math.abs(minX-yp)<=EPSILON)continue;xp=maxY;yp=minX;if(minY===i0||minY===i1||minY===i2)continue;maxX=0;for(let j=0,key=this._hashKey(maxY,minX);j<this._hashSize&&
(maxX=hullHash[(key+j)%this._hashSize],-1===maxX||maxX===hullNext[maxX]);j++);i$jscomp$0=maxX=hullPrev[maxX];let q;for(;q=hullNext[i$jscomp$0],!orient(maxY,minX,coords[2*i$jscomp$0],coords[2*i$jscomp$0+1],coords[2*q],coords[2*q+1]);)if(i$jscomp$0=q,i$jscomp$0===maxX){i$jscomp$0=-1;break}if(-1!==i$jscomp$0){x=this._addTriangle(i$jscomp$0,minY,hullNext[i$jscomp$0],-1,-1,hullTri[i$jscomp$0]);hullTri[minY]=this._legalize(x+2);hullTri[i$jscomp$0]=x;n++;for(JSCompiler_object_inline_x_2185=hullNext[i$jscomp$0];q=
hullNext[JSCompiler_object_inline_x_2185],orient(maxY,minX,coords[2*JSCompiler_object_inline_x_2185],coords[2*JSCompiler_object_inline_x_2185+1],coords[2*q],coords[2*q+1]);)x=this._addTriangle(JSCompiler_object_inline_x_2185,minY,q,hullTri[minY],-1,hullTri[JSCompiler_object_inline_x_2185]),hullTri[minY]=this._legalize(x+2),hullNext[JSCompiler_object_inline_x_2185]=JSCompiler_object_inline_x_2185,n--,JSCompiler_object_inline_x_2185=q;if(i$jscomp$0===maxX)for(;q=hullPrev[i$jscomp$0],orient(maxY,minX,
coords[2*q],coords[2*q+1],coords[2*i$jscomp$0],coords[2*i$jscomp$0+1]);)x=this._addTriangle(q,minY,i$jscomp$0,-1,hullTri[i$jscomp$0],hullTri[q]),this._legalize(x+2),hullTri[q]=x,hullNext[i$jscomp$0]=i$jscomp$0,n--,i$jscomp$0=q;this._hullStart=hullPrev[minY]=i$jscomp$0;hullNext[i$jscomp$0]=hullPrev[JSCompiler_object_inline_x_2185]=minY;hullNext[minY]=JSCompiler_object_inline_x_2185;hullHash[this._hashKey(maxY,minX)]=minY;hullHash[this._hashKey(coords[2*i$jscomp$0],coords[2*i$jscomp$0+1])]=i$jscomp$0}}this.hull=
new Uint32Array(n);for(let i=0,e=this._hullStart;i<n;i++)this.hull[i]=e,e=hullNext[e];this.triangles=this._triangles.subarray(0,this.trianglesLen);this.halfedges=this._halfedges.subarray(0,this.trianglesLen)}}_hashKey(x,y){var JSCompiler_temp_const=Math;x-=this._cx;y-=this._cy;x/=Math.abs(x)+Math.abs(y);return JSCompiler_temp_const.floor.call(JSCompiler_temp_const,(0<y?3-x:1+x)/4*this._hashSize)%this._hashSize}_legalize(a){const {_triangles:triangles,_halfedges:halfedges,coords}=this;let i=0;for(var ar;;){const b=
halfedges[a];var a0=a-a%3;ar=a0+(a+2)%3;if(-1===b){if(0===i)break;a=EDGE_STACK[--i];continue}const b0=b-b%3,bl=b0+(b+2)%3;var p0=triangles[ar],pr=triangles[a],pl=triangles[a0+(a+1)%3];a0=triangles[bl];var px=coords[2*a0],py=coords[2*a0+1];const dx=coords[2*p0]-px,dy=coords[2*p0+1]-py,ex=coords[2*pr]-px;pr=coords[2*pr+1]-py;px=coords[2*pl]-px;py=coords[2*pl+1]-py;pl=ex*ex+pr*pr;const cp=px*px+py*py;if(0>dx*(pr*cp-pl*py)-dy*(ex*cp-pl*px)+(dx*dx+dy*dy)*(ex*py-pr*px)){triangles[a]=a0;triangles[b]=p0;
p0=halfedges[bl];if(-1===p0){a0=this._hullStart;do{if(this._hullTri[a0]===bl){this._hullTri[a0]=a;break}a0=this._hullPrev[a0]}while(a0!==this._hullStart)}this._link(a,p0);this._link(b,halfedges[ar]);this._link(ar,bl);ar=b0+(b+1)%3;i<EDGE_STACK.length&&(EDGE_STACK[i++]=ar)}else{if(0===i)break;a=EDGE_STACK[--i]}}return ar}_link(a,b){this._halfedges[a]=b;-1!==b&&(this._halfedges[b]=a)}_addTriangle(i0,i1,i2,a,b,c){const t=this.trianglesLen;this._triangles[t]=i0;this._triangles[t+1]=i1;this._triangles[t+
2]=i2;this._link(t,a);this._link(t+1,b);this._link(t+2,c);this.trianglesLen+=3;return t}}class Path{constructor(){this._x0=this._y0=this._x1=this._y1=null;this._=""}moveTo(x,y){this._+=`M${this._x0=this._x1=+x},${this._y0=this._y1=+y}`}closePath(){null!==this._x1&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")}lineTo(x,y){this._+=`L${this._x1=+x},${this._y1=+y}`}arc(x,y,r){x=+x;y=+y;r=+r;const x0=x+r,y0=y;if(0>r)throw Error("negative radius");if(null===this._x1)this._+=`M${x0},${y0}`;else if(1E-6<
Math.abs(this._x1-x0)||1E-6<Math.abs(this._y1-y0))this._+="L"+x0+","+y0;r&&(this._+=`A${r},${r},0,1,1,${x-r},${y}A${r},${r},0,1,1,${this._x1=x0},${this._y1=y0}`)}rect(x,y,w,h){this._+=`M${this._x0=this._x1=+x},${this._y0=this._y1=+y}h${+w}v${+h}h${-w}Z`}value(){return this._||null}}class Polygon{constructor(){this._=[]}moveTo(x,y){this._.push([x,y])}closePath(){this._.push(this._[0].slice())}lineTo(x,y){this._.push([x,y])}value(){return this._.length?this._:null}}class Voronoi{constructor(delaunay,
[xmin,ymin,xmax,ymax]=[0,0,960,500]){if(!((xmax=+xmax)>=(xmin=+xmin)&&(ymax=+ymax)>=(ymin=+ymin)))throw Error("invalid bounds");this.delaunay=delaunay;this._circumcenters=new Float64Array(2*delaunay.points.length);this.vectors=new Float64Array(2*delaunay.points.length);this.xmax=xmax;this.xmin=xmin;this.ymax=ymax;this.ymin=ymin;this._init()}update(){this.delaunay.update();this._init();return this}_init(){const {delaunay:{points,hull,triangles},vectors}=this;var circumcenters=this.circumcenters=this._circumcenters.subarray(0,
triangles.length/3*2);for(let i=0,j=0,n=triangles.length,x,y;i<n;i+=3,j+=2){var t1=2*triangles[i],t2=2*triangles[i+1],t3=2*triangles[i+2],x1=points[t1];t1=points[t1+1];var x3=points[t3],y3=points[t3+1];t3=points[t2]-x1;t2=points[t2+1]-t1;var ex=x3-x1;const ey=y3-t1,bl=t3*t3+t2*t2,cl=ex*ex+ey*ey,ab=2*(t3*ey-t2*ex);ab?1E-8>Math.abs(ab)?(x=(x1+x3)/2,y=(t1+y3)/2):(x3=1/ab,x=x1+(ey*bl-t2*cl)*x3,y=t1+(t3*cl-ex*bl)*x3):(x=(x1+x3)/2-1E8*ey,y=(t1+y3)/2+1E8*ex);circumcenters[j]=x;circumcenters[j+1]=y}circumcenters=
hull[hull.length-1];t1=4*circumcenters;t3=points[2*circumcenters];t2=points[2*circumcenters+1];vectors.fill(0);for(ex=0;ex<hull.length;++ex)circumcenters=hull[ex],x1=t1,x3=t3,y3=t2,t1=4*circumcenters,t3=points[2*circumcenters],t2=points[2*circumcenters+1],vectors[x1+2]=vectors[t1]=y3-t2,vectors[x1+3]=vectors[t1+1]=t3-x3}render(context){const buffer=null==context?context=new Path:void 0,{delaunay:{halfedges,inedges,hull},circumcenters,vectors}=this;if(1>=hull.length)return null;for(let i=0,n=halfedges.length;i<
n;++i){var j=halfedges[i];if(!(j<i)){var ti=2*Math.floor(i/3);j=2*Math.floor(j/3);this._renderSegment(circumcenters[ti],circumcenters[ti+1],circumcenters[j],circumcenters[j+1],context)}}ti=hull[hull.length-1];for(j=0;j<hull.length;++j){var h0=ti;ti=hull[j];var t=2*Math.floor(inedges[ti]/3);const x=circumcenters[t];t=circumcenters[t+1];h0*=4;(h0=this._project(x,t,vectors[h0+2],vectors[h0+3]))&&this._renderSegment(x,t,h0[0],h0[1],context)}return buffer&&buffer.value()}renderBounds(context){const buffer=
null==context?context=new Path:void 0;context.rect(this.xmin,this.ymin,this.xmax-this.xmin,this.ymax-this.ymin);return buffer&&buffer.value()}renderCell(i$jscomp$0,context){const buffer=null==context?context=new Path:void 0;i$jscomp$0=this._clip(i$jscomp$0);if(null!==i$jscomp$0&&i$jscomp$0.length){context.moveTo(i$jscomp$0[0],i$jscomp$0[1]);for(var n=i$jscomp$0.length;i$jscomp$0[0]===i$jscomp$0[n-2]&&i$jscomp$0[1]===i$jscomp$0[n-1]&&1<n;)n-=2;for(let i=2;i<n;i+=2)i$jscomp$0[i]===i$jscomp$0[i-2]&&
i$jscomp$0[i+1]===i$jscomp$0[i-1]||context.lineTo(i$jscomp$0[i],i$jscomp$0[i+1]);context.closePath();return buffer&&buffer.value()}}*cellPolygons(){var {delaunay:{points}}=this;for(let i=0,n=points.length/2;i<n;++i)if(points=this.cellPolygon(i))points.index=i,yield points}cellPolygon(i){const polygon=new Polygon;this.renderCell(i,polygon);return polygon.value()}_renderSegment(x0,y0,x1,y1,context){const c0=this._regioncode(x0,y0),c1=this._regioncode(x1,y1);if(0===c0&&0===c1)context.moveTo(x0,y0),context.lineTo(x1,
y1);else if(x0=this._clipSegment(x0,y0,x1,y1,c0,c1))context.moveTo(x0[0],x0[1]),context.lineTo(x0[2],x0[3])}contains(i,x,y){return(x=+x,x!==x)||(y=+y,y!==y)?!1:this.delaunay._step(i,x,y)===i}*neighbors(i){const ci=this._clip(i);if(ci)for(const j of this.delaunay.neighbors(i))if(i=this._clip(j))a:for(let ai=0,li=ci.length;ai<li;ai+=2)for(let aj=0,lj=i.length;aj<lj;aj+=2)if(ci[ai]==i[aj]&&ci[ai+1]==i[aj+1]&&ci[(ai+2)%li]==i[(aj+lj-2)%lj]&&ci[(ai+3)%li]==i[(aj+lj-1)%lj]){yield j;break a}}_cell(i){const {circumcenters,
delaunay:{inedges,halfedges,triangles}}=this,e0=inedges[i];if(-1===e0)return null;const points=[];let e=e0;do{const t=Math.floor(e/3);points.push(circumcenters[2*t],circumcenters[2*t+1]);e=2===e%3?e-2:e+1;if(triangles[e]!==i)break;e=halfedges[e]}while(e!==e0&&-1!==e);return points}_clip(i){if(0===i&&1===this.delaunay.hull.length)return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];const points=this._cell(i);if(null===points)return null;const {vectors:V}=this,v=4*
i;return V[v]||V[v+1]?this._clipInfinite(i,points,V[v],V[v+1],V[v+2],V[v+3]):this._clipFinite(i,points)}_clipFinite(i,points){const n=points.length;let P=null;let x1=points[n-2],y1=points[n-1];let c1=this._regioncode(x1,y1),e1;for(let j=0;j<n;j+=2){var x0=x1;var y0=y1;x1=points[j];y1=points[j+1];var c0=c1;c1=this._regioncode(x1,y1);if(0===c0&&0===c1)e1=0,P?P.push(x1,y1):P=[x1,y1];else{let sx1,sy1;if(0===c0){if(null===(x0=this._clipSegment(x0,y0,x1,y1,c0,c1)))continue;[y0,c0,sx1,sy1]=x0}else{if(null===
(x0=this._clipSegment(x1,y1,x0,y0,c1,c0)))continue;[sx1,sy1,y0,c0]=x0;x0=e1;e1=this._edgecode(y0,c0);x0&&e1&&this._edge(i,x0,e1,P,P.length);P?P.push(y0,c0):P=[y0,c0]}x0=e1;e1=this._edgecode(sx1,sy1);x0&&e1&&this._edge(i,x0,e1,P,P.length);P?P.push(sx1,sy1):P=[sx1,sy1]}}if(P)x0=e1,e1=this._edgecode(P[0],P[1]),x0&&e1&&this._edge(i,x0,e1,P,P.length);else if(this.contains(i,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2))return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];
return P}_clipSegment(x0,y0,x1,y1,c0,c1){for(;;){if(0===c0&&0===c1)return[x0,y0,x1,y1];if(c0&c1)return null;var x=void 0;let y;x=c0||c1;x&8?(x=x0+(x1-x0)*(this.ymax-y0)/(y1-y0),y=this.ymax):x&4?(x=x0+(x1-x0)*(this.ymin-y0)/(y1-y0),y=this.ymin):x&2?(y=y0+(y1-y0)*(this.xmax-x0)/(x1-x0),x=this.xmax):(y=y0+(y1-y0)*(this.xmin-x0)/(x1-x0),x=this.xmin);c0?(x0=x,y0=y,c0=this._regioncode(x0,y0)):(x1=x,y1=y,c1=this._regioncode(x1,y1))}}_clipInfinite(i,points,vx0,vy0,vxn,vyn){points=Array.from(points);let p;
(p=this._project(points[0],points[1],vx0,vy0))&&points.unshift(p[0],p[1]);(p=this._project(points[points.length-2],points[points.length-1],vxn,vyn))&&points.push(p[0],p[1]);if(points=this._clipFinite(i,points))for(let j=0,n=points.length,c0,c1=this._edgecode(points[n-2],points[n-1]);j<n;j+=2)c0=c1,c1=this._edgecode(points[j],points[j+1]),c0&&c1&&(j=this._edge(i,c0,c1,points,j),n=points.length);else this.contains(i,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2)&&(points=[this.xmin,this.ymin,this.xmax,
this.ymin,this.xmax,this.ymax,this.xmin,this.ymax]);return points}_edge(i,e0,e1,P,j){for(;e0!==e1;){let x,y;switch(e0){case 5:e0=4;continue;case 4:e0=6;x=this.xmax;y=this.ymin;break;case 6:e0=2;continue;case 2:e0=10;x=this.xmax;y=this.ymax;break;case 10:e0=8;continue;case 8:e0=9;x=this.xmin;y=this.ymax;break;case 9:e0=1;continue;case 1:e0=5,x=this.xmin,y=this.ymin}P[j]===x&&P[j+1]===y||!this.contains(i,x,y)||(P.splice(j,0,x,y),j+=2)}if(4<P.length)for(i=0;i<P.length;i+=2)if(e0=(i+2)%P.length,e1=(i+
4)%P.length,P[i]===P[e0]&&P[e0]===P[e1]||P[i+1]===P[e0+1]&&P[e0+1]===P[e1+1])P.splice(e0,2),i-=2;return j}_project(x0,y0,vx,vy){let t=Infinity,c,x,y;if(0>vy){if(y0<=this.ymin)return null;(c=(this.ymin-y0)/vy)<t&&(y=this.ymin,x=x0+(t=c)*vx)}else if(0<vy){if(y0>=this.ymax)return null;(c=(this.ymax-y0)/vy)<t&&(y=this.ymax,x=x0+(t=c)*vx)}if(0<vx){if(x0>=this.xmax)return null;(c=(this.xmax-x0)/vx)<t&&(x=this.xmax,y=y0+c*vy)}else if(0>vx){if(x0<=this.xmin)return null;(c=(this.xmin-x0)/vx)<t&&(x=this.xmin,
y=y0+c*vy)}return[x,y]}_edgecode(x,y){return(x===this.xmin?1:x===this.xmax?2:0)|(y===this.ymin?4:y===this.ymax?8:0)}_regioncode(x,y){return(x<this.xmin?1:x>this.xmax?2:0)|(y<this.ymin?4:y>this.ymax?8:0)}}const tau=2*Math.PI,pow=Math.pow;class Delaunay{static from(points,fx=pointX,fy=pointY,that){if("length"in points){const n=points.length,array=new Float64Array(2*n);for(let i=0;i<n;++i){const p=points[i];array[2*i]=fx.call(that,p,i,points);array[2*i+1]=fy.call(that,p,i,points)}points=array}else points=
Float64Array.from(flatIterable(points,fx,fy,that));return new Delaunay(points)}constructor(points){this._delaunator=new Delaunator(points);this.inedges=new Int32Array(points.length/2);this._hullIndex=new Int32Array(points.length/2);this.points=this._delaunator.coords;this._init()}update(){this._delaunator.update();this._init();return this}_init(){var d=this._delaunator;const points=this.points;if(d.hull&&2<d.hull.length&&collinear$jscomp$0(d)){this.collinear=Int32Array.from({length:points.length/
2},(_,i)=>i).sort((i,j)=>points[2*i]-points[2*j]||points[2*i+1]-points[2*j+1]);d=this.collinear[0];var f=this.collinear[this.collinear.length-1];d=[points[2*d],points[2*d+1],points[2*f],points[2*f+1]];d=1E-8*Math.hypot(d[3]-d[1],d[2]-d[0]);for(let i=0,n=points.length/2;i<n;++i)f=jitter(points[2*i],points[2*i+1],d),points[2*i]=f[0],points[2*i+1]=f[1];this._delaunator=new Delaunator(points)}else delete this.collinear;d=this.halfedges=this._delaunator.halfedges;f=this.hull=this._delaunator.hull;const triangles=
this.triangles=this._delaunator.triangles,inedges=this.inedges.fill(-1),hullIndex=this._hullIndex.fill(-1);for(let e=0,n=d.length;e<n;++e){const p=triangles[2===e%3?e-2:e+1];if(-1===d[e]||-1===inedges[p])inedges[p]=e}for(let i=0,n=f.length;i<n;++i)hullIndex[f[i]]=i;2>=f.length&&0<f.length&&(this.triangles=(new Int32Array(3)).fill(-1),this.halfedges=(new Int32Array(3)).fill(-1),this.triangles[0]=f[0],this.triangles[1]=f[1],this.triangles[2]=f[1],inedges[f[0]]=1,2===f.length&&(inedges[f[1]]=0))}voronoi(bounds){return new Voronoi(this,
bounds)}*neighbors(i){const {inedges,hull,_hullIndex,halfedges,triangles,collinear}=this;if(collinear){var l=collinear.indexOf(i);0<l&&(yield collinear[l-1]);l<collinear.length-1&&(yield collinear[l+1])}else{var e0=inedges[i];if(-1!==e0){var e=e0;do{yield(l=triangles[e]);e=2===e%3?e-2:e+1;if(triangles[e]!==i)break;e=halfedges[e];if(-1===e){i=hull[(_hullIndex[i]+1)%hull.length];i!==l&&(yield i);break}}while(e!==e0)}}}find(x,y,i=0){if((x=+x,x!==x)||(y=+y,y!==y))return-1;const i0=i;let c;for(;0<=(c=
this._step(i,x,y))&&c!==i&&c!==i0;)i=c;return c}_step(i,x,y){const {inedges,hull,_hullIndex,halfedges,triangles,points}=this;if(-1===inedges[i]||!points.length)return(i+1)%(points.length>>1);let c=i,dc=pow(x-points[2*i],2)+pow(y-points[2*i+1],2);const e0=inedges[i];let e=e0;do{let t=triangles[e];const dt=pow(x-points[2*t],2)+pow(y-points[2*t+1],2);dt<dc&&(dc=dt,c=t);e=2===e%3?e-2:e+1;if(triangles[e]!==i)break;e=halfedges[e];if(-1===e){e=hull[(_hullIndex[i]+1)%hull.length];if(e!==t&&pow(x-points[2*
e],2)+pow(y-points[2*e+1],2)<dc)return e;break}}while(e!==e0);return c}render(context){const buffer=null==context?context=new Path:void 0,{points,halfedges,triangles}=this;for(let i=0,n=halfedges.length;i<n;++i){var j=halfedges[i];if(j<i)continue;const ti=2*triangles[i];j=2*triangles[j];context.moveTo(points[ti],points[ti+1]);context.lineTo(points[j],points[j+1])}this.renderHull(context);return buffer&&buffer.value()}renderPoints(context,r=2){const buffer=null==context?context=new Path:void 0,{points}=
this;for(let i=0,n=points.length;i<n;i+=2){const x=points[i],y=points[i+1];context.moveTo(x+r,y);context.arc(x,y,r,0,tau)}return buffer&&buffer.value()}renderHull(context){const buffer=null==context?context=new Path:void 0,{hull,points}=this;var h$jscomp$0=2*hull[0];const n=hull.length;context.moveTo(points[h$jscomp$0],points[h$jscomp$0+1]);for(h$jscomp$0=1;h$jscomp$0<n;++h$jscomp$0){const h=2*hull[h$jscomp$0];context.lineTo(points[h],points[h+1])}context.closePath();return buffer&&buffer.value()}hullPolygon(){const polygon=
new Polygon;this.renderHull(polygon);return polygon.value()}renderTriangle(i,context){const buffer=null==context?context=new Path:void 0,{points,triangles}=this,t0=2*triangles[i*=3],t1=2*triangles[i+1];i=2*triangles[i+2];context.moveTo(points[t0],points[t0+1]);context.lineTo(points[t1],points[t1+1]);context.lineTo(points[i],points[i+1]);context.closePath();return buffer&&buffer.value()}*trianglePolygons(){const {triangles}=this;for(let i=0,n=triangles.length/3;i<n;++i)yield this.trianglePolygon(i)}trianglePolygon(i){const polygon=
new Polygon;this.renderTriangle(i,polygon);return polygon.value()}}exports.Delaunay=Delaunay;exports.Voronoi=Voronoi;Object.defineProperty(exports,"__esModule",{value:!0})})}
//# sourceMappingURL=module$node_modules$d3_delaunay$dist$d3_delaunay.js.map
